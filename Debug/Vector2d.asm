; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35217.0 

	TITLE	C:\Users\Hamzzi\Desktop\AI_Practice\Source\VS2010\Buckland_Chapter7 to 10_Raven\Debug\Vector2d.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	__Avx2WmemEnabledWeakValue
;	COMDAT __Avx2WmemEnabledWeakValue
_BSS	SEGMENT
__Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
?_Valid_strftime_specifiers@std@@3QBDB DB 061H		; std::_Valid_strftime_specifiers
	DB	041H
	DB	062H
	DB	042H
	DB	063H
	DB	043H
	DB	064H
	DB	044H
	DB	065H
	DB	046H
	DB	067H
	DB	047H
	DB	068H
	DB	048H
	DB	049H
	DB	06aH
	DB	06dH
	DB	04dH
	DB	06eH
	DB	070H
	DB	072H
	DB	052H
	DB	053H
	DB	074H
	DB	054H
	DB	075H
	DB	055H
	DB	056H
	DB	077H
	DB	057H
	DB	078H
	DB	058H
	DB	079H
	DB	059H
	DB	07aH
	DB	05aH
$SG201405 DB	'invalid argument', 00H
	ORG $+3
$SG201406 DB	'%s', 00H
	ORG $+5
$SG201407 DB	'C:\Program Files\Microsoft Visual Studio\2022\Community\'
	DB	'VC\Tools\MSVC\14.44.35207\include\xmemory', 00H
	ORG $+6
$SG201901 DB	'C:\Program Files\Microsoft Visual Studio\2022\Community\'
	DB	'VC\Tools\MSVC\14.44.35207\include\xlocale', 00H
	ORG $+2
$SG194400 DB	' ', 00H
	ORG $+2
$SG194401 DB	' ', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?fpclassify@@YAHN@Z				; fpclassify
PUBLIC	?fpclassify@@YAHO@Z				; fpclassify
PUBLIC	_fabsl
PUBLIC	_frexpl
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsprintf_s_l
PUBLIC	_sprintf_s
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
PUBLIC	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UBEPBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??1_Iostream_error_category2@std@@UAE@XZ	; std::_Iostream_error_category2::~_Iostream_error_category2
PUBLIC	??_G_Iostream_error_category2@std@@UAEPAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??2_Crt_new_delete@std@@SAPAXI@Z		; std::_Crt_new_delete::operator new
PUBLIC	??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z	; std::_Crt_new_delete::operator new
PUBLIC	??3_Crt_new_delete@std@@SAXPAX@Z		; std::_Crt_new_delete::operator delete
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?_C_str@locale@std@@QBEPBDXZ			; std::locale::_C_str
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z	; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z	; std::_Adl_verify_range<char *,char *>
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	?tolower@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::tolower
PUBLIC	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z		; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?precision@ios_base@std@@QBE_JXZ		; std::ios_base::precision
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?_Stodx_v3@std@@YANPBDPAPADPAH@Z		; std::_Stodx_v3
PUBLIC	?_Stofx_v3@std@@YAMPBDPAPADPAH@Z		; std::_Stofx_v3
PUBLIC	??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUVector2D@@@Z ; operator<<
PUBLIC	??5@YAAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@AAV01@AAUVector2D@@@Z ; operator>>
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Get_index@$0A@@id@locale@std@@QAEIXZ	; std::locale::id::_Get_index<0>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Convert_size@II@std@@YAII@Z			; std::_Convert_size<unsigned int,unsigned int>
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<double>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
PUBLIC	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
PUBLIC	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
PUBLIC	??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
PUBLIC	??$_Float_put_desired_precision@O@std@@YAH_JH@Z	; std::_Float_put_desired_precision<long double>
PUBLIC	??$isfinite@O@@YA_NO@Z				; isfinite<long double>
PUBLIC	??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
PUBLIC	??$_Float_put_desired_precision@N@std@@YAH_JH@Z	; std::_Float_put_desired_precision<double>
PUBLIC	??$isfinite@N@@YA_NN@Z				; isfinite<double>
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$?0$0A@@id@locale@std@@QAE@XZ			; std::locale::id::id<0>
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
PUBLIC	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
PUBLIC	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
PUBLIC	??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
PUBLIC	??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Max_limit@H@std@@YAHXZ			; std::_Max_limit<int>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$begin@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z	; std::begin<char const ,27>
PUBLIC	??$end@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z	; std::end<char const ,27>
PUBLIC	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
PUBLIC	??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z	; std::_Find_elem<char,27>
PUBLIC	??$begin@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z	; std::begin<char const ,29>
PUBLIC	??$end@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z	; std::end<char const ,29>
PUBLIC	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z	; std::_Find_elem<char,29>
PUBLIC	??$reverse@PAD@std@@YAXQAD0@Z			; std::reverse<char *>
PUBLIC	??$_Deallocate@$07@std@@YAXPAXI@Z		; std::_Deallocate<8>
PUBLIC	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
PUBLIC	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Find_unchecked@PBDD@std@@YAPBDPBDQBDABD@Z	; std::_Find_unchecked<char const *,char>
PUBLIC	??$_Get_unwrapped@ABQAD@std@@YA?A_TABQAD@Z	; std::_Get_unwrapped<char * const &>
PUBLIC	??$_To_address@PAD@std@@YA?A_PABQAD@Z		; std::_To_address<char *>
PUBLIC	??$_Reverse_vectorized@$00@std@@YAXPAX0@Z	; std::_Reverse_vectorized<1>
PUBLIC	??$swap@D$0A@@std@@YAXAAD0@Z			; std::swap<char,0>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Could_compare_equal_to_value_type@PBDD@std@@YA_NABD@Z ; std::_Could_compare_equal_to_value_type<char const *,char>
PUBLIC	??$_To_address@PBD@std@@YA?A_PABQBD@Z		; std::_To_address<char const *>
PUBLIC	??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z	; std::_Find_vectorized<char const ,char>
PUBLIC	??$move@AAD@std@@YA$$QADAAD@Z			; std::move<char &>
PUBLIC	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@KLECFGLI@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_0GC@DIOGEBP@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_0GD@GOKHNLI@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GC@FCIPFKFB@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>'::`2'::_Src
PUBLIC	?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>'::`2'::_Src
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@ ; `string'
PUBLIC	??_C@_0GD@HACHJAJP@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_0CL@CMFIACBP@istreambuf_iterator?5is?5not?5dere@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4202a05f20000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__invoke_watson:PROC
EXTRN	__dtest:PROC
EXTRN	__ldtest:PROC
EXTRN	_abs:PROC
EXTRN	_fabs:PROC
EXTRN	_frexp:PROC
EXTRN	__errno:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcspn:PROC
EXTRN	_strlen:PROC
EXTRN	_free:PROC
EXTRN	_strtof:PROC
EXTRN	_strtod:PROC
EXTRN	__calloc_dbg:PROC
EXTRN	__free_dbg:PROC
EXTRN	__malloc_dbg:PROC
EXTRN	__CrtDbgReport:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	___std_reverse_trivially_swappable_1:PROC
EXTRN	___std_find_trivial_1@12:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Iostream_error_category2@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	__Stolx:PROC
EXTRN	__Stoulx:PROC
EXTRN	__Stollx:PROC
EXTRN	__Stoullx:PROC
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD FLAT:??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 00H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category2@std@@@8
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CL@CMFIACBP@istreambuf_iterator?5is?5not?5dere@
CONST	SEGMENT
??_C@_0CL@CMFIACBP@istreambuf_iterator?5is?5not?5dere@ DB 'istreambuf_ite'
	DB	'rator is not dereferenceable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@HACHJAJP@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GD@HACHJAJP@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'44.35207\include\iterator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@
CONST	SEGMENT
??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@ DB 'istreambuf_itera'
	DB	'tor is not incrementable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB
CONST	SEGMENT
?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	050H
	DB	070H
	DB	00H
CONST	ENDS
;	COMDAT ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB
CONST	SEGMENT
?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_0GC@FCIPFKFB@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@FCIPFKFB@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'44.35207\include\xstring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ DB 'string subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@GOKHNLI@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GD@GOKHNLI@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fi'
	DB	'les\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.4'
	DB	'4.35207\include\xutility', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DD FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DD	05H
_DATA	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_0GC@DIOGEBP@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@DIOGEBP@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fi'
	DB	'les\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.4'
	DB	'4.35207\include\xlocale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DD FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DD	FLAT:??_E_Iostream_error_category2@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category2@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@KLECFGLI@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@KLECFGLI@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'44.35207\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	028H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02cH
	DW	0304H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$1
__ehfuncinfo$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01086H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$1
__ehfuncinfo$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
	DB	02eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	06e1H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$1
__ehfuncinfo$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	01a2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	032H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	041H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	057aH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$3
__ehfuncinfo$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	015fH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0185H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0185H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0157H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0157H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0151H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0151H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	030H
	DW	01d7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03cH
	DB	049H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0343H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	032H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$0
__tryblocktable$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$4
__unwindtable$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$3
	DD	00H
	DD	00H
__ehfuncinfo$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	031H
	DB	03eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	0464H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	077H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	025bH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	025bH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	095H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	095H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	091H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	091H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	02bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	027fH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	032H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0
__ehfuncinfo$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0
__ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z$0
__ehfuncinfo$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$3
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$4
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	032H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	050H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	058H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	099H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02dH
	DB	0b5H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	028H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02bH
	DB	0c8H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 500  : _Elem __CRTDECL _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {

	push	ebp
	mov	ebp, esp

; 501  :     // convert char to _Elem using _Cvtvec
; 502  :     return static_cast<_Elem>(static_cast<unsigned char>(_Byte));

	movzx	eax, BYTE PTR __Byte$[ebp]

; 503  : }

	pop	ebp
	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptrnext$1 = -12					; size = 4
__Ptrdest$ = -8						; size = 4
__Count$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 526  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 527  :     // convert C string to _Elem sequence using _Cvtvec
; 528  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR __Count$[ebp], eax

; 529  : 
; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

	push	530					; 00000212H
	push	OFFSET $SG201901
	push	2
	push	1
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	__calloc_dbg
	add	esp, 20					; 00000014H
	mov	DWORD PTR __Ptrdest$[ebp], eax

; 531  : 
; 532  :     if (!_Ptrdest) {

	cmp	DWORD PTR __Ptrdest$[ebp], 0
	jne	SHORT $LN5@Maklocstr

; 533  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
	npad	1
$LN5@Maklocstr:

; 534  :     }
; 535  : 
; 536  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, DWORD PTR __Ptrdest$[ebp]
	mov	DWORD PTR __Ptrnext$1[ebp], edx
	jmp	SHORT $LN4@Maklocstr
$LN2@Maklocstr:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Ptrnext$1[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptrnext$1[ebp], ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@Maklocstr

; 537  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

	mov	eax, DWORD PTR __Ptrnext$1[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 538  :     }

	jmp	SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 539  : 
; 540  :     return _Ptrdest;

	mov	eax, DWORD PTR __Ptrdest$[ebp]
$LN1@Maklocstr:

; 541  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ PROC	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >, COMDAT
; _this$ = ecx

; 86   :     _CONSTEXPR20 ~_Tidy_guard() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 87   :         if (_Target) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy_guard

; 88   :             _Target->_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy
	npad	1
$LN2@Tidy_guard:

; 89   :         }
; 90   :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ENDP	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YA$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1512 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1514 : }

	pop	ebp
	ret	0
??$move@AAD@std@@YA$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 1
??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z PROC	; std::_Find_vectorized<char const ,char>, COMDAT

; 190  : _Ty* _Find_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 191  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 192  : #ifdef _WIN64
; 193  :         return const_cast<_Ty*>(
; 194  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 195  : #else
; 196  :         return const_cast<_Ty*>(
; 197  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 198  : #endif
; 199  :     } else if constexpr (sizeof(_Ty) == 1) {
; 200  :         return const_cast<_Ty*>(

	movzx	eax, BYTE PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	___std_find_trivial_1@12

; 201  :             static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 202  :     } else if constexpr (sizeof(_Ty) == 2) {
; 203  :         return const_cast<_Ty*>(
; 204  :             static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 205  :     } else if constexpr (sizeof(_Ty) == 4) {
; 206  :         return const_cast<_Ty*>(
; 207  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 208  :     } else if constexpr (sizeof(_Ty) == 8) {
; 209  :         return const_cast<_Ty*>(
; 210  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 211  :     } else {
; 212  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 213  :     }
; 214  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z ENDP	; std::_Find_vectorized<char const ,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_To_address@PBD@std@@YA?A_PABQBD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PBD@std@@YA?A_PABQBD@Z PROC		; std::_To_address<char const *>, COMDAT

; 4625 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 4626 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4627 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]

; 4628 : }

	pop	ebp
	ret	0
??$_To_address@PBD@std@@YA?A_PABQBD@Z ENDP		; std::_To_address<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Could_compare_equal_to_value_type@PBDD@std@@YA_NABD@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
__Max$1 = -2						; size = 1
__Min$2 = -1						; size = 1
__Val$ = 8						; size = 4
??$_Could_compare_equal_to_value_type@PBDD@std@@YA_NABD@Z PROC ; std::_Could_compare_equal_to_value_type<char const *,char>, COMDAT

; 6060 : _NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6061 :     // check whether _Val is within the limits of _Elem
; 6062 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 6063 : 
; 6064 :     if constexpr (disjunction_v<
; 6065 : #ifdef __cpp_lib_byte
; 6066 :                       is_same<_Ty, byte>,
; 6067 : #endif // defined(__cpp_lib_byte)
; 6068 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 6069 :         return true;
; 6070 :     } else {
; 6071 :         using _Elem = _Iter_value_t<_InIt>;
; 6072 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 6073 : 
; 6074 :         if constexpr (is_same_v<_Elem, bool>) {
; 6075 :             return _Val == true || _Val == false;
; 6076 :         } else if constexpr (is_signed_v<_Elem>) {
; 6077 :             constexpr _Elem _Min = _STD _Min_limit<_Elem>();

	mov	BYTE PTR __Min$2[ebp], -128		; ffffff80H

; 6078 :             constexpr _Elem _Max = _STD _Max_limit<_Elem>();

	mov	BYTE PTR __Max$1[ebp], 127		; 0000007fH

; 6079 : 
; 6080 :             if constexpr (is_signed_v<_Ty>) {
; 6081 :                 // signed _Elem, signed _Ty
; 6082 :                 return _Min <= _Val && _Val <= _Max;

	mov	eax, DWORD PTR __Val$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -128				; ffffff80H
	jl	SHORT $LN3@Could_comp
	mov	edx, DWORD PTR __Val$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	jg	SHORT $LN3@Could_comp
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@Could_comp
$LN3@Could_comp:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Could_comp:
	movzx	eax, BYTE PTR tv68[ebp]

; 6083 :             } else {
; 6084 :                 // signed _Elem, unsigned _Ty
; 6085 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 6086 :                     // negative values of _Elem can compare equal to values of _Ty
; 6087 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 6088 :                 } else {
; 6089 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 6090 :                     return _Val <= _Max;
; 6091 :                 }
; 6092 :             }
; 6093 :         } else {
; 6094 :             constexpr _Elem _Max = _STD _Max_limit<_Elem>();
; 6095 : 
; 6096 :             if constexpr (is_unsigned_v<_Ty>) {
; 6097 :                 // unsigned _Elem, unsigned _Ty
; 6098 :                 return _Val <= _Max;
; 6099 :             } else {
; 6100 :                 // unsigned _Elem, signed _Ty
; 6101 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 6102 :                     // negative values of _Ty can compare equal to values of _Elem
; 6103 :                     return _Val <= _Max;
; 6104 :                 } else {
; 6105 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 6106 :                     return 0 <= _Val && _Val <= _Max;
; 6107 :                 }
; 6108 :             }
; 6109 :         }
; 6110 :     }
; 6111 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Could_compare_equal_to_value_type@PBDD@std@@YA_NABD@Z ENDP ; std::_Could_compare_equal_to_value_type<char const *,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 0

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]

; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$swap@D$0A@@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -5						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D$0A@@std@@YAXAAD0@Z PROC			; std::swap<char,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$move@AAD@std@@YA$$QADAAD@Z		; std::move<char &>
	add	esp, 4
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR __Tmp$[ebp], cl

; 140  :     _Left    = _STD move(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$move@AAD@std@@YA$$QADAAD@Z		; std::move<char &>
	add	esp, 4
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl

; 141  :     _Right   = _STD move(_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	call	??$move@AAD@std@@YA$$QADAAD@Z		; std::move<char &>
	add	esp, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl

; 142  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@swap
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@swap:
	DD	1
	DD	$LN5@swap
$LN5@swap:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN4@swap
$LN4@swap:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??$swap@D$0A@@std@@YAXAAD0@Z ENDP			; std::swap<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Reverse_vectorized@$00@std@@YAXPAX0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Reverse_vectorized@$00@std@@YAXPAX0@Z PROC		; std::_Reverse_vectorized<1>, COMDAT

; 154  : __declspec(noalias) void _Reverse_vectorized(void* _First, void* _Last) noexcept {

	push	ebp
	mov	ebp, esp

; 155  :     if constexpr (_Nx == 1) {
; 156  :         ::__std_reverse_trivially_swappable_1(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	___std_reverse_trivially_swappable_1
	add	esp, 8

; 157  :     } else if constexpr (_Nx == 2) {
; 158  :         ::__std_reverse_trivially_swappable_2(_First, _Last);
; 159  :     } else if constexpr (_Nx == 4) {
; 160  :         ::__std_reverse_trivially_swappable_4(_First, _Last);
; 161  :     } else if constexpr (_Nx == 8) {
; 162  :         ::__std_reverse_trivially_swappable_8(_First, _Last);
; 163  :     } else {
; 164  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 165  :     }
; 166  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Reverse_vectorized@$00@std@@YAXPAX0@Z ENDP		; std::_Reverse_vectorized<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_To_address@PAD@std@@YA?A_PABQAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAD@std@@YA?A_PABQAD@Z PROC		; std::_To_address<char *>, COMDAT

; 4625 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 4626 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4627 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]

; 4628 : }

	pop	ebp
	ret	0
??$_To_address@PAD@std@@YA?A_PABQAD@Z ENDP		; std::_To_address<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAD@std@@YA?A_TABQAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAD@std@@YA?A_TABQAD@Z PROC		; std::_Get_unwrapped<char * const &>, COMDAT

; 1379 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }

	pop	ebp
	ret	0
??$_Get_unwrapped@ABQAD@std@@YA?A_TABQAD@Z ENDP		; std::_Get_unwrapped<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Find_unchecked@PBDD@std@@YAPBDPBDQBDABD@Z
_TEXT	SEGMENT
__Result$1 = -8						; size = 4
__First_ptr$2 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PBDD@std@@YAPBDPBDQBDABD@Z PROC	; std::_Find_unchecked<char const *,char>, COMDAT

; 6114 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 6115 :     // find first matching _Val; choose optimization
; 6116 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 6117 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 6118 : #if _HAS_CXX20
; 6119 :         if (!_STD is_constant_evaluated())
; 6120 : #endif // _HAS_CXX20
; 6121 :         {
; 6122 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Could_compare_equal_to_value_type@PBDD@std@@YA_NABD@Z ; std::_Could_compare_equal_to_value_type<char const *,char>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@Find_unche

; 6123 :                 return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
	jmp	SHORT $LN1@Find_unche
$LN5@Find_unche:

; 6124 :             }
; 6125 : #if _USE_STD_VECTOR_ALGORITHMS
; 6126 :             const auto _First_ptr = _STD _To_address(_First);

	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_To_address@PBD@std@@YA?A_PABQBD@Z	; std::_To_address<char const *>
	add	esp, 4
	mov	DWORD PTR __First_ptr$2[ebp], eax

; 6127 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_To_address@PBD@std@@YA?A_PABQBD@Z	; std::_To_address<char const *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First_ptr$2[ebp]
	push	eax
	call	??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z ; std::_Find_vectorized<char const ,char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Result$1[ebp], eax

; 6128 :             if constexpr (is_pointer_v<_InIt>) {
; 6129 :                 return _Result;

	mov	eax, DWORD PTR __Result$1[ebp]
	jmp	SHORT $LN1@Find_unche

; 6130 :             } else {
; 6131 :                 return _First + (_Result - _First_ptr);
; 6132 :             }
; 6133 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 6134 :             if constexpr (sizeof(_Iter_value_t<_InIt>) <= 2) {
; 6135 :                 const auto _First_ptr = _STD _To_address(_First);
; 6136 :                 const auto _Count     = static_cast<size_t>(_Last - _First);
; 6137 : 
; 6138 :                 using _Ptr_t = remove_reference_t<_Iter_ref_t<_InIt>>*;
; 6139 :                 _Ptr_t _Result;
; 6140 : 
; 6141 :                 if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 6142 :                     _Result = static_cast<_Ptr_t>(_CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), _Count));
; 6143 :                 } else {
; 6144 :                     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_InIt>) == 2);
; 6145 :                     _Result = reinterpret_cast<_Ptr_t>(const_cast<wchar_t*>(_CSTD wmemchr(
; 6146 :                         reinterpret_cast<const wchar_t*>(_First_ptr), static_cast<wchar_t>(_Val), _Count)));
; 6147 :                 }
; 6148 : 
; 6149 :                 if constexpr (is_pointer_v<_InIt>) {
; 6150 :                     return _Result ? _Result : _Last;
; 6151 :                 } else {
; 6152 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 6153 :                 }
; 6154 :             }
; 6155 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 6156 :         }
; 6157 :     }
; 6158 : 
; 6159 :     for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Find_unche
$LN2@Find_unche:
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 1
	mov	DWORD PTR __First$[ebp], ecx
$LN4@Find_unche:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Find_unche

; 6160 :         if (*_First == _Val) {

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __Val$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN6@Find_unche

; 6161 :             break;

	jmp	SHORT $LN3@Find_unche
$LN6@Find_unche:

; 6162 :         }
; 6163 :     }

	jmp	SHORT $LN2@Find_unche
$LN3@Find_unche:

; 6164 : 
; 6165 :     return _First;

	mov	eax, DWORD PTR __First$[ebp]
$LN1@Find_unche:

; 6166 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked@PBDD@std@@YAPBDPBDQBDABD@Z ENDP	; std::_Find_unchecked<char const *,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1082 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

	push	ebp
	mov	ebp, esp

; 1083 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1084 :         _Left = _STD move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
	add	esp, 4

; 1085 :     }
; 1086 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1524 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 1525 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1526 : }

	pop	ebp
	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -56					; size = 4
__Raw_new$ = -52					; size = 4
__New_ptr$ = -44					; size = 4
__Al$ = -36						; size = 4
__New_capacity$ = -28					; size = 4
__Old_capacity$ = -20					; size = 4
__New_size$ = -16					; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Old_size$[ebp], edx

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Old_capacity$[ebp], edx

; 3035 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3036 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3037 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	ecx, DWORD PTR __New_capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3038 : 
; 3039 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3040 :         _ASAN_STRING_REMOVE(*this);
; 3041 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3042 :         _My_data._Myres       = _New_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [edx+24], eax

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 15	; 0000000fH
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 3046 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	movzx	ecx, BYTE PTR _<_Args_1>$[ebp]
	push	ecx
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 3048 :             _My_data._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3049 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3050 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	movzx	edx, BYTE PTR _<_Args_1>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR __Raw_new$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 3052 :         }
; 3053 : 
; 3054 :         _ASAN_STRING_CREATE(*this);
; 3055 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3056 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN9@Reallocate:
	DD	2
	DD	$LN8@Reallocate
$LN8@Reallocate:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN6@Reallocate
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$ = ecx

; 1556 :             },

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1553 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 1554 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 12					; 0000000cH

; 1555 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 1556 :             },

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -56					; size = 4
__Raw_new$ = -52					; size = 4
__New_ptr$ = -44					; size = 4
__Al$ = -36						; size = 4
__New_capacity$ = -28					; size = 4
__Old_capacity$ = -20					; size = 4
__New_size$ = -16					; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 1
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>, COMDAT
; _this$ = ecx

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Old_size$[ebp], edx

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Old_capacity$[ebp], edx

; 3035 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3036 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3037 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	ecx, DWORD PTR __New_capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3038 : 
; 3039 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3040 :         _ASAN_STRING_REMOVE(*this);
; 3041 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3042 :         _My_data._Myres       = _New_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [edx+24], eax

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 15	; 0000000fH
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 3046 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	movzx	ecx, BYTE PTR _<_Args_2>$[ebp]
	push	ecx
	mov	edx, DWORD PTR _<_Args_1>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Raw_new$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	ecx, DWORD PTR __Old_capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 3048 :             _My_data._Bx._Ptr = _New_ptr;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 3049 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3050 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	movzx	eax, BYTE PTR _<_Args_2>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_1>$[ebp]
	push	ecx
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 3052 :         }
; 3053 : 
; 3054 :         _ASAN_STRING_CREATE(*this);
; 3055 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3056 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN9@Reallocate:
	DD	2
	DD	$LN8@Reallocate
$LN8@Reallocate:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN6@Reallocate
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$ = 20						; size = 4
__Count$ = 24						; size = 4
__Ch$ = 28						; size = 1
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z PROC ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator(), COMDAT
; _this$ = ecx

; 1805 :             },

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1802 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 1803 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Off$[ebp]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 12					; 0000000cH

; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Old_size$[ebp]
	sub	eax, DWORD PTR __Off$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Off$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 1805 :             },

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ENDP ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Deallocate@$07@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07@std@@YAXPAXI@Z PROC			; std::_Deallocate<8>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
	add	esp, 8
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, DWORD PTR __Bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 290  :     }
; 291  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07@std@@YAXPAXI@Z ENDP			; std::_Deallocate<8>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QAE@XZ		; std::locale::id::id<0>
	npad	1
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1171 : __PURE_APPDOMAIN_GLOBAL locale::id num_get<_Elem, _InIt>::id;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QAE@XZ		; std::locale::id::id<0>
	npad	1
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$reverse@PAD@std@@YAXQAD0@Z
_TEXT	SEGMENT
__Nx$ = -32						; size = 4
__Allow_vectorization$ = -25				; size = 1
__ULast$ = -20						; size = 4
__UFirst$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$reverse@PAD@std@@YAXQAD0@Z PROC			; std::reverse<char *>, COMDAT

; 6505 : _CONSTEXPR20 void reverse(const _BidIt _First, const _BidIt _Last) { // reverse elements in [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 6506 :     _STD _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z ; std::_Adl_verify_range<char *,char *>
	add	esp, 8

; 6507 :     auto _UFirst = _STD _Get_unwrapped(_First);

	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Get_unwrapped@ABQAD@std@@YA?A_TABQAD@Z ; std::_Get_unwrapped<char * const &>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 6508 :     auto _ULast  = _STD _Get_unwrapped(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAD@std@@YA?A_TABQAD@Z ; std::_Get_unwrapped<char * const &>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 6509 : #if _USE_STD_VECTOR_ALGORITHMS
; 6510 :     using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
; 6511 :     constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,

	mov	BYTE PTR __Allow_vectorization$[ebp], 1

; 6512 :         _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
; 6513 :     constexpr size_t _Nx                = sizeof(_Elem);

	mov	DWORD PTR __Nx$[ebp], 1

; 6514 : 
; 6515 :     if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
; 6516 : #if _HAS_CXX20
; 6517 :         if (!_STD is_constant_evaluated())
; 6518 : #endif // _HAS_CXX20
; 6519 :         {
; 6520 :             _STD _Reverse_vectorized<_Nx>(_STD _To_address(_UFirst), _STD _To_address(_ULast));

	lea	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	call	??$_To_address@PAD@std@@YA?A_PABQAD@Z	; std::_To_address<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_To_address@PAD@std@@YA?A_PABQAD@Z	; std::_To_address<char *>
	add	esp, 4
	push	eax
	call	??$_Reverse_vectorized@$00@std@@YAXPAX0@Z ; std::_Reverse_vectorized<1>
	add	esp, 8

; 6521 :             return;

	jmp	SHORT $LN1@reverse

; 6522 :         }
; 6523 :     }
; 6524 : #endif // _USE_STD_VECTOR_ALGORITHMS
; 6525 : 
; 6526 :     for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {

	jmp	SHORT $LN4@reverse
$LN2@reverse:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 1
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@reverse:
	mov	ecx, DWORD PTR __UFirst$[ebp]
	cmp	ecx, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@reverse
	mov	edx, DWORD PTR __ULast$[ebp]
	sub	edx, 1
	mov	DWORD PTR __ULast$[ebp], edx
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@reverse

; 6527 :         swap(*_UFirst, *_ULast); // intentional ADL

	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$swap@D$0A@@std@@YAXAAD0@Z		; std::swap<char,0>
	add	esp, 8

; 6528 :     }

	jmp	SHORT $LN2@reverse
$LN3@reverse:
$LN1@reverse:

; 6529 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@reverse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@reverse:
	DD	2
	DD	$LN8@reverse
$LN8@reverse:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN6@reverse
	DD	-20					; ffffffecH
	DD	4
	DD	$LN7@reverse
$LN7@reverse:
	DB	95					; 0000005fH
	DB	85					; 00000055H
	DB	76					; 0000004cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN6@reverse:
	DB	95					; 0000005fH
	DB	85					; 00000055H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
??$reverse@PAD@std@@YAXQAD0@Z ENDP			; std::reverse<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z PROC	; std::_Find_elem<char,29>, COMDAT

; 67   : size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch) {

	push	ebp
	mov	ebp, esp

; 68   :     // lookup _Ch in array storing NUL-terminated string _Base
; 69   :     // pre: _Base contains no nulls except for _Base[_Base_size - 1]
; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Base$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	call	??$_Find_unchecked@PBDD@std@@YAPBDPBDQBDABD@Z ; std::_Find_unchecked<char const *,char>
	add	esp, 12					; 0000000cH
	sub	eax, DWORD PTR __Base$[ebp]

; 71   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ENDP	; std::_Find_elem<char,29>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$end@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z
_TEXT	SEGMENT
__Array$ = 8						; size = 4
??$end@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z PROC		; std::end<char const ,29>, COMDAT

; 2031 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {

	push	ebp
	mov	ebp, esp

; 2032 :     return _Array + _Size;

	mov	eax, DWORD PTR __Array$[ebp]
	add	eax, 29					; 0000001dH

; 2033 : }

	pop	ebp
	ret	0
??$end@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z ENDP		; std::end<char const ,29>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$begin@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z
_TEXT	SEGMENT
__Array$ = 8						; size = 4
??$begin@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z PROC	; std::begin<char const ,29>, COMDAT

; 2026 : _NODISCARD constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {

	push	ebp
	mov	ebp, esp

; 2027 :     return _Array;

	mov	eax, DWORD PTR __Array$[ebp]

; 2028 : }

	pop	ebp
	ret	0
??$begin@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z ENDP	; std::begin<char const ,29>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z PROC	; std::_Find_elem<char,27>, COMDAT

; 67   : size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch) {

	push	ebp
	mov	ebp, esp

; 68   :     // lookup _Ch in array storing NUL-terminated string _Base
; 69   :     // pre: _Base contains no nulls except for _Base[_Base_size - 1]
; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Base$[ebp]
	add	ecx, 26					; 0000001aH
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	call	??$_Find_unchecked@PBDD@std@@YAPBDPBDQBDABD@Z ; std::_Find_unchecked<char const *,char>
	add	esp, 12					; 0000000cH
	sub	eax, DWORD PTR __Base$[ebp]

; 71   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z ENDP	; std::_Find_elem<char,27>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator!=<char,std::char_traits<char> >, COMDAT

; 494  :     const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 495  :     return !(_Left == _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[ebp]

; 496  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$end@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z
_TEXT	SEGMENT
__Array$ = 8						; size = 4
??$end@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z PROC		; std::end<char const ,27>, COMDAT

; 2031 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {

	push	ebp
	mov	ebp, esp

; 2032 :     return _Array + _Size;

	mov	eax, DWORD PTR __Array$[ebp]
	add	eax, 27					; 0000001bH

; 2033 : }

	pop	ebp
	ret	0
??$end@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z ENDP		; std::end<char const ,27>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$begin@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z
_TEXT	SEGMENT
__Array$ = 8						; size = 4
??$begin@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z PROC	; std::begin<char const ,27>, COMDAT

; 2026 : _NODISCARD constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {

	push	ebp
	mov	ebp, esp

; 2027 :     return _Array;

	mov	eax, DWORD PTR __Array$[ebp]

; 2028 : }

	pop	ebp
	ret	0
??$begin@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z ENDP	; std::begin<char const ,27>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[ebp]
	add	eax, 39					; 00000027H
	mov	DWORD PTR __Block_size$[ebp], eax

; 185  :     if (_Block_size <= _Bytes) {

	mov	ecx, DWORD PTR __Block_size$[ebp]
	cmp	ecx, DWORD PTR __Bytes$[ebp]
	ja	SHORT $LN2@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	edx, DWORD PTR __Block_size$[ebp]
	push	edx
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	mov	DWORD PTR __Ptr_container$[ebp], eax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	DWORD PTR __Ptr_container$[ebp], 0
	jne	SHORT $LN3@Allocate_m
	push	OFFSET $SG201405
	push	OFFSET $SG201406
	push	0
	push	190					; 000000beH
	push	OFFSET $SG201407
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN5@Allocate_m
	int	3
$LN5@Allocate_m:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN3@Allocate_m:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	ecx, DWORD PTR __Ptr_container$[ebp]
	add	ecx, 39					; 00000027H
	and	ecx, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$[ebp], ecx

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	edx, 4
	imul	eax, edx, -1
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+ecx], -84215046		; fafafafaH

; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN1@Allocate_m:

; 198  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$_Max_limit@H@std@@YAHXZ
_TEXT	SEGMENT
__Unsigned_max$1 = -4					; size = 4
??$_Max_limit@H@std@@YAHXZ PROC				; std::_Max_limit<int>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

	push	ebp
	mov	ebp, esp
	push	ecx

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	DWORD PTR __Unsigned_max$1[ebp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	eax, 2147483647				; 7fffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Max_limit@H@std@@YAHXZ ENDP				; std::_Max_limit<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	push	ebp
	mov	ebp, esp

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	pop	ebp
	ret	0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
_TEXT	SEGMENT
tv198 = -120						; size = 4
tv190 = -116						; size = 4
tv192 = -112						; size = 4
tv191 = -108						; size = 4
tv162 = -104						; size = 4
tv209 = -100						; size = 4
tv78 = -96						; size = 4
$T2 = -92						; size = 4
$T3 = -88						; size = 8
__Field$4 = -80						; size = 4
__Off$5 = -76						; size = 4
__Prefix$6 = -69					; size = 1
__Column$7 = -68					; size = 4
__Ans$ = -64						; size = 4
__CType$ = -60						; size = 4
__Str$ = -52						; size = 28
__Off$8 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Numfields$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Matching$ = 24					; size = 1
??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z PROC ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>, COMDAT

; 3313 :     _InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr, const _Case_sensitive _Matching) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-120]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3314 :     // find field at _Ptr that matches longest in [_First, _Last)
; 3315 :     for (size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off) {

	mov	DWORD PTR __Off$8[ebp], 0
	jmp	SHORT $LN4@Getloctxt
$LN2@Getloctxt:
	mov	eax, DWORD PTR __Off$8[ebp]
	add	eax, 1
	mov	DWORD PTR __Off$8[ebp], eax
$LN4@Getloctxt:
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Off$8[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@Getloctxt

; 3316 :         if (_Ptr[_Off] == _Ptr[0]) {

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Off$8[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR __Ptr$[ebp]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	ecx, eax
	jne	SHORT $LN13@Getloctxt

; 3317 :             ++_Numfields; // add fields with leading mark to initial count

	mov	ecx, DWORD PTR __Numfields$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Numfields$[ebp], ecx
$LN13@Getloctxt:

; 3318 :         }
; 3319 :     }

	jmp	SHORT $LN2@Getloctxt
$LN3@Getloctxt:

; 3320 : 
; 3321 :     string _Str(_Numfields, '\0'); // one column counter for each field

	push	0
	mov	edx, DWORD PTR __Numfields$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3322 :     const ctype<_Elem>& _CType = _STD use_facet<ctype<_Elem>>(locale{});

	lea	ecx, DWORD PTR $T3[ebp]
	call	??0locale@std@@QAE@XZ			; std::locale::locale
	mov	DWORD PTR tv78[ebp], eax
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv209[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv209[ebp]
	push	ecx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __CType$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 3323 : 
; 3324 :     int _Ans = -2; // no candidates so far

	mov	DWORD PTR __Ans$[ebp], -2		; fffffffeH

; 3325 :     for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { // test each element against all viable fields

	mov	DWORD PTR __Column$7[ebp], 1
	jmp	SHORT $LN7@Getloctxt
$LN5@Getloctxt:
	mov	edx, DWORD PTR __Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR __Column$7[ebp], edx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	mov	DWORD PTR __Ans$[ebp], -1
$LN7@Getloctxt:

; 3326 :         bool _Prefix  = false; // seen at least one valid prefix

	mov	BYTE PTR __Prefix$6[ebp], 0

; 3327 :         size_t _Off   = 0; // offset into fields

	mov	DWORD PTR __Off$5[ebp], 0

; 3328 :         size_t _Field = 0; // current field number

	mov	DWORD PTR __Field$4[ebp], 0

; 3329 : 
; 3330 :         for (; _Field < _Numfields; ++_Field) { // test element at _Column in field _Field

	jmp	SHORT $LN10@Getloctxt
$LN8@Getloctxt:
	mov	eax, DWORD PTR __Field$4[ebp]
	add	eax, 1
	mov	DWORD PTR __Field$4[ebp], eax
$LN10@Getloctxt:
	mov	ecx, DWORD PTR __Field$4[ebp]
	cmp	ecx, DWORD PTR __Numfields$[ebp]
	jae	$LN9@Getloctxt
$LN11@Getloctxt:

; 3331 :             while (_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0]) { // find beginning of field

	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, DWORD PTR __Off$5[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN12@Getloctxt
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Off$5[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR __Ptr$[ebp]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	edx, ecx
	je	SHORT $LN12@Getloctxt

; 3332 :                 ++_Off;

	mov	edx, DWORD PTR __Off$5[ebp]
	add	edx, 1
	mov	DWORD PTR __Off$5[ebp], edx

; 3333 :             }

	jmp	SHORT $LN11@Getloctxt
$LN12@Getloctxt:

; 3334 : 
; 3335 :             if (_Str[_Field] != '\0') {

	mov	eax, DWORD PTR __Field$4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN14@Getloctxt

; 3336 :                 _Off += _Str[_Field]; // skip tested columns in field

	mov	edx, DWORD PTR __Field$4[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	add	eax, DWORD PTR __Off$5[ebp]
	mov	DWORD PTR __Off$5[ebp], eax

; 3337 :             } else if (_Ptr[_Off += _Column] == _Ptr[0]

	jmp	$LN20@Getloctxt
$LN14@Getloctxt:

; 3338 :                        || _Ptr[_Off] == _Elem{}) { // matched all of field, save as possible answer

	mov	ecx, DWORD PTR __Off$5[ebp]
	add	ecx, DWORD PTR __Column$7[ebp]
	mov	DWORD PTR __Off$5[ebp], ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, DWORD PTR __Off$5[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	je	SHORT $LN18@Getloctxt
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Off$5[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN16@Getloctxt
$LN18@Getloctxt:

; 3339 :                 _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); // save skip count if small enough

	cmp	DWORD PTR __Column$7[ebp], 127		; 0000007fH
	jae	SHORT $LN25@Getloctxt
	mov	edx, DWORD PTR __Column$7[ebp]
	mov	DWORD PTR tv162[ebp], edx
	jmp	SHORT $LN26@Getloctxt
$LN25@Getloctxt:
	mov	DWORD PTR tv162[ebp], 127		; 0000007fH
$LN26@Getloctxt:
	mov	eax, DWORD PTR __Field$4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	cl, BYTE PTR tv162[ebp]
	mov	BYTE PTR [eax], cl

; 3340 :                 _Ans         = static_cast<int>(_Field); // save answer

	mov	edx, DWORD PTR __Field$4[ebp]
	mov	DWORD PTR __Ans$[ebp], edx

; 3341 :             } else if (_First == _Last

	jmp	$LN20@Getloctxt
$LN16@Getloctxt:

; 3342 :                        || (_Matching == _Case_sensitive::_Yes

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	$LN21@Getloctxt
	cmp	BYTE PTR __Matching$[ebp], 1
	jne	SHORT $LN31@Getloctxt
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Off$5[ebp]
	movsx	esi, BYTE PTR [eax]
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN29@Getloctxt
	mov	DWORD PTR tv191[ebp], 1
	jmp	SHORT $LN30@Getloctxt
$LN29@Getloctxt:
	mov	DWORD PTR tv191[ebp], 0
$LN30@Getloctxt:
	mov	edx, DWORD PTR tv191[ebp]
	mov	DWORD PTR tv192[ebp], edx
	jmp	SHORT $LN32@Getloctxt
$LN31@Getloctxt:
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Off$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __CType$[ebp]
	call	?tolower@?$ctype@D@std@@QBEDD@Z		; std::ctype<char>::tolower
	movsx	esi, al
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	edx, al
	push	edx
	mov	ecx, DWORD PTR __CType$[ebp]
	call	?tolower@?$ctype@D@std@@QBEDD@Z		; std::ctype<char>::tolower
	movsx	eax, al
	cmp	esi, eax
	je	SHORT $LN27@Getloctxt
	mov	DWORD PTR tv190[ebp], 1
	jmp	SHORT $LN28@Getloctxt
$LN27@Getloctxt:
	mov	DWORD PTR tv190[ebp], 0
$LN28@Getloctxt:
	mov	ecx, DWORD PTR tv190[ebp]
	mov	DWORD PTR tv192[ebp], ecx
$LN32@Getloctxt:
	cmp	DWORD PTR tv192[ebp], 0
	je	SHORT $LN19@Getloctxt
$LN21@Getloctxt:

; 3343 :                                ? _Ptr[_Off] != *_First
; 3344 :                                : _CType.tolower(_Ptr[_Off]) != _CType.tolower(static_cast<_Elem>(*_First)))) {
; 3345 :                 _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); // no match, just save skip count

	cmp	DWORD PTR __Column$7[ebp], 127		; 0000007fH
	jae	SHORT $LN33@Getloctxt
	mov	edx, DWORD PTR __Column$7[ebp]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN34@Getloctxt
$LN33@Getloctxt:
	mov	DWORD PTR tv198[ebp], 127		; 0000007fH
$LN34@Getloctxt:
	mov	eax, DWORD PTR __Field$4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	cl, BYTE PTR tv198[ebp]
	mov	BYTE PTR [eax], cl

; 3346 :             } else {

	jmp	SHORT $LN20@Getloctxt
$LN19@Getloctxt:

; 3347 :                 _Prefix = true; // still a valid prefix

	mov	BYTE PTR __Prefix$6[ebp], 1
$LN20@Getloctxt:

; 3348 :             }
; 3349 :         }

	jmp	$LN8@Getloctxt
$LN9@Getloctxt:

; 3350 : 
; 3351 :         if (!_Prefix || _First == _Last) {

	movzx	edx, BYTE PTR __Prefix$6[ebp]
	test	edx, edx
	je	SHORT $LN23@Getloctxt
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@Getloctxt
$LN23@Getloctxt:

; 3352 :             break; // no pending prefixes or no input, give up

	jmp	SHORT $LN6@Getloctxt
$LN22@Getloctxt:

; 3353 :         }
; 3354 :     }

	jmp	$LN5@Getloctxt
$LN6@Getloctxt:

; 3355 :     return _Ans; // return field number or negative value on failure

	mov	eax, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]

; 3356 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN40@Getloctxt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 120				; 00000078H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@Getloctxt:
	DD	1
	DD	$LN39@Getloctxt
$LN39@Getloctxt:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$LN37@Getloctxt
$LN37@Getloctxt:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z ENDP ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
_TEXT	SEGMENT
tv625 = -372						; size = 4
tv610 = -365						; size = 1
tv603 = -364						; size = 4
tv597 = -360						; size = 4
tv587 = -356						; size = 4
tv540 = -352						; size = 4
tv519 = -348						; size = 4
tv516 = -344						; size = 4
tv443 = -340						; size = 4
tv438 = -336						; size = 4
tv432 = -329						; size = 1
tv426 = -328						; size = 4
tv298 = -324						; size = 4
tv227 = -320						; size = 4
tv92 = -313						; size = 1
$T2 = -312						; size = 2
$T3 = -310						; size = 2
$T4 = -308						; size = 4
$T5 = -304						; size = 2
$T6 = -302						; size = 2
$T7 = -300						; size = 4
$T8 = -296						; size = 2
$T9 = -294						; size = 2
__Exponent_part_abs$10 = -292				; size = 4
__Rev_begin$11 = -288					; size = 4
__Exp_rep_adjustment$12 = -284				; size = 4
__Exponent_part_preadjustment_round_up$13 = -276	; size = 4
__Power_of_rep_adjusted$14 = -268			; size = 4
__Exp_rep_abs_bound$ = -264				; size = 4
__Exp_abs_bound$ = -260					; size = 4
__Hex_exp_abs_bound$ = -256				; size = 4
__Dec_exp_abs_bound$ = -252				; size = 4
__Idx$15 = -248						; size = 4
__Exponent_part$ = -244					; size = 4
__Exponent_part_negative$ = -239			; size = 1
__Upper_exp_wc$ = -238					; size = 1
__Lower_exp_wc$ = -237					; size = 1
__Last_got_digit$16 = -236				; size = 4
__Idx$17 = -232						; size = 4
__Decimal_point$ = -226					; size = 1
__Current_grouping_count$18 = -225			; size = 1
__Grouping_end$19 = -224				; size = 4
__Grouping_iter$20 = -220				; size = 4
__Idx$21 = -216						; size = 4
__Groups_arr_idx$22 = -212				; size = 4
__Groups$23 = -204					; size = 28
__Idx$24 = -172						; size = 4
__Offset_digit_end$ = -168				; size = 4
__Power_of_rep_base$ = -164				; size = 4
__Significant$ = -160					; size = 4
__Has_unaccumulated_digits$ = -154			; size = 1
__Initial_dec_leading_zero$ = -153			; size = 1
__Seendigit$ = -152					; size = 1
__Parse_hex$ = -151					; size = 1
__Bad_grouping$ = -150					; size = 1
__Kseparator$ = -149					; size = 1
__Grouping$ = -144					; size = 28
__Punct_fac$ = -112					; size = 4
__Zero_wc$ = -107					; size = 1
__Negative_sign$ = -106					; size = 1
__Positive_sign$ = -105					; size = 1
__Ctype_fac$ = -104					; size = 4
__Atoms$ = -96						; size = 29
__Offset_lower_e$ = -60					; size = 4
__Offset_upper_e$ = -56					; size = 4
__Offset_lower_p$ = -52					; size = 4
__Offset_upper_p$ = -48					; size = 4
__Offset_lower_x$ = -44					; size = 4
__Offset_upper_x$ = -40					; size = 4
__Offset_pos_sign$ = -36				; size = 4
__Offset_neg_sign$ = -32				; size = 4
__Offset_hex_digit_end$ = -28				; size = 4
__Offset_dec_digit_end$ = -24				; size = 4
__Ptr$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ac$ = 8						; size = 4
__Max_sig_dig$ = 12					; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Loc$ = 24						; size = 4
??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>, COMDAT

; 805  :         char* const _Ac, const int _Max_sig_dig, _InIt& _First, _InIt& _Last, const locale& _Loc) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 806  :         // get floating-point field from [_First, _Last) into _Ac
; 807  :         char* _Ptr = _Ac;

	mov	eax, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 808  : 
; 809  :         constexpr size_t _Offset_dec_digit_end = 10;

	mov	DWORD PTR __Offset_dec_digit_end$[ebp], 10 ; 0000000aH

; 810  :         constexpr size_t _Offset_hex_digit_end = 22;

	mov	DWORD PTR __Offset_hex_digit_end$[ebp], 22 ; 00000016H

; 811  :         constexpr size_t _Offset_neg_sign      = 22;

	mov	DWORD PTR __Offset_neg_sign$[ebp], 22	; 00000016H

; 812  :         constexpr size_t _Offset_pos_sign      = 23;

	mov	DWORD PTR __Offset_pos_sign$[ebp], 23	; 00000017H

; 813  :         constexpr size_t _Offset_upper_x       = 24;

	mov	DWORD PTR __Offset_upper_x$[ebp], 24	; 00000018H

; 814  :         constexpr size_t _Offset_lower_x       = 25;

	mov	DWORD PTR __Offset_lower_x$[ebp], 25	; 00000019H

; 815  :         constexpr size_t _Offset_upper_p       = 26;

	mov	DWORD PTR __Offset_upper_p$[ebp], 26	; 0000001aH

; 816  :         constexpr size_t _Offset_lower_p       = 27;

	mov	DWORD PTR __Offset_lower_p$[ebp], 27	; 0000001bH

; 817  :         constexpr size_t _Offset_upper_e       = 14;

	mov	DWORD PTR __Offset_upper_e$[ebp], 14	; 0000000eH

; 818  :         constexpr size_t _Offset_lower_e       = 20;

	mov	DWORD PTR __Offset_lower_e$[ebp], 20	; 00000014H

; 819  :         static constexpr char _Src[]           = "0123456789ABCDEFabcdef-+XxPp";
; 820  :         _Elem _Atoms[sizeof(_Src)];
; 821  :         const auto& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);

	mov	ecx, DWORD PTR __Loc$[ebp]
	push	ecx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax

; 822  :         _Ctype_fac.widen(_STD begin(_Src), _STD end(_Src), _Atoms);

	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	push	OFFSET ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>'::`2'::_Src
	call	??$end@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z ; std::end<char const ,29>
	add	esp, 4
	push	eax
	push	OFFSET ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>'::`2'::_Src
	call	??$begin@$$CBD$0BN@@std@@YAPBDAAY0BN@$$CBD@Z ; std::begin<char const ,29>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen

; 823  : 
; 824  :         const _Elem _Positive_sign = _Atoms[_Offset_pos_sign];

	mov	eax, 1
	imul	ecx, eax, 23
	mov	dl, BYTE PTR __Atoms$[ebp+ecx]
	mov	BYTE PTR __Positive_sign$[ebp], dl

; 825  :         const _Elem _Negative_sign = _Atoms[_Offset_neg_sign];

	mov	eax, 1
	imul	ecx, eax, 22
	mov	dl, BYTE PTR __Atoms$[ebp+ecx]
	mov	BYTE PTR __Negative_sign$[ebp], dl

; 826  :         const _Elem _Zero_wc       = _Atoms[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR __Atoms$[ebp+ecx]
	mov	BYTE PTR __Zero_wc$[ebp], dl

; 827  : 
; 828  :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Loc);

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax

; 829  :         const string _Grouping  = _Punct_fac.grouping();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 830  :         const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN106@Parse_fp_w
	mov	BYTE PTR tv92[ebp], 0
	jmp	SHORT $LN107@Parse_fp_w
$LN106@Parse_fp_w:
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR tv92[ebp], al
$LN107@Parse_fp_w:
	mov	al, BYTE PTR tv92[ebp]
	mov	BYTE PTR __Kseparator$[ebp], al

; 831  : 
; 832  :         bool _Bad_grouping = false;

	mov	BYTE PTR __Bad_grouping$[ebp], 0

; 833  : 
; 834  :         // skip leading separators before the sign
; 835  :         if (!_Grouping.empty()) {

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Parse_fp_w
$LN2@Parse_fp_w:

; 836  :             while (_First != _Last && *_First == _Kseparator) {

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	movsx	eax, BYTE PTR __Kseparator$[ebp]
	cmp	edx, eax
	jne	SHORT $LN3@Parse_fp_w

; 837  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 838  :                 _Bad_grouping = true;

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 839  :             }

	jmp	SHORT $LN2@Parse_fp_w
$LN3@Parse_fp_w:

; 840  :         }
; 841  : 
; 842  :         if (_First != _Last) {

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN38@Parse_fp_w

; 843  :             if (*_First == _Positive_sign) { // gather plus sign

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	movsx	edx, BYTE PTR __Positive_sign$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN36@Parse_fp_w

; 844  :                 *_Ptr++ = '+';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 845  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
	jmp	SHORT $LN38@Parse_fp_w
$LN36@Parse_fp_w:

; 846  :             } else if (*_First == _Negative_sign) { // gather minus sign

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	movsx	eax, BYTE PTR __Negative_sign$[ebp]
	cmp	edx, eax
	jne	SHORT $LN38@Parse_fp_w

; 847  :                 *_Ptr++ = '-';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 848  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN38@Parse_fp_w:

; 849  :             }
; 850  :         }
; 851  : 
; 852  :         *_Ptr++ = '0'; // backstop carries from sticky bit

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 853  : 
; 854  :         bool _Parse_hex                = false;

	mov	BYTE PTR __Parse_hex$[ebp], 0

; 855  :         bool _Seendigit                = false; // seen a digit in input

	mov	BYTE PTR __Seendigit$[ebp], 0

; 856  :         char _Initial_dec_leading_zero = '\0';

	mov	BYTE PTR __Initial_dec_leading_zero$[ebp], 0

; 857  :         if (_First != _Last && *_First == _Zero_wc) {

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$LN42@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	movsx	eax, BYTE PTR __Zero_wc$[ebp]
	cmp	edx, eax
	jne	$LN42@Parse_fp_w

; 858  :             ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1

; 859  :             if (_First == _Last) { // "0" only

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN40@Parse_fp_w

; 860  :                 *_Ptr = '\0';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 0

; 861  :                 return {10, _Bad_grouping};

	mov	BYTE PTR $T8[ebp], 10			; 0000000aH
	mov	dl, BYTE PTR __Bad_grouping$[ebp]
	mov	BYTE PTR $T8[ebp+1], dl
	mov	ax, WORD PTR $T8[ebp]
	mov	WORD PTR $T9[ebp], ax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ax, WORD PTR $T9[ebp]
	jmp	$LN1@Parse_fp_w
$LN40@Parse_fp_w:

; 862  :             }
; 863  : 
; 864  :             if (*_First == _Atoms[_Offset_lower_x] || *_First == _Atoms[_Offset_upper_x]) { // 0x or 0X

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 25
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	je	SHORT $LN43@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	mov	ecx, 1
	imul	edx, ecx, 24
	movsx	ecx, BYTE PTR __Atoms$[ebp+edx]
	cmp	eax, ecx
	jne	SHORT $LN41@Parse_fp_w
$LN43@Parse_fp_w:

; 865  :                 _Parse_hex = true;

	mov	BYTE PTR __Parse_hex$[ebp], 1

; 866  :                 ++_First; // discard 0x or 0X for further parsing

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 867  :                 *_Ptr++ = 'x';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 120			; 00000078H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 868  :             } else {

	jmp	SHORT $LN42@Parse_fp_w
$LN41@Parse_fp_w:

; 869  :                 _Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 870  :                 ++_Initial_dec_leading_zero;

	mov	cl, BYTE PTR __Initial_dec_leading_zero$[ebp]
	add	cl, 1
	mov	BYTE PTR __Initial_dec_leading_zero$[ebp], cl
$LN42@Parse_fp_w:

; 871  :             }
; 872  :         }
; 873  : 
; 874  :         bool _Has_unaccumulated_digits = false;

	mov	BYTE PTR __Has_unaccumulated_digits$[ebp], 0

; 875  :         int _Significant               = 0; // number of significant digits

	mov	DWORD PTR __Significant$[ebp], 0

; 876  :         ptrdiff_t _Power_of_rep_base   = 0; // power of 10 or 16

	mov	DWORD PTR __Power_of_rep_base$[ebp], 0

; 877  : 
; 878  :         const size_t _Offset_digit_end = _Parse_hex ? _Offset_hex_digit_end : _Offset_dec_digit_end;

	movzx	edx, BYTE PTR __Parse_hex$[ebp]
	test	edx, edx
	je	SHORT $LN108@Parse_fp_w
	mov	DWORD PTR tv227[ebp], 22		; 00000016H
	jmp	SHORT $LN109@Parse_fp_w
$LN108@Parse_fp_w:
	mov	DWORD PTR tv227[ebp], 10		; 0000000aH
$LN109@Parse_fp_w:
	mov	eax, DWORD PTR tv227[ebp]
	mov	DWORD PTR __Offset_digit_end$[ebp], eax

; 879  :         if (_Grouping.empty()) {

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	ecx, al
	test	ecx, ecx
	je	$LN44@Parse_fp_w

; 880  :             for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;

	jmp	SHORT $LN6@Parse_fp_w
$LN4@Parse_fp_w:

; 881  :                 _Seendigit = true, (void) ++_First) {

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN6@Parse_fp_w:

; 880  :             for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	edx, al
	push	edx
	lea	eax, DWORD PTR __Atoms$[ebp]
	push	eax
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$24[ebp], eax
	mov	ecx, DWORD PTR __Idx$24[ebp]
	cmp	ecx, DWORD PTR __Offset_digit_end$[ebp]
	jae	SHORT $LN5@Parse_fp_w

; 882  :                 if (_Significant >= _Max_sig_dig) {

	mov	edx, DWORD PTR __Significant$[ebp]
	cmp	edx, DWORD PTR __Max_sig_dig$[ebp]
	jl	SHORT $LN46@Parse_fp_w

; 883  :                     ++_Power_of_rep_base; // just scale by 10 or 16

	mov	eax, DWORD PTR __Power_of_rep_base$[ebp]
	add	eax, 1
	mov	DWORD PTR __Power_of_rep_base$[ebp], eax

; 884  :                     if (_Idx > 0) {

	cmp	DWORD PTR __Idx$24[ebp], 0
	jbe	SHORT $LN48@Parse_fp_w

; 885  :                         _Has_unaccumulated_digits = true;

	mov	BYTE PTR __Has_unaccumulated_digits$[ebp], 1
$LN48@Parse_fp_w:

; 886  :                     }

	jmp	SHORT $LN49@Parse_fp_w
$LN46@Parse_fp_w:

; 887  :                 } else if (_Idx != 0 || _Significant != 0) { // save a significant digit

	cmp	DWORD PTR __Idx$24[ebp], 0
	jne	SHORT $LN50@Parse_fp_w
	cmp	DWORD PTR __Significant$[ebp], 0
	je	SHORT $LN49@Parse_fp_w
$LN50@Parse_fp_w:

; 888  :                     *_Ptr++ = _Src[_Idx];

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR __Idx$24[ebp]
	mov	al, BYTE PTR ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB[edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 889  :                     ++_Significant;

	mov	edx, DWORD PTR __Significant$[ebp]
	add	edx, 1
	mov	DWORD PTR __Significant$[ebp], edx
$LN49@Parse_fp_w:

; 890  :                 }
; 891  :             }

	jmp	$LN4@Parse_fp_w
$LN5@Parse_fp_w:

; 892  :         } else {

	jmp	$LN45@Parse_fp_w
$LN44@Parse_fp_w:

; 893  :             // skip leading separators before digits
; 894  :             while (_First != _Last && *_First == _Kseparator) {

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	movsx	ecx, BYTE PTR __Kseparator$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN8@Parse_fp_w

; 895  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 896  :                 _Bad_grouping = true;

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 897  :             }

	jmp	SHORT $LN44@Parse_fp_w
$LN8@Parse_fp_w:

; 898  : 
; 899  :             string _Groups(1, _Initial_dec_leading_zero); // Groups are detected in the reversed order of _Groups.

	movzx	edx, BYTE PTR __Initial_dec_leading_zero$[ebp]
	push	edx
	push	1
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 900  :             size_t _Groups_arr_idx = 0;

	mov	DWORD PTR __Groups_arr_idx$22[ebp], 0

; 901  : 
; 902  :             for (; _First != _Last; ++_First) {

	jmp	SHORT $LN11@Parse_fp_w
$LN9@Parse_fp_w:
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN11@Parse_fp_w:
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN10@Parse_fp_w

; 903  :                 const size_t _Idx = _STD _Find_elem(_Atoms, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$21[ebp], eax

; 904  :                 if (_Idx < _Offset_digit_end) { // got a digit, add to group size

	mov	edx, DWORD PTR __Idx$21[ebp]
	cmp	edx, DWORD PTR __Offset_digit_end$[ebp]
	jae	$LN51@Parse_fp_w

; 905  :                     _Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 906  :                     if (_Significant >= _Max_sig_dig) {

	mov	eax, DWORD PTR __Significant$[ebp]
	cmp	eax, DWORD PTR __Max_sig_dig$[ebp]
	jl	SHORT $LN53@Parse_fp_w

; 907  :                         ++_Power_of_rep_base; // just scale by 10 or 16

	mov	ecx, DWORD PTR __Power_of_rep_base$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Power_of_rep_base$[ebp], ecx

; 908  :                         if (_Idx > 0) {

	cmp	DWORD PTR __Idx$21[ebp], 0
	jbe	SHORT $LN55@Parse_fp_w

; 909  :                             _Has_unaccumulated_digits = true;

	mov	BYTE PTR __Has_unaccumulated_digits$[ebp], 1
$LN55@Parse_fp_w:

; 910  :                         }

	jmp	SHORT $LN56@Parse_fp_w
$LN53@Parse_fp_w:

; 911  :                     } else if (_Idx != 0 || _Significant != 0) { // save a significant digit

	cmp	DWORD PTR __Idx$21[ebp], 0
	jne	SHORT $LN57@Parse_fp_w
	cmp	DWORD PTR __Significant$[ebp], 0
	je	SHORT $LN56@Parse_fp_w
$LN57@Parse_fp_w:

; 912  :                         *_Ptr++ = _Src[_Idx];

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Idx$21[ebp]
	mov	cl, BYTE PTR ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB[eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 913  :                         ++_Significant;

	mov	eax, DWORD PTR __Significant$[ebp]
	add	eax, 1
	mov	DWORD PTR __Significant$[ebp], eax
$LN56@Parse_fp_w:

; 914  :                     }
; 915  : 
; 916  :                     if (_Groups[_Groups_arr_idx] != CHAR_MAX) {

	mov	ecx, DWORD PTR __Groups_arr_idx$22[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 127				; 0000007fH
	je	SHORT $LN58@Parse_fp_w

; 917  :                         ++_Groups[_Groups_arr_idx];

	mov	eax, DWORD PTR __Groups_arr_idx$22[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR tv298[ebp], eax
	mov	ecx, DWORD PTR tv298[ebp]
	mov	dl, BYTE PTR [ecx]
	add	dl, 1
	mov	eax, DWORD PTR tv298[ebp]
	mov	BYTE PTR [eax], dl
$LN58@Parse_fp_w:

; 918  :                     }

	jmp	SHORT $LN62@Parse_fp_w
$LN51@Parse_fp_w:

; 919  :                 } else if (*_First != _Kseparator) {

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	movsx	edx, BYTE PTR __Kseparator$[ebp]
	cmp	ecx, edx
	je	SHORT $LN59@Parse_fp_w

; 920  :                     break; // not a group separator, done

	jmp	SHORT $LN10@Parse_fp_w
	jmp	SHORT $LN62@Parse_fp_w
$LN59@Parse_fp_w:

; 921  :                 } else if (_Groups[_Groups_arr_idx] == '\0') {

	mov	eax, DWORD PTR __Groups_arr_idx$22[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN61@Parse_fp_w

; 922  :                     _Bad_grouping = true; // adjacent separators, fail

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 923  :                 } else { // add a new group to _Groups string

	jmp	SHORT $LN62@Parse_fp_w
$LN61@Parse_fp_w:

; 924  :                     _Groups.push_back('\0');

	push	0
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 925  :                     ++_Groups_arr_idx;

	mov	edx, DWORD PTR __Groups_arr_idx$22[ebp]
	add	edx, 1
	mov	DWORD PTR __Groups_arr_idx$22[ebp], edx
$LN62@Parse_fp_w:

; 926  :                 }
; 927  :             }

	jmp	$LN9@Parse_fp_w
$LN10@Parse_fp_w:

; 928  : 
; 929  :             if (_Groups_arr_idx != 0) {

	cmp	DWORD PTR __Groups_arr_idx$22[ebp], 0
	je	SHORT $LN65@Parse_fp_w

; 930  :                 if (_Groups[_Groups_arr_idx] > '\0') {

	mov	eax, DWORD PTR __Groups_arr_idx$22[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN64@Parse_fp_w

; 931  :                     ++_Groups_arr_idx; // add trailing group to group count

	mov	edx, DWORD PTR __Groups_arr_idx$22[ebp]
	add	edx, 1
	mov	DWORD PTR __Groups_arr_idx$22[ebp], edx

; 932  :                 } else {

	jmp	SHORT $LN65@Parse_fp_w
$LN64@Parse_fp_w:

; 933  :                     _Bad_grouping = true; // trailing separator, fail

	mov	BYTE PTR __Bad_grouping$[ebp], 1
$LN65@Parse_fp_w:

; 934  :                 }
; 935  :             }
; 936  : 
; 937  :             // skip trailing separators
; 938  :             while (_First != _Last && *_First == _Kseparator) {

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	movsx	ecx, BYTE PTR __Kseparator$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN13@Parse_fp_w

; 939  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 940  :                 _Bad_grouping = true;

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 941  :             }

	jmp	SHORT $LN65@Parse_fp_w
$LN13@Parse_fp_w:

; 942  : 
; 943  :             const char* _Grouping_iter      = _Grouping.data();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	mov	DWORD PTR __Grouping_iter$20[ebp], eax

; 944  :             const char* const _Grouping_end = _Grouping_iter + _Grouping.size();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	eax, DWORD PTR __Grouping_iter$20[ebp]
	mov	DWORD PTR __Grouping_end$19[ebp], eax

; 945  :             char _Current_grouping_count    = '\0';

	mov	BYTE PTR __Current_grouping_count$18[ebp], 0
$LN14@Parse_fp_w:

; 946  :             while (!_Bad_grouping && _Groups_arr_idx > 0) {

	movzx	edx, BYTE PTR __Bad_grouping$[ebp]
	test	edx, edx
	jne	$LN15@Parse_fp_w
	cmp	DWORD PTR __Groups_arr_idx$22[ebp], 0
	jbe	$LN15@Parse_fp_w

; 947  :                 if (_Grouping_iter != _Grouping_end) { // keep the last value when _Grouping is exhausted

	mov	eax, DWORD PTR __Grouping_iter$20[ebp]
	cmp	eax, DWORD PTR __Grouping_end$19[ebp]
	je	SHORT $LN66@Parse_fp_w

; 948  :                     _Current_grouping_count = *_Grouping_iter; // assign the variable at least once

	mov	ecx, DWORD PTR __Grouping_iter$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Current_grouping_count$18[ebp], dl

; 949  :                     ++_Grouping_iter;

	mov	eax, DWORD PTR __Grouping_iter$20[ebp]
	add	eax, 1
	mov	DWORD PTR __Grouping_iter$20[ebp], eax
$LN66@Parse_fp_w:

; 950  :                 }
; 951  : 
; 952  :                 --_Groups_arr_idx;

	mov	ecx, DWORD PTR __Groups_arr_idx$22[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Groups_arr_idx$22[ebp], ecx

; 953  :                 if ((_Current_grouping_count > '\0' && _Current_grouping_count != CHAR_MAX)
; 954  :                     && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

	movsx	edx, BYTE PTR __Current_grouping_count$18[ebp]
	test	edx, edx
	jle	SHORT $LN67@Parse_fp_w
	movsx	eax, BYTE PTR __Current_grouping_count$18[ebp]
	cmp	eax, 127				; 0000007fH
	je	SHORT $LN67@Parse_fp_w
	cmp	DWORD PTR __Groups_arr_idx$22[ebp], 0
	jbe	SHORT $LN69@Parse_fp_w
	mov	ecx, DWORD PTR __Groups_arr_idx$22[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	movsx	eax, BYTE PTR __Current_grouping_count$18[ebp]
	cmp	edx, eax
	jne	SHORT $LN68@Parse_fp_w
$LN69@Parse_fp_w:
	cmp	DWORD PTR __Groups_arr_idx$22[ebp], 0
	jne	SHORT $LN67@Parse_fp_w
	mov	ecx, DWORD PTR __Groups_arr_idx$22[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	movsx	eax, BYTE PTR __Current_grouping_count$18[ebp]
	cmp	edx, eax
	jle	SHORT $LN67@Parse_fp_w
$LN68@Parse_fp_w:

; 955  :                         || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
; 956  :                     _Bad_grouping = true; // bad group size, fail

	mov	BYTE PTR __Bad_grouping$[ebp], 1
$LN67@Parse_fp_w:

; 957  :                 }
; 958  :                 // group size okay, advance to next test
; 959  :             }

	jmp	$LN14@Parse_fp_w
$LN15@Parse_fp_w:

; 960  :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Groups$23[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN45@Parse_fp_w:

; 961  : 
; 962  :         if (_Parse_hex && _Seendigit && _Significant == 0) {

	movzx	ecx, BYTE PTR __Parse_hex$[ebp]
	test	ecx, ecx
	je	SHORT $LN70@Parse_fp_w
	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	je	SHORT $LN70@Parse_fp_w
	cmp	DWORD PTR __Significant$[ebp], 0
	jne	SHORT $LN70@Parse_fp_w

; 963  :             // the condition is true when all of the digits after the 'x' and before the decimal point are zero
; 964  :             *_Ptr++ = '0'; // save at least one leading digit for hex

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN70@Parse_fp_w:

; 965  :         }
; 966  : 
; 967  :         const char _Decimal_point = (_CSTD localeconv())->decimal_point[0];

	call	_localeconv
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR [eax]
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Decimal_point$[ebp], al

; 968  :         if (_First != _Last && *_First == _Punct_fac.decimal_point()) { // add .

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	esi, al
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?decimal_point@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::decimal_point
	movsx	ecx, al
	cmp	esi, ecx
	jne	SHORT $LN71@Parse_fp_w

; 969  :             *_Ptr++ = _Decimal_point;

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR __Decimal_point$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 970  :             ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN71@Parse_fp_w:

; 971  :         }
; 972  : 
; 973  :         if (_Significant == 0) { // 0000. so far

	cmp	DWORD PTR __Significant$[ebp], 0
	jne	SHORT $LN17@Parse_fp_w

; 974  :             for (; _First != _Last && *_First == _Zero_wc; _Seendigit = true, (void) ++_First) {

	jmp	SHORT $LN18@Parse_fp_w
$LN16@Parse_fp_w:
	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN18@Parse_fp_w:
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	movsx	eax, BYTE PTR __Zero_wc$[ebp]
	cmp	edx, eax
	jne	SHORT $LN17@Parse_fp_w

; 975  :                 --_Power_of_rep_base; // count leading fraction zeros without storing digits into buffer

	mov	ecx, DWORD PTR __Power_of_rep_base$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Power_of_rep_base$[ebp], ecx

; 976  :             }

	jmp	SHORT $LN16@Parse_fp_w
$LN17@Parse_fp_w:

; 977  :         }
; 978  : 
; 979  :         for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;

	jmp	SHORT $LN21@Parse_fp_w
$LN19@Parse_fp_w:

; 980  :             _Seendigit = true, (void) ++_First) {

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN21@Parse_fp_w:

; 977  :         }
; 978  : 
; 979  :         for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	edx, al
	push	edx
	lea	eax, DWORD PTR __Atoms$[ebp]
	push	eax
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$17[ebp], eax
	mov	ecx, DWORD PTR __Idx$17[ebp]
	cmp	ecx, DWORD PTR __Offset_digit_end$[ebp]
	jae	SHORT $LN20@Parse_fp_w

; 981  :             if (_Significant < _Max_sig_dig) { // save a significant fraction digit

	mov	edx, DWORD PTR __Significant$[ebp]
	cmp	edx, DWORD PTR __Max_sig_dig$[ebp]
	jge	SHORT $LN73@Parse_fp_w

; 982  :                 *_Ptr++ = _Src[_Idx];

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Idx$17[ebp]
	mov	dl, BYTE PTR ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB[ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 983  :                 ++_Significant;

	mov	ecx, DWORD PTR __Significant$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Significant$[ebp], ecx
	jmp	SHORT $LN75@Parse_fp_w
$LN73@Parse_fp_w:

; 984  :             } else if (_Idx > 0) {

	cmp	DWORD PTR __Idx$17[ebp], 0
	jbe	SHORT $LN75@Parse_fp_w

; 985  :                 _Has_unaccumulated_digits = true; // just update _Has_unaccumulated_digits

	mov	BYTE PTR __Has_unaccumulated_digits$[ebp], 1
$LN75@Parse_fp_w:

; 986  :             }
; 987  :         }

	jmp	$LN19@Parse_fp_w
$LN20@Parse_fp_w:

; 988  : 
; 989  :         if (_Has_unaccumulated_digits) { // increment last digit in memory of those lost

	movzx	edx, BYTE PTR __Has_unaccumulated_digits$[ebp]
	test	edx, edx
	je	$LN77@Parse_fp_w

; 990  :             char& _Last_got_digit = _Ptr[-1] == _Decimal_point ? _Ptr[-2] : _Ptr[-1];

	mov	eax, 1
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR __Decimal_point$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN110@Parse_fp_w
	mov	edx, 1
	imul	eax, edx, -2
	add	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR tv426[ebp], eax
	jmp	SHORT $LN111@Parse_fp_w
$LN110@Parse_fp_w:
	mov	ecx, 1
	imul	edx, ecx, -1
	add	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR tv426[ebp], edx
$LN111@Parse_fp_w:
	mov	eax, DWORD PTR tv426[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR __Last_got_digit$16[ebp], ecx

; 991  :             if (_Last_got_digit == '0' || _Last_got_digit == (_Parse_hex ? '8' : '5')) {

	mov	edx, DWORD PTR __Last_got_digit$16[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN78@Parse_fp_w
	movzx	ecx, BYTE PTR __Parse_hex$[ebp]
	test	ecx, ecx
	je	SHORT $LN112@Parse_fp_w
	mov	BYTE PTR tv432[ebp], 56			; 00000038H
	jmp	SHORT $LN113@Parse_fp_w
$LN112@Parse_fp_w:
	mov	BYTE PTR tv432[ebp], 53			; 00000035H
$LN113@Parse_fp_w:
	mov	edx, DWORD PTR __Last_got_digit$16[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR tv432[ebp]
	cmp	eax, ecx
	jne	SHORT $LN77@Parse_fp_w
$LN78@Parse_fp_w:

; 992  :                 ++_Last_got_digit;

	mov	edx, DWORD PTR __Last_got_digit$16[ebp]
	mov	al, BYTE PTR [edx]
	add	al, 1
	mov	ecx, DWORD PTR __Last_got_digit$16[ebp]
	mov	BYTE PTR [ecx], al
$LN77@Parse_fp_w:

; 993  :             }
; 994  :         }
; 995  : 
; 996  :         const _Elem _Lower_exp_wc = _Atoms[_Parse_hex ? _Offset_lower_p : _Offset_lower_e]; // 'e' for dec, 'p' for hex

	movzx	edx, BYTE PTR __Parse_hex$[ebp]
	test	edx, edx
	je	SHORT $LN114@Parse_fp_w
	mov	DWORD PTR tv438[ebp], 27		; 0000001bH
	jmp	SHORT $LN115@Parse_fp_w
$LN114@Parse_fp_w:
	mov	DWORD PTR tv438[ebp], 20		; 00000014H
$LN115@Parse_fp_w:
	mov	eax, DWORD PTR tv438[ebp]
	mov	cl, BYTE PTR __Atoms$[ebp+eax]
	mov	BYTE PTR __Lower_exp_wc$[ebp], cl

; 997  :         const _Elem _Upper_exp_wc = _Atoms[_Parse_hex ? _Offset_upper_p : _Offset_upper_e]; // 'E' for dec, 'P' for hex

	movzx	edx, BYTE PTR __Parse_hex$[ebp]
	test	edx, edx
	je	SHORT $LN116@Parse_fp_w
	mov	DWORD PTR tv443[ebp], 26		; 0000001aH
	jmp	SHORT $LN117@Parse_fp_w
$LN116@Parse_fp_w:
	mov	DWORD PTR tv443[ebp], 14		; 0000000eH
$LN117@Parse_fp_w:
	mov	eax, DWORD PTR tv443[ebp]
	mov	cl, BYTE PTR __Atoms$[ebp+eax]
	mov	BYTE PTR __Upper_exp_wc$[ebp], cl

; 998  : 
; 999  :         bool _Exponent_part_negative = false;

	mov	BYTE PTR __Exponent_part_negative$[ebp], 0

; 1000 :         ptrdiff_t _Exponent_part     = 0;

	mov	DWORD PTR __Exponent_part$[ebp], 0

; 1001 :         if (_Seendigit && _First != _Last
; 1002 :             && (*_First == _Lower_exp_wc || *_First == _Upper_exp_wc)) { // collect exponent

	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	je	$LN88@Parse_fp_w
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN88@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	movsx	ecx, BYTE PTR __Lower_exp_wc$[ebp]
	cmp	eax, ecx
	je	SHORT $LN80@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	movsx	eax, BYTE PTR __Upper_exp_wc$[ebp]
	cmp	edx, eax
	jne	$LN88@Parse_fp_w
$LN80@Parse_fp_w:

; 1003 :             ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 1004 :             _Seendigit   = false;

	mov	BYTE PTR __Seendigit$[ebp], 0

; 1005 :             _Significant = 0;

	mov	DWORD PTR __Significant$[ebp], 0

; 1006 : 
; 1007 :             if (_First != _Last) {

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN84@Parse_fp_w

; 1008 :                 if (*_First == _Positive_sign) { // gather plus sign

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	movsx	edx, BYTE PTR __Positive_sign$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN82@Parse_fp_w

; 1009 :                     ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
	jmp	SHORT $LN84@Parse_fp_w
$LN82@Parse_fp_w:

; 1010 :                 } else if (*_First == _Negative_sign) { // gather minus sign

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	movsx	ecx, BYTE PTR __Negative_sign$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN84@Parse_fp_w

; 1011 :                     _Exponent_part_negative = true;

	mov	BYTE PTR __Exponent_part_negative$[ebp], 1

; 1012 :                     ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN84@Parse_fp_w:

; 1013 :                 }
; 1014 :             }
; 1015 : 
; 1016 :             for (; _First != _Last && *_First == _Zero_wc; ++_First) { // strip leading zeros

	jmp	SHORT $LN24@Parse_fp_w
$LN22@Parse_fp_w:
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN24@Parse_fp_w:
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	movsx	eax, BYTE PTR __Zero_wc$[ebp]
	cmp	edx, eax
	jne	SHORT $LN23@Parse_fp_w

; 1017 :                 _Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 1018 :             }

	jmp	SHORT $LN22@Parse_fp_w
$LN23@Parse_fp_w:

; 1019 : 
; 1020 :             for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_dec_digit_end;

	jmp	SHORT $LN27@Parse_fp_w
$LN25@Parse_fp_w:

; 1021 :                 _Seendigit = true, (void) ++_First) {

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN27@Parse_fp_w:

; 1019 : 
; 1020 :             for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_dec_digit_end;

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@Parse_fp_w
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	ecx, al
	push	ecx
	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$15[ebp], eax
	cmp	DWORD PTR __Idx$15[ebp], 10		; 0000000aH
	jae	SHORT $LN26@Parse_fp_w

; 1022 :                 if (_Exponent_part < PTRDIFF_MAX / 10
; 1023 :                     || (_Exponent_part == PTRDIFF_MAX / 10

	cmp	DWORD PTR __Exponent_part$[ebp], 214748364 ; 0cccccccH
	jl	SHORT $LN87@Parse_fp_w
	cmp	DWORD PTR __Exponent_part$[ebp], 214748364 ; 0cccccccH
	jne	SHORT $LN85@Parse_fp_w
	cmp	DWORD PTR __Idx$15[ebp], 7
	jg	SHORT $LN85@Parse_fp_w
$LN87@Parse_fp_w:

; 1024 :                         && static_cast<ptrdiff_t>(_Idx) <= PTRDIFF_MAX % 10)) { // save a significant exponent digit
; 1025 :                     _Exponent_part = _Exponent_part * 10 + static_cast<ptrdiff_t>(_Idx);

	imul	eax, DWORD PTR __Exponent_part$[ebp], 10
	add	eax, DWORD PTR __Idx$15[ebp]
	mov	DWORD PTR __Exponent_part$[ebp], eax

; 1026 :                 } else {

	jmp	SHORT $LN86@Parse_fp_w
$LN85@Parse_fp_w:

; 1027 :                     _Exponent_part = PTRDIFF_MAX; // saturated

	mov	DWORD PTR __Exponent_part$[ebp], 2147483647 ; 7fffffffH
$LN86@Parse_fp_w:

; 1028 :                 }
; 1029 :             }

	jmp	$LN25@Parse_fp_w
$LN26@Parse_fp_w:

; 1030 : 
; 1031 :             if (_Exponent_part_negative) {

	movzx	ecx, BYTE PTR __Exponent_part_negative$[ebp]
	test	ecx, ecx
	je	SHORT $LN88@Parse_fp_w

; 1032 :                 _Exponent_part = -_Exponent_part;

	mov	edx, DWORD PTR __Exponent_part$[ebp]
	neg	edx
	mov	DWORD PTR __Exponent_part$[ebp], edx
$LN88@Parse_fp_w:

; 1033 :             }
; 1034 :         }
; 1035 : 
; 1036 :         if (!_Seendigit) {

	movzx	eax, BYTE PTR __Seendigit$[ebp]
	test	eax, eax
	jne	SHORT $LN89@Parse_fp_w

; 1037 :             return {0, false};

	mov	BYTE PTR $T5[ebp], 0
	mov	BYTE PTR $T5[ebp+1], 0
	mov	cx, WORD PTR $T5[ebp]
	mov	WORD PTR $T6[ebp], cx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ax, WORD PTR $T6[ebp]
	jmp	$LN1@Parse_fp_w
$LN89@Parse_fp_w:

; 1038 :         }
; 1039 : 
; 1040 :         constexpr int _Dec_exp_abs_bound = 1100; // slightly greater than 324 + 768

	mov	DWORD PTR __Dec_exp_abs_bound$[ebp], 1100 ; 0000044cH

; 1041 :         constexpr int _Hex_exp_abs_bound = 4200; // slightly greater than 1074 + 768 * 4

	mov	DWORD PTR __Hex_exp_abs_bound$[ebp], 4200 ; 00001068H

; 1042 : 
; 1043 :         const ptrdiff_t _Exp_abs_bound     = _Parse_hex ? _Hex_exp_abs_bound : _Dec_exp_abs_bound;

	movzx	edx, BYTE PTR __Parse_hex$[ebp]
	test	edx, edx
	je	SHORT $LN118@Parse_fp_w
	mov	DWORD PTR tv516[ebp], 4200		; 00001068H
	jmp	SHORT $LN119@Parse_fp_w
$LN118@Parse_fp_w:
	mov	DWORD PTR tv516[ebp], 1100		; 0000044cH
$LN119@Parse_fp_w:
	mov	eax, DWORD PTR tv516[ebp]
	mov	DWORD PTR __Exp_abs_bound$[ebp], eax

; 1044 :         const ptrdiff_t _Exp_rep_abs_bound = _Parse_hex ? _Hex_exp_abs_bound / 4 : _Dec_exp_abs_bound;

	movzx	ecx, BYTE PTR __Parse_hex$[ebp]
	test	ecx, ecx
	je	SHORT $LN120@Parse_fp_w
	mov	DWORD PTR tv519[ebp], 1050		; 0000041aH
	jmp	SHORT $LN121@Parse_fp_w
$LN120@Parse_fp_w:
	mov	DWORD PTR tv519[ebp], 1100		; 0000044cH
$LN121@Parse_fp_w:
	mov	edx, DWORD PTR tv519[ebp]
	mov	DWORD PTR __Exp_rep_abs_bound$[ebp], edx

; 1045 : 
; 1046 :         // basically _Exponent_part = _STD clamp(-_Exp_abs_bound,
; 1047 :         //     _Exponent_part + _Parse_hex ? _Power_of_rep_base * 4 : _Power_of_rep_base, _Exp_abs_bound)
; 1048 :         // but need to defend overflowing
; 1049 :         for (ptrdiff_t _Power_of_rep_adjusted = _Power_of_rep_base;;) {

	mov	eax, DWORD PTR __Power_of_rep_base$[ebp]
	mov	DWORD PTR __Power_of_rep_adjusted$14[ebp], eax
$LN28@Parse_fp_w:

; 1050 :             if (_Exponent_part >= 0 && _Power_of_rep_adjusted >= 0
; 1051 :                 && (_Exponent_part >= _Exp_abs_bound || _Power_of_rep_adjusted >= _Exp_rep_abs_bound)) {

	cmp	DWORD PTR __Exponent_part$[ebp], 0
	jl	SHORT $LN90@Parse_fp_w
	cmp	DWORD PTR __Power_of_rep_adjusted$14[ebp], 0
	jl	SHORT $LN90@Parse_fp_w
	mov	ecx, DWORD PTR __Exponent_part$[ebp]
	cmp	ecx, DWORD PTR __Exp_abs_bound$[ebp]
	jge	SHORT $LN92@Parse_fp_w
	mov	edx, DWORD PTR __Power_of_rep_adjusted$14[ebp]
	cmp	edx, DWORD PTR __Exp_rep_abs_bound$[ebp]
	jl	SHORT $LN90@Parse_fp_w
$LN92@Parse_fp_w:

; 1052 :                 _Exponent_part = _Exp_abs_bound;

	mov	eax, DWORD PTR __Exp_abs_bound$[ebp]
	mov	DWORD PTR __Exponent_part$[ebp], eax

; 1053 :                 break;

	jmp	$LN29@Parse_fp_w

; 1054 :             } else if (_Exponent_part <= 0 && _Power_of_rep_adjusted <= 0

	jmp	$LN102@Parse_fp_w
$LN90@Parse_fp_w:

; 1055 :                        && (_Exponent_part <= -_Exp_abs_bound || _Power_of_rep_adjusted <= -_Exp_rep_abs_bound)) {

	cmp	DWORD PTR __Exponent_part$[ebp], 0
	jg	SHORT $LN93@Parse_fp_w
	cmp	DWORD PTR __Power_of_rep_adjusted$14[ebp], 0
	jg	SHORT $LN93@Parse_fp_w
	mov	ecx, DWORD PTR __Exp_abs_bound$[ebp]
	neg	ecx
	cmp	DWORD PTR __Exponent_part$[ebp], ecx
	jle	SHORT $LN95@Parse_fp_w
	mov	edx, DWORD PTR __Exp_rep_abs_bound$[ebp]
	neg	edx
	cmp	DWORD PTR __Power_of_rep_adjusted$14[ebp], edx
	jg	SHORT $LN93@Parse_fp_w
$LN95@Parse_fp_w:

; 1056 :                 _Exponent_part = -_Exp_abs_bound;

	mov	eax, DWORD PTR __Exp_abs_bound$[ebp]
	neg	eax
	mov	DWORD PTR __Exponent_part$[ebp], eax

; 1057 :                 break;

	jmp	$LN29@Parse_fp_w

; 1058 :             } else if (_STD abs(_Exponent_part) <= _Exp_abs_bound

	jmp	$LN102@Parse_fp_w
$LN93@Parse_fp_w:

; 1059 :                        && _STD abs(_Power_of_rep_adjusted) <= _Exp_rep_abs_bound) {

	mov	ecx, DWORD PTR __Exponent_part$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	cmp	eax, DWORD PTR __Exp_abs_bound$[ebp]
	jg	$LN96@Parse_fp_w
	mov	edx, DWORD PTR __Power_of_rep_adjusted$14[ebp]
	push	edx
	call	_abs
	add	esp, 4
	cmp	eax, DWORD PTR __Exp_rep_abs_bound$[ebp]
	jg	SHORT $LN96@Parse_fp_w

; 1060 :                 // _Exponent_part and _Power_of_rep_base are of different signedness, both of which are small enough
; 1061 :                 _Exponent_part += _Parse_hex ? _Power_of_rep_adjusted * 4 : _Power_of_rep_adjusted;

	movzx	eax, BYTE PTR __Parse_hex$[ebp]
	test	eax, eax
	je	SHORT $LN122@Parse_fp_w
	mov	ecx, DWORD PTR __Power_of_rep_adjusted$14[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv540[ebp], ecx
	jmp	SHORT $LN123@Parse_fp_w
$LN122@Parse_fp_w:
	mov	edx, DWORD PTR __Power_of_rep_adjusted$14[ebp]
	mov	DWORD PTR tv540[ebp], edx
$LN123@Parse_fp_w:
	mov	eax, DWORD PTR __Exponent_part$[ebp]
	add	eax, DWORD PTR tv540[ebp]
	mov	DWORD PTR __Exponent_part$[ebp], eax

; 1062 :                 if (_Exponent_part > _Exp_abs_bound) {

	mov	ecx, DWORD PTR __Exponent_part$[ebp]
	cmp	ecx, DWORD PTR __Exp_abs_bound$[ebp]
	jle	SHORT $LN98@Parse_fp_w

; 1063 :                     _Exponent_part = _Exp_abs_bound;

	mov	edx, DWORD PTR __Exp_abs_bound$[ebp]
	mov	DWORD PTR __Exponent_part$[ebp], edx
	jmp	SHORT $LN100@Parse_fp_w
$LN98@Parse_fp_w:

; 1064 :                 } else if (_Exponent_part < -_Exp_abs_bound) {

	mov	eax, DWORD PTR __Exp_abs_bound$[ebp]
	neg	eax
	cmp	DWORD PTR __Exponent_part$[ebp], eax
	jge	SHORT $LN100@Parse_fp_w

; 1065 :                     _Exponent_part = -_Exp_abs_bound;

	mov	ecx, DWORD PTR __Exp_abs_bound$[ebp]
	neg	ecx
	mov	DWORD PTR __Exponent_part$[ebp], ecx
$LN100@Parse_fp_w:

; 1066 :                 }
; 1067 :                 break;

	jmp	$LN29@Parse_fp_w

; 1068 :             } else {

	jmp	$LN102@Parse_fp_w
$LN96@Parse_fp_w:

; 1069 :                 // only enters once:
; 1070 :                 // _Exponent_part and _Power_of_rep_base are of different signedness, but at least one is large
; 1071 :                 const ptrdiff_t _Exponent_part_preadjustment_round_up =

	movzx	edx, BYTE PTR __Parse_hex$[ebp]
	test	edx, edx
	je	SHORT $LN124@Parse_fp_w
	mov	eax, DWORD PTR __Exponent_part$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	sub	eax, 1
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, 1
	mov	DWORD PTR tv587[ebp], eax
	jmp	SHORT $LN125@Parse_fp_w
$LN124@Parse_fp_w:
	mov	ecx, DWORD PTR __Exponent_part$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	mov	DWORD PTR tv587[ebp], eax
$LN125@Parse_fp_w:
	mov	edx, DWORD PTR tv587[ebp]
	mov	DWORD PTR __Exponent_part_preadjustment_round_up$13[ebp], edx

; 1072 :                     _Parse_hex ? (_STD abs(_Exponent_part) - 1) / 4 + 1 : _STD abs(_Exponent_part);
; 1073 :                 const ptrdiff_t _Exp_rep_adjustment =

	mov	eax, DWORD PTR __Power_of_rep_base$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Exponent_part_preadjustment_round_up$13[ebp]
	push	edx
	call	??$min@H@std@@YAABHABH0@Z		; std::min<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Exp_rep_adjustment$12[ebp], eax

; 1074 :                     (_STD min)(_Exponent_part_preadjustment_round_up, _STD abs(_Power_of_rep_base));
; 1075 : 
; 1076 :                 if (_Exponent_part >= 0) {

	cmp	DWORD PTR __Exponent_part$[ebp], 0
	jl	SHORT $LN101@Parse_fp_w

; 1077 :                     _Exponent_part -= _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;

	movzx	ecx, BYTE PTR __Parse_hex$[ebp]
	test	ecx, ecx
	je	SHORT $LN126@Parse_fp_w
	mov	edx, DWORD PTR __Exp_rep_adjustment$12[ebp]
	shl	edx, 2
	mov	DWORD PTR tv597[ebp], edx
	jmp	SHORT $LN127@Parse_fp_w
$LN126@Parse_fp_w:
	mov	eax, DWORD PTR __Exp_rep_adjustment$12[ebp]
	mov	DWORD PTR tv597[ebp], eax
$LN127@Parse_fp_w:
	mov	ecx, DWORD PTR __Exponent_part$[ebp]
	sub	ecx, DWORD PTR tv597[ebp]
	mov	DWORD PTR __Exponent_part$[ebp], ecx

; 1078 :                     _Power_of_rep_adjusted += _Exp_rep_adjustment;

	mov	edx, DWORD PTR __Power_of_rep_adjusted$14[ebp]
	add	edx, DWORD PTR __Exp_rep_adjustment$12[ebp]
	mov	DWORD PTR __Power_of_rep_adjusted$14[ebp], edx

; 1079 :                 } else {

	jmp	SHORT $LN102@Parse_fp_w
$LN101@Parse_fp_w:

; 1080 :                     _Exponent_part += _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;

	movzx	eax, BYTE PTR __Parse_hex$[ebp]
	test	eax, eax
	je	SHORT $LN128@Parse_fp_w
	mov	ecx, DWORD PTR __Exp_rep_adjustment$12[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv603[ebp], ecx
	jmp	SHORT $LN129@Parse_fp_w
$LN128@Parse_fp_w:
	mov	edx, DWORD PTR __Exp_rep_adjustment$12[ebp]
	mov	DWORD PTR tv603[ebp], edx
$LN129@Parse_fp_w:
	mov	eax, DWORD PTR __Exponent_part$[ebp]
	add	eax, DWORD PTR tv603[ebp]
	mov	DWORD PTR __Exponent_part$[ebp], eax

; 1081 :                     _Power_of_rep_adjusted -= _Exp_rep_adjustment;

	mov	ecx, DWORD PTR __Power_of_rep_adjusted$14[ebp]
	sub	ecx, DWORD PTR __Exp_rep_adjustment$12[ebp]
	mov	DWORD PTR __Power_of_rep_adjusted$14[ebp], ecx
$LN102@Parse_fp_w:

; 1082 :                 }
; 1083 :             }
; 1084 :         }

	jmp	$LN28@Parse_fp_w
$LN29@Parse_fp_w:

; 1085 : 
; 1086 :         if (_Exponent_part != 0) {

	cmp	DWORD PTR __Exponent_part$[ebp], 0
	je	$LN103@Parse_fp_w

; 1087 :             *_Ptr++ = _Parse_hex ? 'p' : 'e';

	movzx	edx, BYTE PTR __Parse_hex$[ebp]
	test	edx, edx
	je	SHORT $LN130@Parse_fp_w
	mov	BYTE PTR tv610[ebp], 112		; 00000070H
	jmp	SHORT $LN131@Parse_fp_w
$LN130@Parse_fp_w:
	mov	BYTE PTR tv610[ebp], 101		; 00000065H
$LN131@Parse_fp_w:
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	cl, BYTE PTR tv610[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1088 :             if (_Exponent_part < 0) {

	cmp	DWORD PTR __Exponent_part$[ebp], 0
	jge	SHORT $LN104@Parse_fp_w

; 1089 :                 *_Ptr++ = '-';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 45			; 0000002dH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN104@Parse_fp_w:

; 1090 :             }
; 1091 : 
; 1092 :             char* const _Rev_begin = _Ptr;

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Rev_begin$11[ebp], edx

; 1093 :             for (ptrdiff_t _Exponent_part_abs = _STD abs(_Exponent_part); _Exponent_part_abs != 0;

	mov	eax, DWORD PTR __Exponent_part$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR __Exponent_part_abs$10[ebp], eax
	jmp	SHORT $LN33@Parse_fp_w
$LN31@Parse_fp_w:

; 1094 :                 _Exponent_part_abs /= 10) {

	mov	eax, DWORD PTR __Exponent_part_abs$10[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR __Exponent_part_abs$10[ebp], eax
$LN33@Parse_fp_w:

; 1093 :             for (ptrdiff_t _Exponent_part_abs = _STD abs(_Exponent_part); _Exponent_part_abs != 0;

	cmp	DWORD PTR __Exponent_part_abs$10[ebp], 0
	je	SHORT $LN32@Parse_fp_w

; 1095 :                 *_Ptr++ = static_cast<char>('0' + _Exponent_part_abs % 10);

	mov	eax, DWORD PTR __Exponent_part_abs$10[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	edx, 48					; 00000030H
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1096 :             }

	jmp	SHORT $LN31@Parse_fp_w
$LN32@Parse_fp_w:

; 1097 :             _STD reverse(_Rev_begin, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rev_begin$11[ebp]
	push	eax
	call	??$reverse@PAD@std@@YAXQAD0@Z		; std::reverse<char *>
	add	esp, 8
$LN103@Parse_fp_w:

; 1098 :         }
; 1099 : 
; 1100 :         *_Ptr = '\0';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 0

; 1101 :         return {static_cast<int8_t>(_Parse_hex ? 16 : 10), _Bad_grouping};

	movzx	edx, BYTE PTR __Parse_hex$[ebp]
	test	edx, edx
	je	SHORT $LN132@Parse_fp_w
	mov	DWORD PTR tv625[ebp], 16		; 00000010H
	jmp	SHORT $LN133@Parse_fp_w
$LN132@Parse_fp_w:
	mov	DWORD PTR tv625[ebp], 10		; 0000000aH
$LN133@Parse_fp_w:
	mov	al, BYTE PTR tv625[ebp]
	mov	BYTE PTR $T2[ebp], al
	mov	cl, BYTE PTR __Bad_grouping$[ebp]
	mov	BYTE PTR $T2[ebp+1], cl
	mov	dx, WORD PTR $T2[ebp]
	mov	WORD PTR $T3[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ax, WORD PTR $T3[ebp]
$LN1@Parse_fp_w:

; 1102 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN142@Parse_fp_w
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN142@Parse_fp_w:
	DD	4
	DD	$LN141@Parse_fp_w
$LN141@Parse_fp_w:
	DD	-96					; ffffffa0H
	DD	29					; 0000001dH
	DD	$LN136@Parse_fp_w
	DD	-144					; ffffff70H
	DD	28					; 0000001cH
	DD	$LN137@Parse_fp_w
	DD	-204					; ffffff34H
	DD	28					; 0000001cH
	DD	$LN138@Parse_fp_w
	DD	-276					; fffffeecH
	DD	4
	DD	$LN139@Parse_fp_w
$LN139@Parse_fp_w:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	95					; 0000005fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	0
$LN138@Parse_fp_w:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	0
$LN137@Parse_fp_w:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN136@Parse_fp_w:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$0:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$1:
	lea	ecx, DWORD PTR __Groups$23[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-372]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator==<char,std::char_traits<char> >, COMDAT

; 487  :     const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {

	push	ebp
	mov	ebp, esp

; 488  :     return _Left.equal(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 489  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
_TEXT	SEGMENT
tv254 = -204						; size = 4
tv218 = -200						; size = 4
tv217 = -196						; size = 4
tv76 = -190						; size = 1
$T2 = -189						; size = 2
$T3 = -187						; size = 2
$T4 = -185						; size = 2
$T5 = -183						; size = 2
__Current_grouping_count$6 = -181			; size = 1
__Grouping_end$ = -180					; size = 4
__Grouping_iter$ = -176					; size = 4
__Idx$7 = -172						; size = 4
__Pe$8 = -168						; size = 4
__Groups_arr_idx$ = -164				; size = 4
__Groups$ = -156					; size = 28
__Dlen$ = -124						; size = 4
__Nonzero$ = -119					; size = 1
__Seendigit$ = -118					; size = 1
__Base$ = -117						; size = 1
__Ptr$ = -116						; size = 4
__Bad_grouping$ = -109					; size = 1
__Ctype_fac$ = -108					; size = 4
__Atoms$ = -100						; size = 27
__Numget_xoff$ = -68					; size = 4
__Numget_signoff$ = -64					; size = 4
__Kseparator$ = -57					; size = 1
__Grouping$ = -52					; size = 28
__Punct_fac$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ac$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Basefield$ = 20					; size = 4
__Loc$ = 24						; size = 4
??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>, COMDAT

; 659  :         char* const _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield, const locale& _Loc) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 660  :         // get integer field from [_First, _Last) into _Ac
; 661  :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Loc);

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax

; 662  :         const string _Grouping  = _Punct_fac.grouping();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 663  :         const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN53@Parse_int_
	mov	BYTE PTR tv76[ebp], 0
	jmp	SHORT $LN54@Parse_int_
$LN53@Parse_int_:
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR tv76[ebp], al
$LN54@Parse_int_:
	mov	al, BYTE PTR tv76[ebp]
	mov	BYTE PTR __Kseparator$[ebp], al

; 664  : 
; 665  :         constexpr int _Numget_signoff = 22;

	mov	DWORD PTR __Numget_signoff$[ebp], 22	; 00000016H

; 666  :         constexpr int _Numget_xoff    = 24;

	mov	DWORD PTR __Numget_xoff$[ebp], 24	; 00000018H

; 667  :         static constexpr char _Src[]  = "0123456789ABCDEFabcdef-+Xx";
; 668  :         _Elem _Atoms[sizeof(_Src)];
; 669  :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);

	mov	ecx, DWORD PTR __Loc$[ebp]
	push	ecx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax

; 670  :         _Ctype_fac.widen(_STD begin(_Src), _STD end(_Src), _Atoms);

	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	push	OFFSET ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>'::`2'::_Src
	call	??$end@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z ; std::end<char const ,27>
	add	esp, 4
	push	eax
	push	OFFSET ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>'::`2'::_Src
	call	??$begin@$$CBD$0BL@@std@@YAPBDAAY0BL@$$CBD@Z ; std::begin<char const ,27>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen

; 671  : 
; 672  :         bool _Bad_grouping = false;

	mov	BYTE PTR __Bad_grouping$[ebp], 0

; 673  : 
; 674  :         // skip leading separators before the sign
; 675  :         if (_Kseparator != _Elem{}) {

	movsx	eax, BYTE PTR __Kseparator$[ebp]
	test	eax, eax
	je	SHORT $LN3@Parse_int_
$LN2@Parse_int_:

; 676  :             while (_First != _Last && *_First == _Kseparator) {

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Parse_int_
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	movsx	edx, BYTE PTR __Kseparator$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN3@Parse_int_

; 677  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 678  :                 _Bad_grouping = true;

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 679  :             }

	jmp	SHORT $LN2@Parse_int_
$LN3@Parse_int_:

; 680  :         }
; 681  : 
; 682  :         char* _Ptr = _Ac;

	mov	eax, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 683  : 
; 684  :         if (_First != _Last) {

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@Parse_int_

; 685  :             if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 23
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN16@Parse_int_

; 686  :                 *_Ptr++ = '+';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 687  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
	jmp	SHORT $LN18@Parse_int_
$LN16@Parse_int_:

; 688  :             } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 22
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN18@Parse_int_

; 689  :                 *_Ptr++ = '-';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 690  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN18@Parse_int_:

; 691  :             }
; 692  :         }
; 693  : 
; 694  :         // skip leading separators before digits
; 695  :         if (_Kseparator != _Elem{}) {

	movsx	eax, BYTE PTR __Kseparator$[ebp]
	test	eax, eax
	je	SHORT $LN5@Parse_int_
$LN4@Parse_int_:

; 696  :             while (_First != _Last && *_First == _Kseparator) {

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Parse_int_
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	movsx	edx, BYTE PTR __Kseparator$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN5@Parse_int_

; 697  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 698  :                 _Bad_grouping = true;

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 699  :             }

	jmp	SHORT $LN4@Parse_int_
$LN5@Parse_int_:

; 700  :         }
; 701  : 
; 702  :         _Basefield &= ios_base::basefield;

	mov	eax, DWORD PTR __Basefield$[ebp]
	and	eax, 3584				; 00000e00H
	mov	DWORD PTR __Basefield$[ebp], eax

; 703  : 
; 704  :         int8_t _Base;
; 705  :         if (_Basefield == ios_base::oct) {

	cmp	DWORD PTR __Basefield$[ebp], 1024	; 00000400H
	jne	SHORT $LN20@Parse_int_

; 706  :             _Base = 8;

	mov	BYTE PTR __Base$[ebp], 8
	jmp	SHORT $LN25@Parse_int_
$LN20@Parse_int_:

; 707  :         } else if (_Basefield == ios_base::hex) {

	cmp	DWORD PTR __Basefield$[ebp], 2048	; 00000800H
	jne	SHORT $LN22@Parse_int_

; 708  :             _Base = 16;

	mov	BYTE PTR __Base$[ebp], 16		; 00000010H
	jmp	SHORT $LN25@Parse_int_
$LN22@Parse_int_:

; 709  :         } else if (_Basefield == ios_base::_Fmtzero) {

	cmp	DWORD PTR __Basefield$[ebp], 0
	jne	SHORT $LN24@Parse_int_

; 710  :             _Base = 0;

	mov	BYTE PTR __Base$[ebp], 0

; 711  :         } else {

	jmp	SHORT $LN25@Parse_int_
$LN24@Parse_int_:

; 712  :             _Base = 10;

	mov	BYTE PTR __Base$[ebp], 10		; 0000000aH
$LN25@Parse_int_:

; 713  :         }
; 714  : 
; 715  :         bool _Seendigit = false; // seen a digit in input

	mov	BYTE PTR __Seendigit$[ebp], 0

; 716  :         bool _Nonzero   = false; // seen a nonzero digit in input

	mov	BYTE PTR __Nonzero$[ebp], 0

; 717  : 
; 718  :         if (_First != _Last && *_First == _Atoms[0]) { // leading zero, look for 0x, 0X

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN31@Parse_int_
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 0
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	$LN31@Parse_int_

; 719  :             _Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 720  :             ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1

; 721  :             if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
; 722  :                 && (_Base == 0 || _Base == 16)) {

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN27@Parse_int_
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	mov	ecx, 1
	imul	edx, ecx, 25
	movsx	ecx, BYTE PTR __Atoms$[ebp+edx]
	cmp	eax, ecx
	je	SHORT $LN29@Parse_int_
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 24
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN27@Parse_int_
$LN29@Parse_int_:
	movsx	ecx, BYTE PTR __Base$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@Parse_int_
	movsx	edx, BYTE PTR __Base$[ebp]
	cmp	edx, 16					; 00000010H
	jne	SHORT $LN27@Parse_int_
$LN30@Parse_int_:

; 723  :                 _Base      = 16;

	mov	BYTE PTR __Base$[ebp], 16		; 00000010H

; 724  :                 _Seendigit = false;

	mov	BYTE PTR __Seendigit$[ebp], 0

; 725  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
	jmp	SHORT $LN31@Parse_int_
$LN27@Parse_int_:

; 726  :             } else if (_Base == 0) {

	movsx	eax, BYTE PTR __Base$[ebp]
	test	eax, eax
	jne	SHORT $LN31@Parse_int_

; 727  :                 _Base = 8;

	mov	BYTE PTR __Base$[ebp], 8
$LN31@Parse_int_:

; 728  :             }
; 729  :         }
; 730  : 
; 731  :         const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);

	movsx	ecx, BYTE PTR __Base$[ebp]
	test	ecx, ecx
	je	SHORT $LN55@Parse_int_
	movsx	edx, BYTE PTR __Base$[ebp]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN55@Parse_int_
	movsx	eax, BYTE PTR __Base$[ebp]
	cmp	eax, 8
	jne	SHORT $LN56@Parse_int_
	mov	DWORD PTR tv217[ebp], 8
	jmp	SHORT $LN57@Parse_int_
$LN56@Parse_int_:
	mov	DWORD PTR tv217[ebp], 22		; 00000016H
$LN57@Parse_int_:
	mov	ecx, DWORD PTR tv217[ebp]
	mov	DWORD PTR tv218[ebp], ecx
	jmp	SHORT $LN58@Parse_int_
$LN55@Parse_int_:
	mov	DWORD PTR tv218[ebp], 10		; 0000000aH
$LN58@Parse_int_:
	mov	edx, DWORD PTR tv218[ebp]
	mov	DWORD PTR __Dlen$[ebp], edx

; 732  :         string _Groups(1, static_cast<char>(_Seendigit)); // Groups are detected in the reversed order of _Groups.

	movzx	eax, BYTE PTR __Seendigit$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 733  :         size_t _Groups_arr_idx = 0;

	mov	DWORD PTR __Groups_arr_idx$[ebp], 0

; 734  : 
; 735  :         for (char* const _Pe = &_Ac[_Max_int_dig - 1]; _First != _Last; ++_First) { // look for digits and separators

	mov	ecx, 1
	imul	edx, ecx, 31
	add	edx, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Pe$8[ebp], edx
	jmp	SHORT $LN8@Parse_int_
$LN6@Parse_int_:
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN8@Parse_int_:
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN7@Parse_int_

; 736  :             size_t _Idx = _STD _Find_elem(_Atoms, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	call	??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z ; std::_Find_elem<char,27>
	add	esp, 8
	mov	DWORD PTR __Idx$7[ebp], eax

; 737  :             if (_Idx < _Dlen) { // got a digit, characterize it and add to group size

	mov	edx, DWORD PTR __Idx$7[ebp]
	cmp	edx, DWORD PTR __Dlen$[ebp]
	jae	$LN32@Parse_int_

; 738  :                 *_Ptr = _Src[_Idx];

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Idx$7[ebp]
	mov	dl, BYTE PTR ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB[ecx]
	mov	BYTE PTR [eax], dl

; 739  :                 if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {

	movzx	eax, BYTE PTR __Nonzero$[ebp]
	test	eax, eax
	jne	SHORT $LN35@Parse_int_
	mov	ecx, DWORD PTR __Ptr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	je	SHORT $LN34@Parse_int_
$LN35@Parse_int_:
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR __Pe$8[ebp]
	jae	SHORT $LN34@Parse_int_

; 740  :                     ++_Ptr;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 741  :                     _Nonzero = true;

	mov	BYTE PTR __Nonzero$[ebp], 1
$LN34@Parse_int_:

; 742  :                 }
; 743  : 
; 744  :                 _Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 745  :                 if (_Groups[_Groups_arr_idx] != CHAR_MAX) {

	mov	edx, DWORD PTR __Groups_arr_idx$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 127				; 0000007fH
	je	SHORT $LN36@Parse_int_

; 746  :                     ++_Groups[_Groups_arr_idx];

	mov	ecx, DWORD PTR __Groups_arr_idx$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR tv254[ebp], eax
	mov	edx, DWORD PTR tv254[ebp]
	mov	al, BYTE PTR [edx]
	add	al, 1
	mov	ecx, DWORD PTR tv254[ebp]
	mov	BYTE PTR [ecx], al
$LN36@Parse_int_:

; 747  :                 }

	jmp	SHORT $LN41@Parse_int_
$LN32@Parse_int_:

; 748  :             } else if (_Kseparator == _Elem{} || *_First != _Kseparator) {

	movsx	edx, BYTE PTR __Kseparator$[ebp]
	test	edx, edx
	je	SHORT $LN39@Parse_int_
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	movsx	ecx, BYTE PTR __Kseparator$[ebp]
	cmp	eax, ecx
	je	SHORT $LN37@Parse_int_
$LN39@Parse_int_:

; 749  :                 break; // not a group separator, done

	jmp	SHORT $LN7@Parse_int_
	jmp	SHORT $LN41@Parse_int_
$LN37@Parse_int_:

; 750  :             } else if (_Groups[_Groups_arr_idx] == '\0') {

	mov	edx, DWORD PTR __Groups_arr_idx$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN40@Parse_int_

; 751  :                 _Bad_grouping = true; // adjacent separators, fail

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 752  :             } else { // add a new group to _Groups string

	jmp	SHORT $LN41@Parse_int_
$LN40@Parse_int_:

; 753  :                 _Groups.push_back('\0');

	push	0
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 754  :                 ++_Groups_arr_idx;

	mov	ecx, DWORD PTR __Groups_arr_idx$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Groups_arr_idx$[ebp], ecx
$LN41@Parse_int_:

; 755  :             }
; 756  :         }

	jmp	$LN6@Parse_int_
$LN7@Parse_int_:

; 757  : 
; 758  :         if (_Groups_arr_idx != 0) {

	cmp	DWORD PTR __Groups_arr_idx$[ebp], 0
	je	SHORT $LN44@Parse_int_

; 759  :             if (_Groups[_Groups_arr_idx] > '\0') {

	mov	edx, DWORD PTR __Groups_arr_idx$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jle	SHORT $LN43@Parse_int_

; 760  :                 ++_Groups_arr_idx; // add trailing group to group count

	mov	ecx, DWORD PTR __Groups_arr_idx$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Groups_arr_idx$[ebp], ecx

; 761  :             } else {

	jmp	SHORT $LN44@Parse_int_
$LN43@Parse_int_:

; 762  :                 _Bad_grouping = true; // trailing separator, fail

	mov	BYTE PTR __Bad_grouping$[ebp], 1
$LN44@Parse_int_:

; 763  :             }
; 764  :         }
; 765  : 
; 766  :         // skip trailing separators
; 767  :         if (_Kseparator != _Elem{}) {

	movsx	edx, BYTE PTR __Kseparator$[ebp]
	test	edx, edx
	je	SHORT $LN10@Parse_int_
$LN9@Parse_int_:

; 768  :             while (_First != _Last && *_First == _Kseparator) {

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@Parse_int_
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	movsx	ecx, BYTE PTR __Kseparator$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN10@Parse_int_

; 769  :                 ++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 770  :                 _Bad_grouping = true;

	mov	BYTE PTR __Bad_grouping$[ebp], 1

; 771  :             }

	jmp	SHORT $LN9@Parse_int_
$LN10@Parse_int_:

; 772  :         }
; 773  : 
; 774  :         const char* _Grouping_iter      = _Grouping.data();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	mov	DWORD PTR __Grouping_iter$[ebp], eax

; 775  :         const char* const _Grouping_end = _Grouping_iter + _Grouping.size();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	eax, DWORD PTR __Grouping_iter$[ebp]
	mov	DWORD PTR __Grouping_end$[ebp], eax

; 776  :         for (char _Current_grouping_count = '\0'; _Seendigit && !_Bad_grouping && _Groups_arr_idx > 0;) {

	mov	BYTE PTR __Current_grouping_count$6[ebp], 0
$LN11@Parse_int_:
	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	je	$LN12@Parse_int_
	movzx	eax, BYTE PTR __Bad_grouping$[ebp]
	test	eax, eax
	jne	$LN12@Parse_int_
	cmp	DWORD PTR __Groups_arr_idx$[ebp], 0
	jbe	$LN12@Parse_int_

; 777  :             if (_Grouping_iter != _Grouping_end) { // keep the last value when _Grouping is exhausted

	mov	ecx, DWORD PTR __Grouping_iter$[ebp]
	cmp	ecx, DWORD PTR __Grouping_end$[ebp]
	je	SHORT $LN46@Parse_int_

; 778  :                 _Current_grouping_count = *_Grouping_iter; // if _Grouping is empty, '\0' is used

	mov	edx, DWORD PTR __Grouping_iter$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Current_grouping_count$6[ebp], al

; 779  :                 ++_Grouping_iter;

	mov	ecx, DWORD PTR __Grouping_iter$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Grouping_iter$[ebp], ecx
$LN46@Parse_int_:

; 780  :             }
; 781  : 
; 782  :             --_Groups_arr_idx;

	mov	edx, DWORD PTR __Groups_arr_idx$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Groups_arr_idx$[ebp], edx

; 783  :             if ((_Current_grouping_count > '\0' && _Current_grouping_count != CHAR_MAX)
; 784  :                 && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

	movsx	eax, BYTE PTR __Current_grouping_count$6[ebp]
	test	eax, eax
	jle	SHORT $LN47@Parse_int_
	movsx	ecx, BYTE PTR __Current_grouping_count$6[ebp]
	cmp	ecx, 127				; 0000007fH
	je	SHORT $LN47@Parse_int_
	cmp	DWORD PTR __Groups_arr_idx$[ebp], 0
	jbe	SHORT $LN49@Parse_int_
	mov	edx, DWORD PTR __Groups_arr_idx$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	movsx	ecx, BYTE PTR __Current_grouping_count$6[ebp]
	cmp	eax, ecx
	jne	SHORT $LN48@Parse_int_
$LN49@Parse_int_:
	cmp	DWORD PTR __Groups_arr_idx$[ebp], 0
	jne	SHORT $LN47@Parse_int_
	mov	edx, DWORD PTR __Groups_arr_idx$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	movsx	ecx, BYTE PTR __Current_grouping_count$6[ebp]
	cmp	eax, ecx
	jle	SHORT $LN47@Parse_int_
$LN48@Parse_int_:

; 785  :                     || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
; 786  :                 _Bad_grouping = true; // bad group size, fail

	mov	BYTE PTR __Bad_grouping$[ebp], 1
$LN47@Parse_int_:

; 787  :             }
; 788  :             // group size okay, advance to next test
; 789  :         }

	jmp	$LN11@Parse_int_
$LN12@Parse_int_:

; 790  : 
; 791  :         if (!_Seendigit) {

	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	jne	SHORT $LN50@Parse_int_

; 792  :             return {static_cast<int8_t>(~_Base), false};

	movsx	eax, BYTE PTR __Base$[ebp]
	not	eax
	mov	BYTE PTR $T4[ebp], al
	mov	BYTE PTR $T4[ebp+1], 0
	mov	cx, WORD PTR $T4[ebp]
	mov	WORD PTR $T5[ebp], cx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ax, WORD PTR $T5[ebp]
	jmp	SHORT $LN1@Parse_int_
$LN50@Parse_int_:

; 793  :         }
; 794  : 
; 795  :         if (!_Nonzero) {

	movzx	edx, BYTE PTR __Nonzero$[ebp]
	test	edx, edx
	jne	SHORT $LN51@Parse_int_

; 796  :             *_Ptr++ = '0'; // zero field, replace stripped zero(s)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN51@Parse_int_:

; 797  :         }
; 798  : 
; 799  :         *_Ptr = '\0';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 0

; 800  :         return {_Base, _Bad_grouping};

	mov	al, BYTE PTR __Base$[ebp]
	mov	BYTE PTR $T2[ebp], al
	mov	cl, BYTE PTR __Bad_grouping$[ebp]
	mov	BYTE PTR $T2[ebp+1], cl
	mov	dx, WORD PTR $T2[ebp]
	mov	WORD PTR $T3[ebp], dx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ax, WORD PTR $T3[ebp]
$LN1@Parse_int_:

; 801  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN66@Parse_int_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@Parse_int_:
	DD	3
	DD	$LN65@Parse_int_
$LN65@Parse_int_:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$LN61@Parse_int_
	DD	-100					; ffffff9cH
	DD	27					; 0000001bH
	DD	$LN62@Parse_int_
	DD	-156					; ffffff64H
	DD	28					; 0000001cH
	DD	$LN63@Parse_int_
$LN63@Parse_int_:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	0
$LN62@Parse_int_:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	0
$LN61@Parse_int_:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$0:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$1:
	lea	ecx, DWORD PTR __Groups$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 1352 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	push	ebp
	mov	ebp, esp

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

	pop	ebp
	ret	0
??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	DWORD PTR __Bytes$[ebp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	ecx, DWORD PTR __Bytes$[ebp]
	push	ecx
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
$LN1@Allocate:

; 257  :     }
; 258  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 117  :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
$LN1@Get_size_o:

; 123  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@max
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@max:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 78   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 1524 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 1525 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1526 : }

	pop	ebp
	ret	0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 812  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QAE@XZ		; std::locale::id::id<0>
	npad	1
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QAE@XZ		; std::locale::id::id<0>
	npad	1
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$?0$0A@@id@locale@std@@QAE@XZ PROC			; std::locale::id::id<0>, COMDAT
; _this$ = ecx

; 83   :         id() noexcept /* strengthened */ {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 85   : 
; 86   :         id(const id&)            = delete;
; 87   :         id& operator=(const id&) = delete;
; 88   : 
; 89   :         template <int = 0> // TRANSITION, ABI
; 90   :         size_t _Get_index() { // get stamp, with lazy allocation
; 91   :             if (_Id == 0) { // still zero, allocate stamp
; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 93   :                 if (_Id == 0) {
; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 95   :                 }
; 96   :                 _END_LOCK()
; 97   :             }
; 98   :             return _Id;
; 99   :         }
; 100  : 
; 101  : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 102  :         __CLR_OR_THIS_CALL operator size_t() {
; 103  :             return _Get_index();
; 104  :         }
; 105  : #endif // defined(_CRTBLD)
; 106  : 
; 107  :     private:
; 108  :         size_t _Id = 0; // the identifier stamp

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 83   :         id() noexcept /* strengthened */ {}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??$?0$0A@@id@locale@std@@QAE@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1501 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1503 : }

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1501 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1503 : }

	pop	ebp
	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 1524 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 1525 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1526 : }

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2294 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

	push	ebp
	mov	ebp, esp

; 2295 : #if _HAS_CXX23
; 2296 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2297 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2298 :         _Count                  = _Allocated;
; 2299 :         return _Ptr;
; 2300 :     } else
; 2301 : #endif // _HAS_CXX23
; 2302 :     {
; 2303 :         return _Al.allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 2304 :     }
; 2305 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1501 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1503 : }

	pop	ebp
	ret	0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1524 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 1525 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1526 : }

	pop	ebp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 714  :     /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07@std@@YAXPAXI@Z	; std::_Deallocate<8>
	add	esp, 8

; 724  :         }
; 725  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1501 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1503 : }

	pop	ebp
	ret	0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z PROC	; std::_Construct_in_place<char *,char * &>, COMDAT

; 469  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 477  :     }
; 478  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ENDP	; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1524 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 1525 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1526 : }

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -56					; size = 4
__Raw_new$ = -52					; size = 4
__New_ptr$ = -44					; size = 4
__Al$ = -36						; size = 4
__New_capacity$ = -28					; size = 4
__Old_capacity$ = -20					; size = 4
__New_size$ = -16					; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Old_size$[ebp], edx

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Old_capacity$[ebp], edx

; 3035 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3036 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3037 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	ecx, DWORD PTR __New_capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3038 : 
; 3039 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3040 :         _ASAN_STRING_REMOVE(*this);
; 3041 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3042 :         _My_data._Myres       = _New_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [edx+24], eax

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 15	; 0000000fH
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 3046 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	ecx, DWORD PTR _<_Args_1>$[ebp]
	push	ecx
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 3048 :             _My_data._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3049 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3050 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	edx, DWORD PTR _<_Args_1>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR __Raw_new$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 3052 :         }
; 3053 : 
; 3054 :         _ASAN_STRING_CREATE(*this);
; 3055 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3056 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN9@Reallocate:
	DD	2
	DD	$LN8@Reallocate
$LN8@Reallocate:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN6@Reallocate
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 1529 :             },

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1526 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 1527 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 1529 :             },

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Old_ptr$1 = -56					; size = 4
__Raw_new$ = -52					; size = 4
__New_ptr$ = -44					; size = 4
__Al$ = -36						; size = 4
__New_capacity$ = -28					; size = 4
__Old_capacity$ = -20					; size = 4
__New_size$ = -16					; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Old_size$[ebp], edx

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Old_capacity$[ebp], edx

; 3035 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3036 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3037 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	ecx, DWORD PTR __New_capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3038 : 
; 3039 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3040 :         _ASAN_STRING_REMOVE(*this);
; 3041 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3042 :         _My_data._Myres       = _New_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [edx+24], eax

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 15	; 0000000fH
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 3046 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	movzx	ecx, BYTE PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	edx, DWORD PTR __Old_capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 3048 :             _My_data._Bx._Ptr = _New_ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 3049 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3050 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	movzx	ecx, BYTE PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 3052 :         }
; 3053 : 
; 3054 :         _ASAN_STRING_CREATE(*this);
; 3055 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3056 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN9@Reallocate:
	DD	2
	DD	$LN8@Reallocate
$LN8@Reallocate:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN6@Reallocate
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$ = ecx

; 2309 :                 },

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2306 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	add	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2309 :                 },

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1512 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1514 : }

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$numpunct@D@std@@MAE@XZ		; std::numpunct<char>::~numpunct<char>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN4@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN4@scalar
$LN3@scalar:
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN4@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 201  :     void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_free
	add	esp, 4

; 203  :         _CSTD free(const_cast<_Elem*>(_Falsename));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_free
	add	esp, 4

; 204  :         _CSTD free(const_cast<_Elem*>(_Truename));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_free
	add	esp, 4

; 205  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 196  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 197  :         return string_type{_Truename};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 198  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 192  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 193  :         return string_type{_Falsename};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 194  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 188  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 189  :         return string{_Grouping};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 190  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 184  :     virtual _Elem __CLR_OR_THIS_CALL do_thousands_sep() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  :         return _Kseparator;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+13]

; 186  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 180  :     virtual _Elem __CLR_OR_THIS_CALL do_decimal_point() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 181  :         return _Dp;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+12]

; 182  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
tv79 = -92						; size = 4
__Guard$ = -84						; size = 4
__Cvt$ = -72						; size = 44
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 152  :     void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { // initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 153  :         const lconv* _Ptr      = _Lobj._Getlconv();

	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ; std::_Locinfo::_Getlconv
	mov	DWORD PTR __Ptr$[ebp], eax

; 154  :         _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); // conversion information

	lea	eax, DWORD PTR __Cvt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt

; 155  : 
; 156  :         _Grouping  = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 157  :         _Falsename = nullptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 158  :         _Truename  = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 159  : 
; 160  :         _Tidy_guard<numpunct> _Guard{this};

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Guard$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 161  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Cvt);

	movzx	edx, BYTE PTR __Isdef$[ebp]
	test	edx, edx
	je	SHORT $LN5@Init
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN6@Init
$LN5@Init:
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv79[ebp], ecx
$LN6@Init:
	lea	edx, DWORD PTR __Cvt$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 162  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	lea	edx, DWORD PTR __Cvt$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getfalse@_Locinfo@std@@QBEPBDXZ	; std::_Locinfo::_Getfalse
	push	eax
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 163  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	lea	edx, DWORD PTR __Cvt$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Gettrue@_Locinfo@std@@QBEPBDXZ	; std::_Locinfo::_Gettrue
	push	eax
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 164  :         _Guard._Target = nullptr;

	mov	DWORD PTR __Guard$[ebp], 0

; 165  : 
; 166  :         if (_Isdef) { // apply defaults for required facets

	movzx	edx, BYTE PTR __Isdef$[ebp]
	test	edx, edx
	je	SHORT $LN2@Init

; 167  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

	lea	eax, DWORD PTR __Cvt$[ebp]
	push	eax
	push	0
	push	46					; 0000002eH
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+12], al

; 168  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

	lea	edx, DWORD PTR __Cvt$[ebp]
	push	edx
	push	0
	push	44					; 0000002cH
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], al

; 169  :         } else {

	jmp	SHORT $LN3@Init
$LN2@Init:

; 170  :             if constexpr (is_same_v<_Elem, wchar_t>) {
; 171  :                 _Dp         = _Ptr->_W_decimal_point[0];
; 172  :                 _Kseparator = _Ptr->_W_thousands_sep[0];
; 173  :             } else {
; 174  :                 _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem*>(nullptr), _Cvt);

	lea	edx, DWORD PTR __Cvt$[ebp]
	push	edx
	push	0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx]
	push	ecx
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], al

; 175  :                 _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem*>(nullptr), _Cvt);

	lea	eax, DWORD PTR __Cvt$[ebp]
	push	eax
	push	0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+edx]
	push	edx
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], al
$LN3@Init:

; 176  :             }
; 177  :         }
; 178  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Guard$[ebp]
	call	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Init
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN12@Init:
	DD	2
	DD	$LN11@Init
$LN11@Init:
	DD	-72					; ffffffb8H
	DD	44					; 0000002cH
	DD	$LN8@Init
	DD	-84					; ffffffacH
	DD	4
	DD	$LN9@Init
$LN9@Init:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN8@Init:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	118					; 00000076H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:
	lea	ecx, DWORD PTR __Guard$[ebp]
	jmp	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$numpunct@D@std@@6B@

; 143  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy
	npad	1

; 144  :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
tv89 = -88						; size = 4
tv95 = -84						; size = 4
tv130 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 52
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 133  :     static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 134  :         // return locale category mask and construct standard facet
; 135  :         if (_Ppf && !*_Ppf) {

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN9@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN9@Getcat

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

	push	24					; 00000018H
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	1
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?_C_str@locale@std@@QBEPBDXZ		; std::locale::_C_str
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR tv130[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv95[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ; std::numpunct<char>::numpunct<char>
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv89[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 1
	je	SHORT $LN9@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
	npad	1
$LN9@Getcat:

; 137  :         }
; 138  :         return _X_NUMERIC;

	mov	eax, 4

; 139  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 129  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$numpunct@D@std@@6B@

; 130  :         _Init(_Lobj, _Isdef);

	movzx	edx, BYTE PTR __Isdef$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lobj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init
	npad	1

; 131  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 115  :     string_type truename() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 116  :         return do_truename();

	mov	esi, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 117  :     }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 111  :     string_type falsename() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 112  :         return do_falsename();

	mov	esi, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 113  :     }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 107  :     string grouping() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 108  :         return do_grouping();

	mov	esi, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 109  :     }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 103  :     _Elem thousands_sep() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 104  :         return do_thousands_sep();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 105  :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 99   :     _Elem decimal_point() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 100  :         return do_decimal_point();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 101  :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
__Psave_guard$3 = -56					; size = 4
__Pfmod$4 = -48						; size = 4
__Pf$5 = -44						; size = 4
__Id$6 = -40						; size = 4
__Psave$7 = -32						; size = 4
__Lock$8 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	DWORD PTR __Psave$7[ebp], eax

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();

	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$_Get_index@$0A@@id@locale@std@@QAEIXZ ; std::locale::id::_Get_index<0>
	mov	DWORD PTR __Id$6[ebp], eax

; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$6[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$5[ebp], eax

; 441  : 
; 442  :     if (!_Pf) {

	cmp	DWORD PTR __Pf$5[ebp], 0
	jne	$LN6@use_facet

; 443  :         if (_Psave) {

	cmp	DWORD PTR __Psave$7[ebp], 0
	je	SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], edx
	jmp	SHORT $LN6@use_facet
$LN3@use_facet:

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$7[ebp]
	push	ecx
	call	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 446  : #if _HAS_EXCEPTIONS
; 447  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 448  : #else
; 449  :             _CSTD abort(); // lazy disallowed
; 450  : #endif
; 451  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN6@use_facet
$LN5@use_facet:

; 452  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pfmod$4[ebp], edx

; 453  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	eax, DWORD PTR __Pfmod$4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 454  : 
; 455  : #if defined(_M_CEE)
; 456  :             _Facet_Register_m(_Pfmod);
; 457  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 458  :             _Facet_Register(_Pfmod);

	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	push	ecx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR __Pfmod$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::numpunct<char> >::_Psave

; 463  :             _Pf                       = _Psave;

	mov	ecx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], ecx

; 464  : 
; 465  :             (void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 466  :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	npad	1
$LN6@use_facet:

; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	edx, DWORD PTR __Pf$5[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@use_facet
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@use_facet:
	DD	3
	DD	$LN14@use_facet
$LN14@use_facet:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN10@use_facet
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN11@use_facet
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN12@use_facet
$LN12@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN11@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$LN10@use_facet:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$8[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT ??$isfinite@N@@YA_NN@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
__X$ = 8						; size = 8
??$isfinite@N@@YA_NN@Z PROC				; isfinite<double>, COMDAT

; 436  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 437  :         return fpclassify(_X) <= 0;

	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?fpclassify@@YAHN@Z			; fpclassify
	add	esp, 8
	test	eax, eax
	jg	SHORT $LN3@isfinite
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@isfinite
$LN3@isfinite:
	mov	DWORD PTR tv67[ebp], 0
$LN4@isfinite:
	movzx	eax, BYTE PTR tv67[ebp]

; 438  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$isfinite@N@@YA_NN@Z ENDP				; isfinite<double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@N@std@@YAH_JH@Z
_TEXT	SEGMENT
tv72 = -10						; size = 1
tv65 = -9						; size = 1
__Default_precision$1 = -8				; size = 4
__Is_default_float$2 = -2				; size = 1
__Is_hex$ = -1						; size = 1
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@N@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<double>, COMDAT

; 1178 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1179 :     // return the effective precision determined by N4950 [facet.num.put.virtuals]/2.1 and printf's rules
; 1180 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR __Float_flags$[ebp], 12288	; 00003000H
	jne	SHORT $LN10@Float_put_
	mov	BYTE PTR tv65[ebp], 1
	jmp	SHORT $LN11@Float_put_
$LN10@Float_put_:
	mov	BYTE PTR tv65[ebp], 0
$LN11@Float_put_:
	mov	al, BYTE PTR tv65[ebp]
	mov	BYTE PTR __Is_hex$[ebp], al

; 1181 :     if (_Is_hex) {

	movzx	ecx, BYTE PTR __Is_hex$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@Float_put_

; 1182 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1183 :         if constexpr (is_same_v<_Ty, double>) {
; 1184 :             return ((DBL_MANT_DIG - 1) + 3) / 4;

	mov	eax, 13					; 0000000dH
	jmp	SHORT $LN6@Float_put_
$LN2@Float_put_:

; 1185 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1186 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;
; 1187 :         } else {
; 1188 :             _STL_INTERNAL_STATIC_ASSERT(false); // unexpected type; shouldn't be float
; 1189 :         }
; 1190 :     }
; 1191 : 
; 1192 :     if (_Precision > 0) {

	cmp	DWORD PTR __Precision$[ebp+4], 0
	jl	SHORT $LN3@Float_put_
	jg	SHORT $LN14@Float_put_
	cmp	DWORD PTR __Precision$[ebp], 0
	jbe	SHORT $LN3@Float_put_
$LN14@Float_put_:

; 1193 :         return static_cast<int>(_Precision);

	mov	eax, DWORD PTR __Precision$[ebp]
	jmp	SHORT $LN6@Float_put_
	jmp	SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1194 :     } else if (_Precision == 0) {

	mov	edx, DWORD PTR __Precision$[ebp]
	or	edx, DWORD PTR __Precision$[ebp+4]
	jne	SHORT $LN5@Float_put_

; 1195 :         const bool _Is_default_float = _Float_flags == 0;

	cmp	DWORD PTR __Float_flags$[ebp], 0
	jne	SHORT $LN12@Float_put_
	mov	BYTE PTR tv72[ebp], 1
	jmp	SHORT $LN13@Float_put_
$LN12@Float_put_:
	mov	BYTE PTR tv72[ebp], 0
$LN13@Float_put_:
	mov	al, BYTE PTR tv72[ebp]
	mov	BYTE PTR __Is_default_float$2[ebp], al

; 1196 :         if (_Is_default_float) {

	movzx	ecx, BYTE PTR __Is_default_float$2[ebp]
	test	ecx, ecx
	je	SHORT $LN7@Float_put_

; 1197 :             return 1;

	mov	eax, 1
	jmp	SHORT $LN6@Float_put_

; 1198 :         } else {

	jmp	SHORT $LN8@Float_put_
$LN7@Float_put_:

; 1199 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN6@Float_put_
$LN8@Float_put_:

; 1200 :         }
; 1201 :     } else {

	jmp	SHORT $LN6@Float_put_
$LN5@Float_put_:

; 1202 :         constexpr int _Default_precision = 6;

	mov	DWORD PTR __Default_precision$1[ebp], 6

; 1203 :         return _Default_precision;

	mov	eax, 6
$LN6@Float_put_:

; 1204 :     }
; 1205 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Float_put_desired_precision@N@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
_TEXT	SEGMENT
tv397 = -244						; size = 8
tv188 = -236						; size = 4
tv295 = -232						; size = 4
tv154 = -228						; size = 4
tv292 = -224						; size = 4
tv299 = -220						; size = 4
tv69 = -216						; size = 4
$T2 = -212						; size = 8
$T3 = -204						; size = 8
$T4 = -196						; size = 8
$T5 = -188						; size = 8
$T6 = -180						; size = 8
$T7 = -172						; size = 8
$T8 = -164						; size = 8
$T9 = -156						; size = 8
__Adjustfield$ = -148					; size = 4
__Fillcount$ = -144					; size = 4
__Pg$10 = -140						; size = 4
__Off$11 = -136						; size = 4
__Kseparator$ = -129					; size = 1
__Grouping$ = -124					; size = 28
__Punct_fac$ = -92					; size = 4
__Groupstring$ = -84					; size = 28
__Ctype_fac$ = -52					; size = 4
__Poff$ = -48						; size = 4
__Dp$ = -40						; size = 2
__Eoff$ = -32						; size = 4
__Exps$ = -28						; size = 4
__Prefix$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Buf$ = 28						; size = 4
__Count$ = 32						; size = 4
__Is_finite_val$ = 36					; size = 1
??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>, COMDAT
; _this$ = ecx

; 1470 :         bool _Is_finite_val) const { // put formatted floating-point to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1471 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN20@Fput_v3
	mov	eax, DWORD PTR __Buf$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN19@Fput_v3
	mov	edx, DWORD PTR __Buf$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN20@Fput_v3
$LN19@Fput_v3:
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN21@Fput_v3
$LN20@Fput_v3:
	mov	DWORD PTR tv69[ebp], 0
$LN21@Fput_v3:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR __Prefix$[ebp], ecx

; 1472 :         const char* _Exps;
; 1473 :         if ((_Iosbase.flags() & ios_base::floatfield) != (ios_base::scientific | ios_base::fixed)) {

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN4@Fput_v3

; 1474 :             _Exps = "eE";

	mov	DWORD PTR __Exps$[ebp], OFFSET ??_C@_02MDKMJEGG@eE@

; 1475 :         } else { // correct for hexadecimal floating-point

	jmp	SHORT $LN6@Fput_v3
$LN4@Fput_v3:

; 1476 :             _Exps = "pP";

	mov	DWORD PTR __Exps$[ebp], OFFSET ??_C@_02OOPEBDOJ@pP@

; 1477 :             if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1478 :                 && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	mov	edx, DWORD PTR __Prefix$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN6@Fput_v3
	mov	eax, DWORD PTR __Buf$[ebp]
	add	eax, DWORD PTR __Prefix$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN6@Fput_v3
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Prefix$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN7@Fput_v3
	mov	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, DWORD PTR __Prefix$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 88					; 00000058H
	jne	SHORT $LN6@Fput_v3
$LN7@Fput_v3:

; 1479 :                 _Prefix += 2;

	mov	eax, DWORD PTR __Prefix$[ebp]
	add	eax, 2
	mov	DWORD PTR __Prefix$[ebp], eax
$LN6@Fput_v3:

; 1480 :             }
; 1481 :         }
; 1482 :         const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent

	mov	ecx, DWORD PTR __Exps$[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_strcspn
	add	esp, 8
	mov	DWORD PTR __Eoff$[ebp], eax

; 1483 :         char _Dp[2]        = {"."};

	mov	cx, WORD PTR ??_C@_01LFCBOECM@?4@
	mov	WORD PTR __Dp$[ebp], cx

; 1484 :         _Dp[0]             = (_CSTD localeconv())->decimal_point[0];

	call	_localeconv
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR [eax]
	mov	eax, 1
	imul	eax, eax, 0
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Dp$[ebp+eax], cl

; 1485 :         const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR __Dp$[ebp+eax]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_strcspn
	add	esp, 8
	mov	DWORD PTR __Poff$[ebp], eax

; 1486 : 
; 1487 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv299[ebp], eax
	mov	edx, DWORD PTR tv299[ebp]
	mov	DWORD PTR tv292[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv292[ebp]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 1488 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1489 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen
	npad	1

; 1490 : 
; 1491 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv154[ebp], eax
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv295[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv295[ebp]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 1492 :         const string _Grouping  = _Punct_fac.grouping();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1493 :         const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR __Kseparator$[ebp], al

; 1494 : 
; 1495 :         if (_Poff != _Count) {

	mov	edx, DWORD PTR __Poff$[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	je	SHORT $LN8@Fput_v3

; 1496 :             _Groupstring[_Poff] = _Punct_fac.decimal_point();

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?decimal_point@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::decimal_point
	mov	bl, al
	mov	eax, DWORD PTR __Poff$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl
$LN8@Fput_v3:

; 1497 :         }
; 1498 : 
; 1499 :         if (_Is_finite_val) {

	movzx	ecx, BYTE PTR __Is_finite_val$[ebp]
	test	ecx, ecx
	je	$LN3@Fput_v3

; 1500 :             size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

	mov	edx, DWORD PTR __Poff$[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jne	SHORT $LN22@Fput_v3
	mov	eax, DWORD PTR __Eoff$[ebp]
	mov	DWORD PTR tv188[ebp], eax
	jmp	SHORT $LN23@Fput_v3
$LN22@Fput_v3:
	mov	ecx, DWORD PTR __Poff$[ebp]
	mov	DWORD PTR tv188[ebp], ecx
$LN23@Fput_v3:
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR __Off$11[ebp], edx

; 1501 :             const char* _Pg = &_Grouping[0];

	push	0
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Pg$10[ebp], eax
$LN2@Fput_v3:

; 1502 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {

	mov	eax, DWORD PTR __Pg$10[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	je	SHORT $LN3@Fput_v3
	mov	edx, DWORD PTR __Pg$10[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jle	SHORT $LN3@Fput_v3
	mov	ecx, DWORD PTR __Pg$10[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Off$11[ebp]
	sub	eax, DWORD PTR __Prefix$[ebp]
	cmp	edx, eax
	jae	SHORT $LN3@Fput_v3

; 1503 :                 // add thousands separator
; 1504 :                 _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);

	mov	ecx, DWORD PTR __Pg$10[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Off$11[ebp]
	sub	eax, edx
	mov	DWORD PTR __Off$11[ebp], eax
	movzx	ecx, BYTE PTR __Kseparator$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR __Off$11[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	npad	1

; 1505 :                 if ('\0' < _Pg[1]) {

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR __Pg$10[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jle	SHORT $LN10@Fput_v3

; 1506 :                     ++_Pg; // not last group, advance

	mov	eax, DWORD PTR __Pg$10[ebp]
	add	eax, 1
	mov	DWORD PTR __Pg$10[ebp], eax
$LN10@Fput_v3:

; 1507 :                 }
; 1508 :             }

	jmp	$LN2@Fput_v3
$LN3@Fput_v3:

; 1509 :         }
; 1510 : 
; 1511 :         _Count = _Groupstring.size();

	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Count$[ebp], eax

; 1512 : 
; 1513 :         size_t _Fillcount;
; 1514 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv397[ebp], eax
	mov	DWORD PTR tv397[ebp+4], edx
	cmp	DWORD PTR tv397[ebp+4], 0
	jl	SHORT $LN13@Fput_v3
	jg	SHORT $LN28@Fput_v3
	cmp	DWORD PTR tv397[ebp], 0
	jbe	SHORT $LN13@Fput_v3
$LN28@Fput_v3:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN11@Fput_v3
$LN13@Fput_v3:

; 1515 :             _Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1516 :         } else {

	jmp	SHORT $LN12@Fput_v3
$LN11@Fput_v3:

; 1517 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Fillcount$[ebp], eax
$LN12@Fput_v3:

; 1518 :         }
; 1519 : 
; 1520 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR __Adjustfield$[ebp], eax

; 1521 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	cmp	DWORD PTR __Adjustfield$[ebp], 64	; 00000040H
	je	$LN14@Fput_v3
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	je	SHORT $LN14@Fput_v3

; 1522 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	mov	ecx, DWORD PTR __Fillcount$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1523 :             _Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1524 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
	jmp	$LN17@Fput_v3
$LN14@Fput_v3:

; 1525 :         } else if (_Adjustfield == ios_base::internal) { // put internal fill

	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	jne	SHORT $LN16@Fput_v3

; 1526 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1527 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1528 :             _Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1529 :         } else {

	jmp	SHORT $LN17@Fput_v3
$LN16@Fput_v3:

; 1530 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
$LN17@Fput_v3:

; 1531 :         }
; 1532 : 
; 1533 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Prefix$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1534 :         _Iosbase.width(0);

	push	0
	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width

; 1535 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1536 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN34@Fput_v3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	1
$LN34@Fput_v3:
	DD	3
	DD	$LN33@Fput_v3
$LN33@Fput_v3:
	DD	-40					; ffffffd8H
	DD	2
	DD	$LN29@Fput_v3
	DD	-84					; ffffffacH
	DD	28					; 0000001cH
	DD	$LN30@Fput_v3
	DD	-124					; ffffff84H
	DD	28					; 0000001cH
	DD	$LN31@Fput_v3
$LN31@Fput_v3:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN30@Fput_v3:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN29@Fput_v3:
	DB	95					; 0000005fH
	DB	68					; 00000044H
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$0:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT ??$isfinite@O@@YA_NO@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
__X$ = 8						; size = 8
??$isfinite@O@@YA_NO@Z PROC				; isfinite<long double>, COMDAT

; 436  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 437  :         return fpclassify(_X) <= 0;

	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?fpclassify@@YAHO@Z			; fpclassify
	add	esp, 8
	test	eax, eax
	jg	SHORT $LN3@isfinite
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@isfinite
$LN3@isfinite:
	mov	DWORD PTR tv67[ebp], 0
$LN4@isfinite:
	movzx	eax, BYTE PTR tv67[ebp]

; 438  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$isfinite@O@@YA_NO@Z ENDP				; isfinite<long double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@O@std@@YAH_JH@Z
_TEXT	SEGMENT
tv72 = -10						; size = 1
tv65 = -9						; size = 1
__Default_precision$1 = -8				; size = 4
__Is_default_float$2 = -2				; size = 1
__Is_hex$ = -1						; size = 1
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@O@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<long double>, COMDAT

; 1178 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1179 :     // return the effective precision determined by N4950 [facet.num.put.virtuals]/2.1 and printf's rules
; 1180 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR __Float_flags$[ebp], 12288	; 00003000H
	jne	SHORT $LN10@Float_put_
	mov	BYTE PTR tv65[ebp], 1
	jmp	SHORT $LN11@Float_put_
$LN10@Float_put_:
	mov	BYTE PTR tv65[ebp], 0
$LN11@Float_put_:
	mov	al, BYTE PTR tv65[ebp]
	mov	BYTE PTR __Is_hex$[ebp], al

; 1181 :     if (_Is_hex) {

	movzx	ecx, BYTE PTR __Is_hex$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@Float_put_

; 1182 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1183 :         if constexpr (is_same_v<_Ty, double>) {
; 1184 :             return ((DBL_MANT_DIG - 1) + 3) / 4;
; 1185 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1186 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;

	mov	eax, 13					; 0000000dH
	jmp	SHORT $LN6@Float_put_
$LN2@Float_put_:

; 1187 :         } else {
; 1188 :             _STL_INTERNAL_STATIC_ASSERT(false); // unexpected type; shouldn't be float
; 1189 :         }
; 1190 :     }
; 1191 : 
; 1192 :     if (_Precision > 0) {

	cmp	DWORD PTR __Precision$[ebp+4], 0
	jl	SHORT $LN3@Float_put_
	jg	SHORT $LN14@Float_put_
	cmp	DWORD PTR __Precision$[ebp], 0
	jbe	SHORT $LN3@Float_put_
$LN14@Float_put_:

; 1193 :         return static_cast<int>(_Precision);

	mov	eax, DWORD PTR __Precision$[ebp]
	jmp	SHORT $LN6@Float_put_
	jmp	SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1194 :     } else if (_Precision == 0) {

	mov	edx, DWORD PTR __Precision$[ebp]
	or	edx, DWORD PTR __Precision$[ebp+4]
	jne	SHORT $LN5@Float_put_

; 1195 :         const bool _Is_default_float = _Float_flags == 0;

	cmp	DWORD PTR __Float_flags$[ebp], 0
	jne	SHORT $LN12@Float_put_
	mov	BYTE PTR tv72[ebp], 1
	jmp	SHORT $LN13@Float_put_
$LN12@Float_put_:
	mov	BYTE PTR tv72[ebp], 0
$LN13@Float_put_:
	mov	al, BYTE PTR tv72[ebp]
	mov	BYTE PTR __Is_default_float$2[ebp], al

; 1196 :         if (_Is_default_float) {

	movzx	ecx, BYTE PTR __Is_default_float$2[ebp]
	test	ecx, ecx
	je	SHORT $LN7@Float_put_

; 1197 :             return 1;

	mov	eax, 1
	jmp	SHORT $LN6@Float_put_

; 1198 :         } else {

	jmp	SHORT $LN8@Float_put_
$LN7@Float_put_:

; 1199 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN6@Float_put_
$LN8@Float_put_:

; 1200 :         }
; 1201 :     } else {

	jmp	SHORT $LN6@Float_put_
$LN5@Float_put_:

; 1202 :         constexpr int _Default_precision = 6;

	mov	DWORD PTR __Default_precision$1[ebp], 6

; 1203 :         return _Default_precision;

	mov	eax, 6
$LN6@Float_put_:

; 1204 :     }
; 1205 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Float_put_desired_precision@O@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<long double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >, COMDAT

; 1524 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp

; 1525 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1526 : }

	pop	ebp
	ret	0
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __New_val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 775  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 776  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ
_TEXT	SEGMENT
__Meta$ = -8						; size = 4
_this$ = -4						; size = 4
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek, COMDAT
; _this$ = ecx

; 468  :     _Elem _Peek() const { // peek at next input element

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 469  :         int_type _Meta;
; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Peek
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR __Meta$[ebp], eax
	mov	edx, DWORD PTR __Meta$[ebp]
	push	edx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Peek
$LN4@Peek:

; 471  :             _Strbuf = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 472  :         } else {

	jmp	SHORT $LN3@Peek
$LN2@Peek:

; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	edx, DWORD PTR __Meta$[ebp]
	push	edx
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5], al
$LN3@Peek:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 1

; 477  :         return _Val;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+5]

; 478  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc, COMDAT
; _this$ = ecx

; 459  :     void _Inc() { // skip to next input element

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Inc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
	push	eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Inc
$LN4@Inc:

; 461  :             _Strbuf = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 462  :             _Got    = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 1

; 463  :         } else {

	jmp	SHORT $LN3@Inc
$LN2@Inc:

; 464  :             _Got = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 0
$LN3@Inc:

; 465  :         }
; 466  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::equal, COMDAT
; _this$ = ecx

; 436  :     _NODISCARD bool equal(const istreambuf_iterator& _Right) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 437  :         if (!_Got) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN2@equal

; 438  :             _Peek();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
	npad	1
$LN2@equal:

; 439  :         }
; 440  : 
; 441  :         if (!_Right._Got) {

	mov	edx, DWORD PTR __Right$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	test	eax, eax
	jne	SHORT $LN3@equal

; 442  :             _Right._Peek();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
	npad	1
$LN3@equal:

; 443  :         }
; 444  : 
; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@equal
	mov	edx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@equal
$LN5@equal:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@equal
	mov	ecx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN7@equal
$LN6@equal:
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN8@equal
$LN7@equal:
	mov	DWORD PTR tv80[ebp], 1
$LN8@equal:
	movzx	eax, BYTE PTR tv80[ebp]

; 446  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 417  :     istreambuf_iterator& operator++() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 418  : #if _ITERATOR_DEBUG_LEVEL == 2
; 419  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not incrementable");

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@operator
	push	OFFSET ??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	419					; 000001a3H
	push	OFFSET ??_C@_0GD@HACHJAJP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@operator
	int	3
$LN4@operator:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@operator:

; 420  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 421  : 
; 422  :         _Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc

; 423  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 424  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 405  :     _NODISCARD _Elem operator*() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 406  :         if (!_Got) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN2@operator

; 407  :             _Peek();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
	npad	1
$LN2@operator:

; 408  :         }
; 409  : 
; 410  : #if _ITERATOR_DEBUG_LEVEL == 2
; 411  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not dereferenceable");

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@operator
	push	OFFSET ??_C@_0CL@CMFIACBP@istreambuf_iterator?5is?5not?5dere@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	411					; 0000019bH
	push	OFFSET ??_C@_0GD@HACHJAJP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN5@operator
	int	3
$LN5@operator:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN3@operator:

; 412  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 413  : 
; 414  :         return _Val;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+5]
$LN1@operator:

; 415  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@istreambuf
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@istreambuf
$LN3@istreambuf:
	mov	DWORD PTR tv79[ebp], 0
$LN4@istreambuf:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv79[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 376  :     constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN4@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN4@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN4@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
_TEXT	SEGMENT
tv128 = -116						; size = 4
tv129 = -112						; size = 4
$T2 = -108						; size = 8
$T3 = -98						; size = 2
__Ep$4 = -92						; size = 4
__Errno$5 = -80						; size = 4
__Parse_result$ = -68					; size = 2
__Ac$ = -56						; size = 32
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 623  :         void*& _Val) const { // get void pointer from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 624  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 625  :         char _Ac[_Max_int_dig];
; 626  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv129[ebp], eax
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv128[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv128[ebp]
	push	ecx
	push	2048					; 00000800H
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 627  :             _Parse_int_with_locale(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); // gather field
; 628  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jge	SHORT $LN2@do_get

; 629  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 630  :             _Val   = nullptr;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [edx], 0

; 631  :         } else {

	jmp	SHORT $LN6@do_get
$LN2@do_get:

; 632  :             int _Errno;
; 633  :             char* _Ep;
; 634  : #ifdef _WIN64
; 635  :             _Val = reinterpret_cast<void*>(_CSTD _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno));
; 636  : #else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
; 637  :             _Val = reinterpret_cast<void*>(_CSTD _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno));

	lea	eax, DWORD PTR __Errno$5[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Parse_result$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ep$4[ebp]
	push	edx
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 638  : #endif // ^^^ !defined(_WIN64) ^^^
; 639  :             if (_Ep == _Ac || _Errno != 0) { // N4950 [facet.num.get.virtuals]/3

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$5[ebp], 0
	je	SHORT $LN4@do_get
$LN5@do_get:

; 640  :                 _State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 641  :                 _Val   = nullptr;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], 0
$LN4@do_get:

; 642  :             }
; 643  : 
; 644  :             if (_Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	movzx	edx, BYTE PTR __Parse_result$[ebp+1]
	test	edx, edx
	je	SHORT $LN6@do_get

; 645  :                 _State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN6@do_get:

; 646  :             }
; 647  :         }
; 648  : 
; 649  :         if (_First == _Last) {

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@do_get

; 650  :             _State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN7@do_get:

; 651  :         }
; 652  : 
; 653  :         return _First;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 654  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	3
$LN16@do_get:
	DD	4
	DD	$LN15@do_get
$LN15@do_get:
	DD	-56					; ffffffc8H
	DD	32					; 00000020H
	DD	$LN10@do_get
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN11@do_get
	DD	-80					; ffffffb0H
	DD	4
	DD	$LN12@do_get
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN13@do_get
$LN13@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN12@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN11@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN10@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
__Result$ = -16						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 612  :         long double& _Val) const { // get long double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 613  :         // Assumes sizeof(double) == sizeof(long double).
; 614  :         // For 80-bit long double (which is not supported by MSVC in general), this will compile
; 615  :         // but will not attempt to handle the increased precision at runtime.
; 616  :         double _Result;
; 617  :         _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); // avoid virtual call for perf

	lea	eax, DWORD PTR __Result$[ebp]
	push	eax
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __First$[ebp], edx
	mov	DWORD PTR __First$[ebp+4], eax

; 618  :         _Val   = _Result;

	mov	ecx, DWORD PTR __Val$[ebp]
	movsd	xmm0, QWORD PTR __Result$[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 619  :         return _First;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 620  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN5@do_get:
	DD	1
	DD	$LN4@do_get
$LN4@do_get:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN3@do_get
$LN3@do_get:
	DB	95					; 0000005fH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
_TEXT	SEGMENT
tv94 = -876						; size = 4
tv95 = -872						; size = 4
$T2 = -868						; size = 8
$T3 = -858						; size = 2
__Ep$4 = -852						; size = 4
__Errno$5 = -840					; size = 4
__Parse_result$ = -828					; size = 2
__Ac$ = -816						; size = 792
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 584  :         double& _Val) const { // get double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 864				; 00000360H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-876]
	mov	ecx, 216				; 000000d8H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 585  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 586  :         char _Ac[_FLOATING_BUFFER_SIZE];
; 587  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv95[ebp], eax
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv94[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	push	768					; 00000300H
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 588  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field
; 589  :         if (_Parse_result._Base == 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jne	SHORT $LN2@do_get

; 590  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 591  :             _Val   = 0.0;

	mov	edx, DWORD PTR __Val$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [edx], xmm0

; 592  :         } else {

	jmp	SHORT $LN4@do_get
$LN2@do_get:

; 593  :             int _Errno;
; 594  :             char* _Ep;
; 595  :             _Val = _STD _Stodx_v3(_Ac, &_Ep, &_Errno); // convert

	lea	eax, DWORD PTR __Errno$5[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	?_Stodx_v3@std@@YANPBDPAPADPAH@Z	; std::_Stodx_v3
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR __Val$[ebp]
	fstp	QWORD PTR [eax]

; 596  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 597  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	lea	ecx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], ecx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$5[ebp], 0
	jne	SHORT $LN5@do_get
	movzx	edx, BYTE PTR __Parse_result$[ebp+1]
	test	edx, edx
	je	SHORT $LN4@do_get
$LN5@do_get:

; 598  :                 _State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN4@do_get:

; 599  :             }
; 600  :         }
; 601  : 
; 602  :         if (_First == _Last) {

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@do_get

; 603  :             _State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN6@do_get:

; 604  :         }
; 605  : 
; 606  :         return _First;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 607  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 876				; 0000036cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	2
$LN15@do_get:
	DD	4
	DD	$LN14@do_get
$LN14@do_get:
	DD	-816					; fffffcd0H
	DD	792					; 00000318H
	DD	$LN9@do_get
	DD	-828					; fffffcc4H
	DD	2
	DD	$LN10@do_get
	DD	-840					; fffffcb8H
	DD	4
	DD	$LN11@do_get
	DD	-852					; fffffcacH
	DD	4
	DD	$LN12@do_get
$LN12@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN11@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN10@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN9@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-872]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
_TEXT	SEGMENT
tv94 = -876						; size = 4
tv95 = -872						; size = 4
$T2 = -868						; size = 8
$T3 = -858						; size = 2
__Ep$4 = -852						; size = 4
__Errno$5 = -840					; size = 4
__Parse_result$ = -828					; size = 2
__Ac$ = -816						; size = 792
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 558  :         float& _Val) const { // get float from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 864				; 00000360H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-876]
	mov	ecx, 216				; 000000d8H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 559  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 560  :         char _Ac[_FLOATING_BUFFER_SIZE];
; 561  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv95[ebp], eax
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv94[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	push	768					; 00000300H
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 562  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field
; 563  :         if (_Parse_result._Base == 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jne	SHORT $LN2@do_get

; 564  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 565  :             _Val   = 0.0f;

	mov	edx, DWORD PTR __Val$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx], xmm0

; 566  :         } else {

	jmp	SHORT $LN4@do_get
$LN2@do_get:

; 567  :             int _Errno;
; 568  :             char* _Ep;
; 569  :             _Val = _STD _Stofx_v3(_Ac, &_Ep, &_Errno); // convert

	lea	eax, DWORD PTR __Errno$5[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	?_Stofx_v3@std@@YAMPBDPAPADPAH@Z	; std::_Stofx_v3
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR __Val$[ebp]
	fstp	DWORD PTR [eax]

; 570  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 571  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	lea	ecx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], ecx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$5[ebp], 0
	jne	SHORT $LN5@do_get
	movzx	edx, BYTE PTR __Parse_result$[ebp+1]
	test	edx, edx
	je	SHORT $LN4@do_get
$LN5@do_get:

; 572  :                 _State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN4@do_get:

; 573  :             }
; 574  :         }
; 575  : 
; 576  :         if (_First == _Last) {

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@do_get

; 577  :             _State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN6@do_get:

; 578  :         }
; 579  : 
; 580  :         return _First;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 581  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 876				; 0000036cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	2
$LN15@do_get:
	DD	4
	DD	$LN14@do_get
$LN14@do_get:
	DD	-816					; fffffcd0H
	DD	792					; 00000318H
	DD	$LN9@do_get
	DD	-828					; fffffcc4H
	DD	2
	DD	$LN10@do_get
	DD	-840					; fffffcb8H
	DD	4
	DD	$LN11@do_get
	DD	-852					; fffffcacH
	DD	4
	DD	$LN12@do_get
$LN12@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN11@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN10@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN9@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-872]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
_TEXT	SEGMENT
tv130 = -116						; size = 4
tv131 = -112						; size = 4
$T2 = -108						; size = 8
$T3 = -98						; size = 2
__Ep$4 = -92						; size = 4
__Errno$5 = -80						; size = 4
__Parse_result$ = -68					; size = 2
__Ac$ = -56						; size = 32
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 527  :         unsigned long long& _Val) const { // get unsigned long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 528  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 529  :         char _Ac[_Max_int_dig];
; 530  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 531  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
; 532  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jge	SHORT $LN2@do_get

; 533  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 534  :             _Val   = 0;

	mov	edx, DWORD PTR __Val$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 535  :         } else {

	jmp	SHORT $LN4@do_get
$LN2@do_get:

; 536  :             int _Errno;
; 537  :             char* _Ep;
; 538  :             _Val = _CSTD _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

	lea	edx, DWORD PTR __Errno$5[ebp]
	push	edx
	movsx	eax, BYTE PTR __Parse_result$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	__Stoullx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 539  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 540  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$5[ebp], 0
	jne	SHORT $LN5@do_get
	movzx	eax, BYTE PTR __Parse_result$[ebp+1]
	test	eax, eax
	je	SHORT $LN4@do_get
$LN5@do_get:

; 541  :                 _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2
$LN4@do_get:

; 542  :             }
; 543  :         }
; 544  : 
; 545  :         if (_First == _Last) {

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@do_get

; 546  :             _State |= ios_base::eofbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@do_get:

; 547  :         }
; 548  : 
; 549  :         return _First;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 550  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	3
$LN15@do_get:
	DD	4
	DD	$LN14@do_get
$LN14@do_get:
	DD	-56					; ffffffc8H
	DD	32					; 00000020H
	DD	$LN9@do_get
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN10@do_get
	DD	-80					; ffffffb0H
	DD	4
	DD	$LN11@do_get
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN12@do_get
$LN12@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN11@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN10@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN9@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
_TEXT	SEGMENT
tv130 = -116						; size = 4
tv131 = -112						; size = 4
$T2 = -108						; size = 8
$T3 = -98						; size = 2
__Errno$4 = -92						; size = 4
__Ep$5 = -80						; size = 4
__Parse_result$ = -68					; size = 2
__Ac$ = -56						; size = 32
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 501  :         long long& _Val) const { // get long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 502  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 503  :         char _Ac[_Max_int_dig];
; 504  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 505  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
; 506  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jge	SHORT $LN2@do_get

; 507  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 508  :             _Val   = 0;

	mov	edx, DWORD PTR __Val$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 509  :         } else {

	jmp	SHORT $LN4@do_get
$LN2@do_get:

; 510  :             char* _Ep;
; 511  :             int _Errno;
; 512  :             _Val = _CSTD _Stollx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

	lea	edx, DWORD PTR __Errno$4[ebp]
	push	edx
	movsx	eax, BYTE PTR __Parse_result$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$5[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	__Stollx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 513  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 514  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$5[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$4[ebp], 0
	jne	SHORT $LN5@do_get
	movzx	eax, BYTE PTR __Parse_result$[ebp+1]
	test	eax, eax
	je	SHORT $LN4@do_get
$LN5@do_get:

; 515  :                 _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2
$LN4@do_get:

; 516  :             }
; 517  :         }
; 518  : 
; 519  :         if (_First == _Last) {

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@do_get

; 520  :             _State |= ios_base::eofbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@do_get:

; 521  :         }
; 522  : 
; 523  :         return _First;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 524  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	3
$LN15@do_get:
	DD	4
	DD	$LN14@do_get
$LN14@do_get:
	DD	-56					; ffffffc8H
	DD	32					; 00000020H
	DD	$LN9@do_get
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN10@do_get
	DD	-80					; ffffffb0H
	DD	4
	DD	$LN11@do_get
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN12@do_get
$LN12@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN11@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN10@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN9@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
_TEXT	SEGMENT
tv130 = -116						; size = 4
tv131 = -112						; size = 4
$T2 = -108						; size = 8
$T3 = -98						; size = 2
__Errno$4 = -92						; size = 4
__Ep$5 = -80						; size = 4
__Parse_result$ = -68					; size = 2
__Ac$ = -56						; size = 32
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 475  :         unsigned long& _Val) const { // get unsigned long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 476  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 477  :         char _Ac[_Max_int_dig];
; 478  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 479  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
; 480  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jge	SHORT $LN2@do_get

; 481  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 482  :             _Val   = 0;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [edx], 0

; 483  :         } else {

	jmp	SHORT $LN4@do_get
$LN2@do_get:

; 484  :             char* _Ep;
; 485  :             int _Errno;
; 486  :             _Val = _CSTD _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

	lea	eax, DWORD PTR __Errno$4[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Parse_result$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ep$5[ebp]
	push	edx
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 487  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 488  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$5[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$4[ebp], 0
	jne	SHORT $LN5@do_get
	movzx	eax, BYTE PTR __Parse_result$[ebp+1]
	test	eax, eax
	je	SHORT $LN4@do_get
$LN5@do_get:

; 489  :                 _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2
$LN4@do_get:

; 490  :             }
; 491  :         }
; 492  : 
; 493  :         if (_First == _Last) {

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@do_get

; 494  :             _State |= ios_base::eofbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@do_get:

; 495  :         }
; 496  : 
; 497  :         return _First;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 498  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	1
$LN15@do_get:
	DD	4
	DD	$LN14@do_get
$LN14@do_get:
	DD	-56					; ffffffc8H
	DD	32					; 00000020H
	DD	$LN9@do_get
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN10@do_get
	DD	-80					; ffffffb0H
	DD	4
	DD	$LN11@do_get
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN12@do_get
$LN12@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN11@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN10@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN9@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
tv130 = -116						; size = 4
tv131 = -112						; size = 4
$T2 = -108						; size = 8
$T3 = -98						; size = 2
__Errno$4 = -92						; size = 4
__Ep$5 = -80						; size = 4
__Parse_result$ = -68					; size = 2
__Ac$ = -56						; size = 32
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 449  :         long& _Val) const { // get long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 450  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 451  :         char _Ac[_Max_int_dig];
; 452  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 453  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
; 454  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jge	SHORT $LN2@do_get

; 455  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 456  :             _Val   = 0;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [edx], 0

; 457  :         } else {

	jmp	SHORT $LN4@do_get
$LN2@do_get:

; 458  :             char* _Ep;
; 459  :             int _Errno;
; 460  :             _Val = _CSTD _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

	lea	eax, DWORD PTR __Errno$4[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Parse_result$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ep$5[ebp]
	push	edx
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stolx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 461  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 462  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$5[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$4[ebp], 0
	jne	SHORT $LN5@do_get
	movzx	eax, BYTE PTR __Parse_result$[ebp+1]
	test	eax, eax
	je	SHORT $LN4@do_get
$LN5@do_get:

; 463  :                 _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2
$LN4@do_get:

; 464  :             }
; 465  :         }
; 466  : 
; 467  :         if (_First == _Last) {

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@do_get

; 468  :             _State |= ios_base::eofbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@do_get:

; 469  :         }
; 470  : 
; 471  :         return _First;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 472  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	1
$LN15@do_get:
	DD	4
	DD	$LN14@do_get
$LN14@do_get:
	DD	-56					; ffffffc8H
	DD	32					; 00000020H
	DD	$LN9@do_get
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN10@do_get
	DD	-80					; ffffffb0H
	DD	4
	DD	$LN11@do_get
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN12@do_get
$LN12@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN11@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN10@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN9@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 8
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 439  :         unsigned int& _Val) const { // get unsigned int from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 440  :         static_assert(sizeof(unsigned int) == sizeof(unsigned long),
; 441  :             "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
; 442  :         unsigned long _Tmp;
; 443  :         _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); // avoid virtual call for perf

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __First$[ebp], edx
	mov	DWORD PTR __First$[ebp+4], eax

; 444  :         _Val   = _Tmp;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [ecx], edx

; 445  :         return _First;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 446  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	3
$LN5@do_get:
	DD	1
	DD	$LN4@do_get
$LN4@do_get:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN3@do_get
$LN3@do_get:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
_TEXT	SEGMENT
tv85 = -129						; size = 1
tv144 = -128						; size = 4
tv145 = -124						; size = 4
$T2 = -120						; size = 8
$T3 = -110						; size = 2
__Tmp$4 = -108						; size = 4
__Errno$5 = -100					; size = 4
__Ep$6 = -88						; size = 4
__Digits$7 = -80					; size = 4
__Minus$8 = -73						; size = 1
__Parse_result$ = -68					; size = 2
__Ac$ = -56						; size = 32
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 397  :         unsigned short& _Val) const { // get unsigned short from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-132]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 398  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 399  :         char _Ac[_Max_int_dig];
; 400  :         const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv144[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv144[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 401  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
; 402  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

	movsx	eax, BYTE PTR __Parse_result$[ebp]
	test	eax, eax
	jge	SHORT $LN2@do_get

; 403  :             _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 404  :             _Val   = 0;

	xor	edx, edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	WORD PTR [eax], dx

; 405  :         } else {

	jmp	$LN9@do_get
$LN2@do_get:

; 406  :             const bool _Minus   = _Ac[0] == '-';

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR __Ac$[ebp+edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN12@do_get
	mov	BYTE PTR tv85[ebp], 1
	jmp	SHORT $LN13@do_get
$LN12@do_get:
	mov	BYTE PTR tv85[ebp], 0
$LN13@do_get:
	mov	cl, BYTE PTR tv85[ebp]
	mov	BYTE PTR __Minus$8[ebp], cl

; 407  :             const char* _Digits = _Ac;

	lea	edx, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Digits$7[ebp], edx

; 408  :             // C11 7.22.1.4/5: the sequence of characters starting with the first digit
; 409  :             // is interpreted as an integer constant according to the rules of 6.4.4.1
; 410  :             if (_Minus) { // skip over minus to start with the first digit

	movzx	eax, BYTE PTR __Minus$8[ebp]
	test	eax, eax
	je	SHORT $LN4@do_get

; 411  :                 ++_Digits;

	mov	ecx, DWORD PTR __Digits$7[ebp]
	add	ecx, 1
	mov	DWORD PTR __Digits$7[ebp], ecx
$LN4@do_get:

; 412  :             }
; 413  : 
; 414  :             char* _Ep;
; 415  :             int _Errno;
; 416  :             const unsigned long _Tmp = _CSTD _Stoulx(_Digits, &_Ep, _Parse_result._Base, &_Errno); // convert

	lea	edx, DWORD PTR __Errno$5[ebp]
	push	edx
	movsx	eax, BYTE PTR __Parse_result$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$6[ebp]
	push	ecx
	mov	edx, DWORD PTR __Digits$7[ebp]
	push	edx
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Tmp$4[ebp], eax

; 417  :             _Val                     = static_cast<unsigned short>(_Tmp);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	cx, WORD PTR __Tmp$4[ebp]
	mov	WORD PTR [eax], cx

; 418  :             if (_Ep == _Digits || _Errno != 0 || _Tmp > USHRT_MAX) { // N4950 [facet.num.get.virtuals]/3

	mov	edx, DWORD PTR __Ep$6[ebp]
	cmp	edx, DWORD PTR __Digits$7[ebp]
	je	SHORT $LN7@do_get
	cmp	DWORD PTR __Errno$5[ebp], 0
	jne	SHORT $LN7@do_get
	cmp	DWORD PTR __Tmp$4[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN5@do_get
$LN7@do_get:

; 419  :                 _State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 420  :                 _Val   = USHRT_MAX;

	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR __Val$[ebp]
	mov	WORD PTR [edx], cx
	jmp	SHORT $LN8@do_get
$LN5@do_get:

; 421  :             } else if (_Minus) { // C11 7.22.1.4/5:  If the subject sequence begins with a minus sign,

	movzx	eax, BYTE PTR __Minus$8[ebp]
	test	eax, eax
	je	SHORT $LN8@do_get

; 422  :                                  // the value resulting from the conversion is negated (in the return type).
; 423  :                 _Val = static_cast<unsigned short>(0 - _Val);

	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	edx, WORD PTR [ecx]
	xor	eax, eax
	sub	eax, edx
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	WORD PTR [ecx], ax
$LN8@do_get:

; 424  :             }
; 425  : 
; 426  :             if (_Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	movzx	edx, BYTE PTR __Parse_result$[ebp+1]
	test	edx, edx
	je	SHORT $LN9@do_get

; 427  :                 _State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN9@do_get:

; 428  :             }
; 429  :         }
; 430  : 
; 431  :         if (_First == _Last) {

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@do_get

; 432  :             _State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN10@do_get:

; 433  :         }
; 434  : 
; 435  :         return _First;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 436  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 132				; 00000084H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN21@do_get:
	DD	4
	DD	$LN20@do_get
$LN20@do_get:
	DD	-56					; ffffffc8H
	DD	32					; 00000020H
	DD	$LN15@do_get
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN16@do_get
	DD	-88					; ffffffa8H
	DD	4
	DD	$LN17@do_get
	DD	-100					; ffffff9cH
	DD	4
	DD	$LN18@do_get
$LN18@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN17@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN16@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN15@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
_TEXT	SEGMENT
tv167 = -256						; size = 4
tv185 = -252						; size = 4
tv188 = -248						; size = 4
tv138 = -244						; size = 4
tv183 = -240						; size = 4
tv187 = -236						; size = 4
tv181 = -232						; size = 4
tv78 = -228						; size = 4
tv178 = -224						; size = 4
tv186 = -220						; size = 4
$T2 = -216						; size = 8
$T3 = -206						; size = 2
$T4 = -204						; size = 8
__Ans$5 = -196						; size = 4
__Errno$6 = -188					; size = 4
__Ep$7 = -176						; size = 4
__Parse_result$8 = -164					; size = 2
__Ac$9 = -152						; size = 32
$T10 = -116						; size = 28
$T11 = -88						; size = 28
__Str$12 = -56						; size = 28
__Punct_fac$13 = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 343  :         bool& _Val) const { // get bool from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 344  :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 345  :         if (_Iosbase.flags() & ios_base::boolalpha) { // get false name or true name

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 16384				; 00004000H
	je	$LN4@do_get

; 346  :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv186[ebp], eax
	mov	eax, DWORD PTR tv186[ebp]
	mov	DWORD PTR tv178[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv178[ebp]
	push	ecx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 347  :             basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});

	push	0
	push	1
	lea	ecx, DWORD PTR __Str$12[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 348  :             _Str += _Punct_fac.falsename();

	lea	edx, DWORD PTR $T11[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$13[ebp]
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	mov	DWORD PTR tv78[ebp], eax
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv181[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$12[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 349  :             _Str.push_back(_Elem{});

	push	0
	lea	ecx, DWORD PTR __Str$12[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
	npad	1

; 350  :             _Str += _Punct_fac.truename(); // construct "\0false\0true"

	lea	edx, DWORD PTR $T10[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$13[ebp]
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	mov	DWORD PTR tv187[ebp], eax
	mov	eax, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv183[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv183[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$12[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 351  :             switch (_Getloctxt(_First, _Last, 2, _Str.c_str(), _Case_sensitive::_Yes)) {

	push	1
	lea	ecx, DWORD PTR __Str$12[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	push	2
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv138[ebp], eax
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN6@do_get
	cmp	DWORD PTR tv138[ebp], 1
	je	SHORT $LN7@do_get
	jmp	SHORT $LN8@do_get
$LN6@do_get:

; 352  :             case 0:
; 353  :                 _Val = false;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [ecx], 0

; 354  :                 break;

	jmp	SHORT $LN2@do_get
$LN7@do_get:

; 355  :             case 1:
; 356  :                 _Val = true;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [edx], 1

; 357  :                 break;

	jmp	SHORT $LN2@do_get
$LN8@do_get:

; 358  :             default:
; 359  :                 _Val   = false;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [eax], 0

; 360  :                 _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2
$LN2@do_get:

; 361  :                 break;
; 362  :             }
; 363  :         } else { // get long value

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	$LN14@do_get
$LN4@do_get:

; 364  :             char _Ac[_Max_int_dig];
; 365  :             const auto _Parse_result =

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv188[ebp], eax
	mov	eax, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv185[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv185[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$9[ebp]
	push	ecx
	call	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
	add	esp, 20					; 00000014H
	mov	WORD PTR $T3[ebp], ax
	mov	dx, WORD PTR $T3[ebp]
	mov	WORD PTR __Parse_result$8[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 366  :                 _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
; 367  :             if (_Parse_result._Base < 0) {

	movsx	eax, BYTE PTR __Parse_result$8[ebp]
	test	eax, eax
	jge	SHORT $LN9@do_get

; 368  :                 // N4950 [facet.num.get.virtuals]/3.9:
; 369  :                 //  "zero, if the conversion function does not convert the entire field."
; 370  :                 _Val   = false;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [ecx], 0

; 371  :                 _State = ios_base::failbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], 2

; 372  :             } else {

	jmp	$LN14@do_get
$LN9@do_get:

; 373  :                 char* _Ep;
; 374  :                 int _Errno;
; 375  :                 const long _Ans = _CSTD _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

	lea	eax, DWORD PTR __Errno$6[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Parse_result$8[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ep$7[ebp]
	push	edx
	lea	eax, DWORD PTR __Ac$9[ebp]
	push	eax
	call	__Stolx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Ans$5[ebp], eax

; 376  :                 if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 377  :                     || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

	lea	ecx, DWORD PTR __Ac$9[ebp]
	cmp	DWORD PTR __Ep$7[ebp], ecx
	je	SHORT $LN13@do_get
	cmp	DWORD PTR __Errno$6[ebp], 0
	jne	SHORT $LN13@do_get
	movzx	edx, BYTE PTR __Parse_result$8[ebp+1]
	test	edx, edx
	je	SHORT $LN11@do_get
$LN13@do_get:

; 378  :                     _Val   = true;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [eax], 1

; 379  :                     _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 380  :                 } else {

	jmp	SHORT $LN14@do_get
$LN11@do_get:

; 381  :                     _Val = _Ans != 0;

	cmp	DWORD PTR __Ans$5[ebp], 0
	je	SHORT $LN17@do_get
	mov	DWORD PTR tv167[ebp], 1
	jmp	SHORT $LN18@do_get
$LN17@do_get:
	mov	DWORD PTR tv167[ebp], 0
$LN18@do_get:
	mov	edx, DWORD PTR __Val$[ebp]
	mov	al, BYTE PTR tv167[ebp]
	mov	BYTE PTR [edx], al

; 382  :                     if (_Ans != 0 && _Ans != 1) {

	cmp	DWORD PTR __Ans$5[ebp], 0
	je	SHORT $LN14@do_get
	cmp	DWORD PTR __Ans$5[ebp], 1
	je	SHORT $LN14@do_get

; 383  :                         _State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2
$LN14@do_get:

; 384  :                     }
; 385  :                 }
; 386  :             }
; 387  :         }
; 388  : 
; 389  :         if (_First == _Last) {

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@do_get

; 390  :             _State |= ios_base::eofbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], eax
$LN15@do_get:

; 391  :         }
; 392  : 
; 393  :         return _First;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 394  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN31@do_get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN31@do_get:
	DD	5
	DD	$LN30@do_get
$LN30@do_get:
	DD	-56					; ffffffc8H
	DD	28					; 0000001cH
	DD	$LN24@do_get
	DD	-152					; ffffff68H
	DD	32					; 00000020H
	DD	$LN25@do_get
	DD	-164					; ffffff5cH
	DD	2
	DD	$LN26@do_get
	DD	-176					; ffffff50H
	DD	4
	DD	$LN27@do_get
	DD	-188					; ffffff44H
	DD	4
	DD	$LN28@do_get
$LN28@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	0
$LN27@do_get:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	112					; 00000070H
	DB	0
$LN26@do_get:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN25@do_get:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	0
$LN24@do_get:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1:
	lea	ecx, DWORD PTR __Str$12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get, COMDAT
; _this$ = ecx

; 327  :         double& _Val) const { // get double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 328  :         return do_get(_First, _Last, _Iosbase, _State, _Val);

	mov	esi, esp
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 329  :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 279  :     __CLR_OR_THIS_CALL num_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 280  :         _Init(_Lobj);

	mov	edx, DWORD PTR __Lobj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
	npad	1

; 281  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 270  :     void _Init(const _Locinfo&) {} // initialize from _Locinfo object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 268  :     __CLR_OR_THIS_CALL ~num_get() noexcept override {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
tv88 = -88						; size = 4
tv94 = -84						; size = 4
tv129 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 52
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 256  :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 257  :         // return locale category mask and construct standard facet
; 258  :         if (_Ppf && !*_Ppf) {

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN9@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN9@Getcat

; 259  :             *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));

	push	8
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?_C_str@locale@std@@QBEPBDXZ		; std::locale::_C_str
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv88[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 1
	je	SHORT $LN9@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
	npad	1
$LN9@Getcat:

; 260  :         }
; 261  : 
; 262  :         return _X_NUMERIC;

	mov	eax, 4

; 263  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
__Psave_guard$3 = -56					; size = 4
__Pfmod$4 = -48						; size = 4
__Pf$5 = -44						; size = 4
__Id$6 = -40						; size = 4
__Psave$7 = -32						; size = 4
__Lock$8 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$7[ebp], eax

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();

	mov	ecx, OFFSET ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$_Get_index@$0A@@id@locale@std@@QAEIXZ ; std::locale::id::_Get_index<0>
	mov	DWORD PTR __Id$6[ebp], eax

; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$6[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$5[ebp], eax

; 441  : 
; 442  :     if (!_Pf) {

	cmp	DWORD PTR __Pf$5[ebp], 0
	jne	$LN6@use_facet

; 443  :         if (_Psave) {

	cmp	DWORD PTR __Psave$7[ebp], 0
	je	SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], edx
	jmp	SHORT $LN6@use_facet
$LN3@use_facet:

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$7[ebp]
	push	ecx
	call	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 446  : #if _HAS_EXCEPTIONS
; 447  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 448  : #else
; 449  :             _CSTD abort(); // lazy disallowed
; 450  : #endif
; 451  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN6@use_facet
$LN5@use_facet:

; 452  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pfmod$4[ebp], edx

; 453  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	eax, DWORD PTR __Pfmod$4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 454  : 
; 455  : #if defined(_M_CEE)
; 456  :             _Facet_Register_m(_Pfmod);
; 457  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 458  :             _Facet_Register(_Pfmod);

	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	push	ecx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR __Pfmod$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 463  :             _Pf                       = _Psave;

	mov	ecx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], ecx

; 464  : 
; 465  :             (void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 466  :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	npad	1
$LN6@use_facet:

; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	edx, DWORD PTR __Pf$5[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@use_facet
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@use_facet:
	DD	3
	DD	$LN14@use_facet
$LN14@use_facet:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN10@use_facet
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN11@use_facet
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN12@use_facet
$LN12@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN11@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$LN10@use_facet:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$8[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 110  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+4]

; 112  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 108  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Istr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movzx	ecx, BYTE PTR __Noskip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -24						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 93   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 94   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 95   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN2@Sentry_bas

; 96   :                 _Rdbuf->_Unlock();

	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@Sentry_bas:

; 97   :             }
; 98   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
__Rdbuf$ = -8						; size = 4
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 86   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [eax], ecx

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 88   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN2@Sentry_bas

; 89   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@Sentry_bas:

; 90   :             }
; 91   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 69   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 70   : }

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 469  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABQAD@std@@YAABQADABQAD@Z	; std::forward<char * const &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 477  :     }
; 478  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z
_TEXT	SEGMENT
__Fancy_ptr$ = -4					; size = 4
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 823  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 824  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 825  :         ++_Capacity; // Take null terminator into consideration

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR [edx], ecx

; 826  : 
; 827  :         pointer _Fancy_ptr = nullptr;

	mov	DWORD PTR __Fancy_ptr$[ebp], 0

; 828  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 829  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	add	esp, 8
	mov	DWORD PTR __Fancy_ptr$[ebp], eax

; 830  :         } else {
; 831  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 832  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 833  :         }
; 834  : 
; 835  : #if _HAS_CXX20
; 836  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 837  :         // but likely more impactful to throughput.
; 838  :         if (_STD is_constant_evaluated()) {
; 839  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 840  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 841  :                 _STD construct_at(_Ptr + _Idx);
; 842  :             }
; 843  :         }
; 844  : #endif // _HAS_CXX20
; 845  :         --_Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR [ecx], eax

; 846  :         return _Fancy_ptr;

	mov	eax, DWORD PTR __Fancy_ptr$[ebp]

; 847  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1501 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1503 : }

	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 469  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
	add	esp, 4
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
	npad	1

; 477  :     }
; 478  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 69   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 70   : }

	pop	ebp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1495 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1496 :         if (_Ptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Container_

; 1497 :             _Delete_plain_internal(_Al, _Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8
$LN2@Container_:

; 1498 :         }
; 1499 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1481 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1482 :         // create a new _Container_proxy pointing at _Mycont
; 1483 :         _Ptr = _Unfancy(_Al_.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al_$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 1484 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

	mov	eax, DWORD PTR __Mycont$[ebp]
	push	eax
	call	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1485 :         _Mycont._Myproxy = _Ptr;

	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1486 :     }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1135 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp

; 1136 :     // deallocate a plain pointer using an allocator
; 1137 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1138 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1139 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	add	esp, 12					; 0000000cH

; 1140 :     } else {
; 1141 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1142 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1143 :     }
; 1144 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	push	eax
	call	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z
_TEXT	SEGMENT
tv185 = -88						; size = 4
tv182 = -84						; size = 4
tv65 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 8
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 8
__Ok$ = -44						; size = 8
__Err$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<double>, COMDAT
; _this$ = ecx

; 207  :     basic_istream& _Common_extract_with_num_get(_Ty& _Val) { // formatted extract with num_get

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 208  :         ios_base::iostate _Err = ios_base::goodbit;

	mov	DWORD PTR __Err$[ebp], 0

; 209  :         const sentry _Ok(*this);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 210  : 
; 211  :         if (_Ok) { // state okay, use facet to extract

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@Common_ext

; 212  :             _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv182[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv182[ebp]
	push	ecx
	call	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	DWORD PTR tv185[ebp], eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR __Err$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	call	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR tv185[ebp]
	call	?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
	npad	1
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1
	jmp	SHORT $LN5@Common_ext
__catch$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$0:

; 214  :             _CATCH_IO_END

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	mov	eax, $LN10@Common_ext
	ret	0
$LN5@Common_ext:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN9@Common_ext
$LN10@Common_ext:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN9@Common_ext:

; 215  :         }
; 216  : 
; 217  :         _Myios::setstate(_Err);

	push	0
	mov	eax, DWORD PTR __Err$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1

; 218  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 219  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@Common_ext
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN15@Common_ext:
	DD	2
	DD	$LN14@Common_ext
$LN14@Common_ext:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN11@Common_ext
	DD	-44					; ffffffd4H
	DD	8
	DD	$LN12@Common_ext
$LN12@Common_ext:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
$LN11@Common_ext:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z$3:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<double>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 545  :     _NODISCARD bool failed() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 546  :         return _Failed;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax]

; 547  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 537  :     ostreambuf_iterator& operator++() noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 538  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 539  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 533  :     _NODISCARD ostreambuf_iterator& operator*() noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 534  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 535  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 525  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 526  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@operator
	movzx	ecx, BYTE PTR __Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	push	eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator
$LN3@operator:

; 527  :             _Failed = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx], 1
$LN2@operator:

; 528  :         }
; 529  : 
; 530  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 531  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 521  :     ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 
; 523  :     ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}
; 524  : 
; 525  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment
; 526  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
; 527  :             _Failed = true;
; 528  :         }
; 529  : 
; 530  :         return *this;
; 531  :     }
; 532  : 
; 533  :     _NODISCARD ostreambuf_iterator& operator*() noexcept /* strengthened */ {
; 534  :         return *this;
; 535  :     }
; 536  : 
; 537  :     ostreambuf_iterator& operator++() noexcept /* strengthened */ {
; 538  :         return *this;
; 539  :     }
; 540  : 
; 541  :     ostreambuf_iterator& operator++(int) noexcept /* strengthened */ {
; 542  :         return *this;
; 543  :     }
; 544  : 
; 545  :     _NODISCARD bool failed() const noexcept {
; 546  :         return _Failed;
; 547  :     }
; 548  : 
; 549  : private:
; 550  :     bool _Failed = false; // true if any stores have failed

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 521  :     ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Sb$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN4@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN4@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN4@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1631 :     _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest

	push	ebp
	mov	ebp, esp

; 1632 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

	jmp	SHORT $LN4@Rep
$LN2@Rep:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
	npad	1
$LN4@Rep:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@Rep

; 1633 :             *_Dest = _Ch;

	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	ecx, eax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
	npad	1

; 1634 :         }

	jmp	SHORT $LN2@Rep
$LN3@Rep:

; 1635 : 
; 1636 :         return _Dest;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1637 :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1623 :         _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest

	push	ebp
	mov	ebp, esp

; 1624 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

	jmp	SHORT $LN4@Put
$LN2@Put:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN4@Put:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@Put

; 1625 :             *_Dest = *_Ptr;

	mov	edx, DWORD PTR __Ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	ecx, eax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
	npad	1

; 1626 :         }

	jmp	SHORT $LN2@Put
$LN3@Put:

; 1627 : 
; 1628 :         return _Dest;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1629 :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
tv318 = -208						; size = 8
tv266 = -200						; size = 4
tv131 = -196						; size = 4
tv263 = -192						; size = 4
tv270 = -188						; size = 4
tv69 = -184						; size = 4
$T2 = -180						; size = 8
$T3 = -172						; size = 8
$T4 = -164						; size = 8
$T5 = -156						; size = 8
$T6 = -148						; size = 8
$T7 = -140						; size = 8
$T8 = -132						; size = 8
$T9 = -124						; size = 8
__Adjustfield$ = -116					; size = 4
__Fillcount$ = -112					; size = 4
__Kseparator$10 = -105					; size = 1
__Pg$ = -104						; size = 4
__Grouping$ = -96					; size = 28
__Punct_fac$ = -64					; size = 4
__Groupstring$ = -56					; size = 28
__Ctype_fac$ = -24					; size = 4
__Prefix$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1569 :         size_t _Count) const { // put formatted integer to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1570 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN17@Iput
	mov	eax, DWORD PTR __Buf$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN16@Iput
	mov	edx, DWORD PTR __Buf$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN17@Iput
$LN16@Iput:
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN18@Iput
$LN17@Iput:
	mov	DWORD PTR tv69[ebp], 0
$LN18@Iput:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR __Prefix$[ebp], ecx

; 1571 :         if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1572 :             && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 3584				; 00000e00H
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN4@Iput
	mov	edx, DWORD PTR __Prefix$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN4@Iput
	mov	eax, DWORD PTR __Buf$[ebp]
	add	eax, DWORD PTR __Prefix$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN4@Iput
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Prefix$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN5@Iput
	mov	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, DWORD PTR __Prefix$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 88					; 00000058H
	jne	SHORT $LN4@Iput
$LN5@Iput:

; 1573 :             _Prefix += 2;

	mov	eax, DWORD PTR __Prefix$[ebp]
	add	eax, 2
	mov	DWORD PTR __Prefix$[ebp], eax
$LN4@Iput:

; 1574 :         }
; 1575 : 
; 1576 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv270[ebp], eax
	mov	edx, DWORD PTR tv270[ebp]
	mov	DWORD PTR tv263[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv263[ebp]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 1577 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1578 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen
	npad	1

; 1579 : 
; 1580 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	edx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv266[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv266[ebp]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 1581 :         const string _Grouping = _Punct_fac.grouping();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1582 :         const char* _Pg        = &_Grouping[0];

	push	0
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Pg$[ebp], eax

; 1583 :         if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators

	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	je	SHORT $LN3@Iput
	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jle	SHORT $LN3@Iput

; 1584 :             const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR __Kseparator$10[ebp], al
$LN2@Iput:

; 1585 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {

	mov	eax, DWORD PTR __Pg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	je	SHORT $LN3@Iput
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jle	SHORT $LN3@Iput
	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Prefix$[ebp]
	cmp	edx, eax
	jae	SHORT $LN3@Iput

; 1586 :                 // insert thousands separator
; 1587 :                 _Count -= *_Pg;

	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 1588 :                 _Groupstring.insert(_Count, 1, _Kseparator);

	movzx	ecx, BYTE PTR __Kseparator$10[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	npad	1

; 1589 :                 if ('\0' < _Pg[1]) {

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jle	SHORT $LN7@Iput

; 1590 :                     ++_Pg; // not last group, advance

	mov	eax, DWORD PTR __Pg$[ebp]
	add	eax, 1
	mov	DWORD PTR __Pg$[ebp], eax
$LN7@Iput:

; 1591 :                 }
; 1592 :             }

	jmp	SHORT $LN2@Iput
$LN3@Iput:

; 1593 :         }
; 1594 : 
; 1595 :         _Count = _Groupstring.size();

	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Count$[ebp], eax

; 1596 : 
; 1597 :         size_t _Fillcount;
; 1598 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv318[ebp], eax
	mov	DWORD PTR tv318[ebp+4], edx
	cmp	DWORD PTR tv318[ebp+4], 0
	jl	SHORT $LN10@Iput
	jg	SHORT $LN23@Iput
	cmp	DWORD PTR tv318[ebp], 0
	jbe	SHORT $LN10@Iput
$LN23@Iput:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN8@Iput
$LN10@Iput:

; 1599 :             _Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1600 :         } else {

	jmp	SHORT $LN9@Iput
$LN8@Iput:

; 1601 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Fillcount$[ebp], eax
$LN9@Iput:

; 1602 :         }
; 1603 : 
; 1604 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR __Adjustfield$[ebp], eax

; 1605 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	cmp	DWORD PTR __Adjustfield$[ebp], 64	; 00000040H
	je	SHORT $LN11@Iput
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	je	SHORT $LN11@Iput

; 1606 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	mov	ecx, DWORD PTR __Fillcount$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1607 :             _Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1608 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
	jmp	$LN14@Iput
$LN11@Iput:

; 1609 :         } else if (_Adjustfield == ios_base::internal) { // put internal fill

	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	jne	SHORT $LN13@Iput

; 1610 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1611 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1612 :             _Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1613 :         } else {

	jmp	SHORT $LN14@Iput
$LN13@Iput:

; 1614 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
$LN14@Iput:

; 1615 :         }
; 1616 : 
; 1617 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Prefix$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1618 :         _Iosbase.width(0);

	push	0
	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width

; 1619 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1620 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@Iput
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN28@Iput:
	DD	2
	DD	$LN27@Iput
$LN27@Iput:
	DD	-56					; ffffffc8H
	DD	28					; 0000001cH
	DD	$LN24@Iput
	DD	-96					; ffffffa0H
	DD	28					; 0000001cH
	DD	$LN25@Iput
$LN25@Iput:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN24@Iput:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
tv89 = -11						; size = 1
tv90 = -10						; size = 1
tv91 = -9						; size = 1
__Basefield$ = -8					; size = 4
__Ptr$ = -4						; size = 4
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1539 :         char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1540 :         char* _Ptr = _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 1541 :         *_Ptr++    = '%';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1542 : 
; 1543 :         if (_Flags & ios_base::showpos) {

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@Ifmt

; 1544 :             *_Ptr++ = '+';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 43			; 0000002bH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN2@Ifmt:

; 1545 :         }
; 1546 : 
; 1547 :         if (_Flags & ios_base::showbase) {

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 8
	je	SHORT $LN3@Ifmt

; 1548 :             *_Ptr++ = '#';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN3@Ifmt:

; 1549 :         }
; 1550 : 
; 1551 :         if (_Spec[0] != 'L') {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR __Spec$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN4@Ifmt

; 1552 :             *_Ptr++ = _Spec[0]; // qualifier

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Spec$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1553 :         } else { // change L to I64

	jmp	SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1554 :             *_Ptr++ = 'I';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 73			; 00000049H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1555 :             *_Ptr++ = '6';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 54			; 00000036H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1556 :             *_Ptr++ = '4';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 52			; 00000034H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax
$LN5@Ifmt:

; 1557 :         }
; 1558 : 
; 1559 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	ecx, DWORD PTR __Flags$[ebp]
	and	ecx, 3584				; 00000e00H
	mov	DWORD PTR __Basefield$[ebp], ecx

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

	cmp	DWORD PTR __Basefield$[ebp], 1024	; 00000400H
	jne	SHORT $LN11@Ifmt
	mov	BYTE PTR tv91[ebp], 111			; 0000006fH
	jmp	SHORT $LN12@Ifmt
$LN11@Ifmt:
	cmp	DWORD PTR __Basefield$[ebp], 2048	; 00000800H
	je	SHORT $LN9@Ifmt
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR __Spec$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR tv90[ebp], cl
	jmp	SHORT $LN10@Ifmt
$LN9@Ifmt:
	mov	edx, DWORD PTR __Flags$[ebp]
	and	edx, 4
	je	SHORT $LN7@Ifmt
	mov	BYTE PTR tv89[ebp], 88			; 00000058H
	jmp	SHORT $LN8@Ifmt
$LN7@Ifmt:
	mov	BYTE PTR tv89[ebp], 120			; 00000078H
$LN8@Ifmt:
	mov	al, BYTE PTR tv89[ebp]
	mov	BYTE PTR tv90[ebp], al
$LN10@Ifmt:
	mov	cl, BYTE PTR tv90[ebp]
	mov	BYTE PTR tv91[ebp], cl
$LN12@Ifmt:
	mov	edx, DWORD PTR __Ptr$[ebp]
	movzx	eax, BYTE PTR tv91[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1561 :                                       : _Basefield != ios_base::hex  ? _Spec[1] // 'd' or 'u'
; 1562 :                                       : _Flags & ios_base::uppercase ? 'X'
; 1563 :                                                                      : 'x';
; 1564 :         *_Ptr                         = '\0';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 0

; 1565 :         return _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]

; 1566 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
__Ffl$ = -12						; size = 4
__Ch$ = -5						; size = 1
__Ptr$ = -4						; size = 4
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1416 :         char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for floating-point

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1417 :         char* _Ptr = _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 1418 :         *_Ptr++    = '%';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1419 : 
; 1420 :         if (_Flags & ios_base::showpos) {

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@Ffmt

; 1421 :             *_Ptr++ = '+';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 43			; 0000002bH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN2@Ffmt:

; 1422 :         }
; 1423 : 
; 1424 :         if (_Flags & ios_base::showpoint) {

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN3@Ffmt

; 1425 :             *_Ptr++ = '#';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN3@Ffmt:

; 1426 :         }
; 1427 : 
; 1428 :         *_Ptr++ = '.';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1429 :         *_Ptr++ = '*'; // for precision argument

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 42			; 0000002aH
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1430 :         if (_Spec != '\0') {

	movsx	ecx, BYTE PTR __Spec$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@Ffmt

; 1431 :             *_Ptr++ = _Spec; // 'L' qualifier for long double only

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR __Spec$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN4@Ffmt:

; 1432 :         }
; 1433 : 
; 1434 :         char _Ch; // specifier
; 1435 :         ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	edx, DWORD PTR __Flags$[ebp]
	and	edx, 12288				; 00003000H
	mov	DWORD PTR __Ffl$[ebp], edx

; 1436 :         if (_Flags & ios_base::uppercase) {

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 4
	je	SHORT $LN5@Ffmt

; 1437 :             if (_Ffl == ios_base::fixed) {

	cmp	DWORD PTR __Ffl$[ebp], 8192		; 00002000H
	jne	SHORT $LN7@Ffmt

; 1438 :                 _Ch = 'F';

	mov	BYTE PTR __Ch$[ebp], 70			; 00000046H
	jmp	SHORT $LN12@Ffmt
$LN7@Ffmt:

; 1439 :             } else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {

	cmp	DWORD PTR __Ffl$[ebp], 12288		; 00003000H
	jne	SHORT $LN9@Ffmt

; 1440 :                 _Ch = 'A';

	mov	BYTE PTR __Ch$[ebp], 65			; 00000041H
	jmp	SHORT $LN12@Ffmt
$LN9@Ffmt:

; 1441 :             } else if (_Ffl == ios_base::scientific) {

	cmp	DWORD PTR __Ffl$[ebp], 4096		; 00001000H
	jne	SHORT $LN11@Ffmt

; 1442 :                 _Ch = 'E';

	mov	BYTE PTR __Ch$[ebp], 69			; 00000045H

; 1443 :             } else {

	jmp	SHORT $LN12@Ffmt
$LN11@Ffmt:

; 1444 :                 _Ch = 'G';

	mov	BYTE PTR __Ch$[ebp], 71			; 00000047H
$LN12@Ffmt:

; 1445 :             }
; 1446 :         } else {

	jmp	SHORT $LN18@Ffmt
$LN5@Ffmt:

; 1447 :             if (_Ffl == ios_base::fixed) {

	cmp	DWORD PTR __Ffl$[ebp], 8192		; 00002000H
	jne	SHORT $LN13@Ffmt

; 1448 :                 _Ch = 'f';

	mov	BYTE PTR __Ch$[ebp], 102		; 00000066H
	jmp	SHORT $LN18@Ffmt
$LN13@Ffmt:

; 1449 :             } else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {

	cmp	DWORD PTR __Ffl$[ebp], 12288		; 00003000H
	jne	SHORT $LN15@Ffmt

; 1450 :                 _Ch = 'a';

	mov	BYTE PTR __Ch$[ebp], 97			; 00000061H
	jmp	SHORT $LN18@Ffmt
$LN15@Ffmt:

; 1451 :             } else if (_Ffl == ios_base::scientific) {

	cmp	DWORD PTR __Ffl$[ebp], 4096		; 00001000H
	jne	SHORT $LN17@Ffmt

; 1452 :                 _Ch = 'e';

	mov	BYTE PTR __Ch$[ebp], 101		; 00000065H

; 1453 :             } else {

	jmp	SHORT $LN18@Ffmt
$LN17@Ffmt:

; 1454 :                 _Ch = 'g';

	mov	BYTE PTR __Ch$[ebp], 103		; 00000067H
$LN18@Ffmt:

; 1455 :             }
; 1456 :         }
; 1457 :         *_Ptr++ = _Ch;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	dl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1458 : 
; 1459 :         *_Ptr = '\0';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 0

; 1460 :         return _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]

; 1461 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1407 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1408 :         char _Buf[2 * _Max_int_dig];
; 1409 : 
; 1410 :         return _Iput(

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp@
	push	64					; 00000040H
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1411 :             _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
; 1412 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN5@do_put:
	DD	1
	DD	$LN4@do_put
$LN4@do_put:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$LN3@do_put
$LN3@do_put:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
tv139 = -144						; size = 4
tv196 = -140						; size = 8
tv78 = -132						; size = 8
tv73 = -122						; size = 1
tv71 = -121						; size = 1
__Ngen$ = -120						; size = 4
__Adjusted_flags$ = -116				; size = 4
__Is_finite$ = -109					; size = 1
__Ptwo$2 = -104						; size = 4
__Bufsize$ = -96					; size = 4
__Desired_precision$ = -92				; size = 4
__Precision$ = -88					; size = 8
__Is_hex$ = -78						; size = 1
__Is_fixed$ = -77					; size = 1
__Float_flags$ = -76					; size = 4
__Fmt$ = -68						; size = 8
__Buf$ = -52						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1379 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-144]
	mov	ecx, 33					; 00000021H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1380 :         string _Buf;

	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1381 :         char _Fmt[8];
; 1382 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Float_flags$[ebp], eax

; 1383 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;

	cmp	DWORD PTR __Float_flags$[ebp], 8192	; 00002000H
	jne	SHORT $LN4@do_put
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $LN5@do_put
$LN4@do_put:
	mov	BYTE PTR tv71[ebp], 0
$LN5@do_put:
	mov	al, BYTE PTR tv71[ebp]
	mov	BYTE PTR __Is_fixed$[ebp], al

; 1384 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR __Float_flags$[ebp], 12288	; 00003000H
	jne	SHORT $LN6@do_put
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN7@do_put
$LN6@do_put:
	mov	BYTE PTR tv73[ebp], 0
$LN7@do_put:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR __Is_hex$[ebp], cl

; 1385 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

	movzx	edx, BYTE PTR __Is_hex$[ebp]
	test	edx, edx
	je	SHORT $LN8@do_put
	or	eax, -1
	mov	DWORD PTR tv78[ebp], -1
	mov	DWORD PTR tv78[ebp+4], eax
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBE_JXZ	; std::ios_base::precision
	mov	DWORD PTR tv78[ebp], eax
	mov	DWORD PTR tv78[ebp+4], edx
$LN9@do_put:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	edx, DWORD PTR tv78[ebp+4]
	mov	DWORD PTR __Precision$[ebp], ecx
	mov	DWORD PTR __Precision$[ebp+4], edx

; 1386 :         const int _Desired_precision =

	mov	eax, DWORD PTR __Float_flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Precision$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Precision$[ebp]
	push	edx
	call	??$_Float_put_desired_precision@O@std@@YAH_JH@Z ; std::_Float_put_desired_precision<long double>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Desired_precision$[ebp], eax

; 1387 :             _Float_put_desired_precision<long double>(_Precision, _Float_flags); // desired precision
; 1388 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

	mov	eax, DWORD PTR __Desired_precision$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], eax

; 1389 :         if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

	movzx	ecx, BYTE PTR __Is_fixed$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@do_put
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabsl
	add	esp, 8
	fstp	QWORD PTR tv196[ebp]
	movsd	xmm0, QWORD PTR tv196[ebp]
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1390 :             int _Ptwo;
; 1391 :             (void) _CSTD frexpl(_Val, &_Ptwo);

	lea	edx, DWORD PTR __Ptwo$2[ebp]
	push	edx
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_frexpl
	fstp	ST(0)
	add	esp, 12					; 0000000cH

; 1392 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$2[ebp]
	push	eax
	call	_abs
	add	esp, 4
	imul	eax, eax, 30103
	cdq
	mov	ecx, 100000				; 000186a0H
	idiv	ecx
	add	eax, DWORD PTR __Bufsize$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], eax
$LN2@do_put:

; 1393 :         }
; 1394 : 
; 1395 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	push	0
	mov	edx, DWORD PTR __Bufsize$[ebp]
	add	edx, 50					; 00000032H
	push	edx
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1396 :         const bool _Is_finite      = (_STD isfinite)(_Val);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	??$isfinite@O@@YA_NO@Z			; isfinite<long double>
	add	esp, 8
	mov	BYTE PTR __Is_finite$[ebp], al

; 1397 :         const auto _Adjusted_flags = // TRANSITION, DevCom-10519861

	movzx	eax, BYTE PTR __Is_finite$[ebp]
	test	eax, eax
	je	SHORT $LN10@do_put
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN11@do_put
$LN10@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, -17				; ffffffefH
	mov	DWORD PTR tv139[ebp], eax
$LN11@do_put:
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR __Adjusted_flags$[ebp], ecx

; 1398 :             _Is_finite ? _Iosbase.flags() : _Iosbase.flags() & ~ios_base::showpoint;
; 1399 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR __Precision$[ebp]
	push	edx
	mov	eax, DWORD PTR __Adjusted_flags$[ebp]
	push	eax
	push	76					; 0000004cH
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	push	0
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	call	_sprintf_s
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Ngen$[ebp], eax

; 1400 :             &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Adjusted_flags), static_cast<int>(_Precision), _Val));
; 1401 : 
; 1402 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

	movzx	eax, BYTE PTR __Is_finite$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ngen$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1403 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 144				; 00000090H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN18@do_put:
	DD	3
	DD	$LN17@do_put
$LN17@do_put:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$LN13@do_put
	DD	-68					; ffffffbcH
	DD	8
	DD	$LN14@do_put
	DD	-104					; ffffff98H
	DD	4
	DD	$LN15@do_put
$LN15@do_put:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	0
$LN14@do_put:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$LN13@do_put:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0:
	lea	ecx, DWORD PTR __Buf$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
tv139 = -144						; size = 4
tv196 = -140						; size = 8
tv78 = -132						; size = 8
tv73 = -122						; size = 1
tv71 = -121						; size = 1
__Ngen$ = -120						; size = 4
__Adjusted_flags$ = -116				; size = 4
__Is_finite$ = -109					; size = 1
__Ptwo$2 = -104						; size = 4
__Bufsize$ = -96					; size = 4
__Desired_precision$ = -92				; size = 4
__Precision$ = -88					; size = 8
__Is_hex$ = -78						; size = 1
__Is_fixed$ = -77					; size = 1
__Float_flags$ = -76					; size = 4
__Fmt$ = -68						; size = 8
__Buf$ = -52						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1352 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-144]
	mov	ecx, 33					; 00000021H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1353 :         string _Buf;

	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1354 :         char _Fmt[8];
; 1355 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Float_flags$[ebp], eax

; 1356 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;

	cmp	DWORD PTR __Float_flags$[ebp], 8192	; 00002000H
	jne	SHORT $LN4@do_put
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $LN5@do_put
$LN4@do_put:
	mov	BYTE PTR tv71[ebp], 0
$LN5@do_put:
	mov	al, BYTE PTR tv71[ebp]
	mov	BYTE PTR __Is_fixed$[ebp], al

; 1357 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR __Float_flags$[ebp], 12288	; 00003000H
	jne	SHORT $LN6@do_put
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN7@do_put
$LN6@do_put:
	mov	BYTE PTR tv73[ebp], 0
$LN7@do_put:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR __Is_hex$[ebp], cl

; 1358 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

	movzx	edx, BYTE PTR __Is_hex$[ebp]
	test	edx, edx
	je	SHORT $LN8@do_put
	or	eax, -1
	mov	DWORD PTR tv78[ebp], -1
	mov	DWORD PTR tv78[ebp+4], eax
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBE_JXZ	; std::ios_base::precision
	mov	DWORD PTR tv78[ebp], eax
	mov	DWORD PTR tv78[ebp+4], edx
$LN9@do_put:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	edx, DWORD PTR tv78[ebp+4]
	mov	DWORD PTR __Precision$[ebp], ecx
	mov	DWORD PTR __Precision$[ebp+4], edx

; 1359 :         const int _Desired_precision =

	mov	eax, DWORD PTR __Float_flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Precision$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Precision$[ebp]
	push	edx
	call	??$_Float_put_desired_precision@N@std@@YAH_JH@Z ; std::_Float_put_desired_precision<double>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Desired_precision$[ebp], eax

; 1360 :             _Float_put_desired_precision<double>(_Precision, _Float_flags); // desired precision
; 1361 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

	mov	eax, DWORD PTR __Desired_precision$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], eax

; 1362 :         if (_Is_fixed && 1e10 < _CSTD fabs(_Val)) { // f or F format

	movzx	ecx, BYTE PTR __Is_fixed$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@do_put
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv196[ebp]
	movsd	xmm0, QWORD PTR tv196[ebp]
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1363 :             int _Ptwo;
; 1364 :             (void) _CSTD frexp(_Val, &_Ptwo);

	lea	edx, DWORD PTR __Ptwo$2[ebp]
	push	edx
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_frexp
	fstp	ST(0)
	add	esp, 12					; 0000000cH

; 1365 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$2[ebp]
	push	eax
	call	_abs
	add	esp, 4
	imul	eax, eax, 30103
	cdq
	mov	ecx, 100000				; 000186a0H
	idiv	ecx
	add	eax, DWORD PTR __Bufsize$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], eax
$LN2@do_put:

; 1366 :         }
; 1367 : 
; 1368 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	push	0
	mov	edx, DWORD PTR __Bufsize$[ebp]
	add	edx, 50					; 00000032H
	push	edx
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1369 :         const bool _Is_finite      = (_STD isfinite)(_Val);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	??$isfinite@N@@YA_NN@Z			; isfinite<double>
	add	esp, 8
	mov	BYTE PTR __Is_finite$[ebp], al

; 1370 :         const auto _Adjusted_flags = // TRANSITION, DevCom-10519861

	movzx	eax, BYTE PTR __Is_finite$[ebp]
	test	eax, eax
	je	SHORT $LN10@do_put
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN11@do_put
$LN10@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, -17				; ffffffefH
	mov	DWORD PTR tv139[ebp], eax
$LN11@do_put:
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR __Adjusted_flags$[ebp], ecx

; 1371 :             _Is_finite ? _Iosbase.flags() : _Iosbase.flags() & ~ios_base::showpoint;
; 1372 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR __Precision$[ebp]
	push	edx
	mov	eax, DWORD PTR __Adjusted_flags$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	push	0
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	call	_sprintf_s
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Ngen$[ebp], eax

; 1373 :             &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Adjusted_flags), static_cast<int>(_Precision), _Val));
; 1374 : 
; 1375 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

	movzx	eax, BYTE PTR __Is_finite$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ngen$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1376 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 144				; 00000090H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN18@do_put:
	DD	3
	DD	$LN17@do_put
$LN17@do_put:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$LN13@do_put
	DD	-68					; ffffffbcH
	DD	8
	DD	$LN14@do_put
	DD	-104					; ffffff98H
	DD	4
	DD	$LN15@do_put
$LN15@do_put:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	0
$LN14@do_put:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$LN13@do_put:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0:
	lea	ecx, DWORD PTR __Buf$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 8
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1343 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1344 :         char _Buf[2 * _Max_int_dig];
; 1345 :         char _Fmt[8];
; 1346 : 
; 1347 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02CLHGNPPK@Lu@
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf_s
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1348 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
; 1349 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	1
$LN6@do_put:
	DD	2
	DD	$LN5@do_put
$LN5@do_put:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$LN3@do_put
	DD	-92					; ffffffa4H
	DD	8
	DD	$LN4@do_put
$LN4@do_put:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$LN3@do_put:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 8
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1334 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1335 :         char _Buf[2 * _Max_int_dig];
; 1336 :         char _Fmt[8];
; 1337 : 
; 1338 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02HIKPPMOK@Ld@
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf_s
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1339 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
; 1340 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	1
$LN6@do_put:
	DD	2
	DD	$LN5@do_put
$LN5@do_put:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$LN3@do_put
	DD	-92					; ffffffa4H
	DD	8
	DD	$LN4@do_put
$LN4@do_put:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$LN3@do_put:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 6
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1325 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1326 :         char _Buf[2 * _Max_int_dig];
; 1327 :         char _Fmt[6];
; 1328 : 
; 1329 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02BDDLJJBK@lu@
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1330 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
; 1331 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN6@do_put:
	DD	2
	DD	$LN5@do_put
$LN5@do_put:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$LN3@do_put
	DD	-92					; ffffffa4H
	DD	6
	DD	$LN4@do_put
$LN4@do_put:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$LN3@do_put:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 6
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1316 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1317 :         char _Buf[2 * _Max_int_dig];
; 1318 :         char _Fmt[6];
; 1319 : 
; 1320 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02EAOCLKAK@ld@
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1321 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
; 1322 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN6@do_put:
	DD	2
	DD	$LN5@do_put
$LN5@do_put:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$LN3@do_put
	DD	-92					; ffffffa4H
	DD	6
	DD	$LN4@do_put
$LN4@do_put:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$LN3@do_put:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
tv221 = -168						; size = 8
tv185 = -160						; size = 4
tv183 = -156						; size = 4
tv180 = -152						; size = 4
tv187 = -148						; size = 4
$T2 = -144						; size = 8
$T3 = -136						; size = 8
$T4 = -128						; size = 8
__Fillcount$5 = -120					; size = 4
$T6 = -116						; size = 28
$T7 = -88						; size = 28
__Str$8 = -56						; size = 28
__Punct_fac$9 = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1284 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-168]
	mov	ecx, 39					; 00000027H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1285 :         if (!(_Iosbase.flags() & ios_base::boolalpha)) {

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 16384				; 00004000H
	jne	SHORT $LN2@do_put

; 1286 :             return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));

	movzx	eax, BYTE PTR __Val$[ebp]
	mov	esi, esp
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN3@do_put

; 1287 :         } else { // put "false" or "true"

	jmp	$LN3@do_put
$LN2@do_put:

; 1288 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv187[ebp], eax
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv180[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv180[ebp]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 1289 :             basic_string<_Elem> _Str;

	lea	ecx, DWORD PTR __Str$8[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1290 :             if (_Val) {

	movzx	ecx, BYTE PTR __Val$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@do_put

; 1291 :                 _Str.assign(_Punct_fac.truename());

	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$9[ebp]
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	mov	DWORD PTR tv183[ebp], eax
	mov	eax, DWORD PTR tv183[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$8[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1292 :             } else {

	jmp	SHORT $LN5@do_put
$LN4@do_put:

; 1293 :                 _Str.assign(_Punct_fac.falsename());

	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$9[ebp]
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	mov	DWORD PTR tv185[ebp], eax
	mov	edx, DWORD PTR tv185[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$8[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@do_put:

; 1294 :             }
; 1295 : 
; 1296 :             size_t _Fillcount;
; 1297 :             if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv221[ebp], eax
	mov	DWORD PTR tv221[ebp+4], edx
	cmp	DWORD PTR tv221[ebp+4], 0
	jl	SHORT $LN8@do_put
	jg	SHORT $LN15@do_put
	cmp	DWORD PTR tv221[ebp], 0
	jbe	SHORT $LN8@do_put
$LN15@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$8[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	esi, eax
	ja	SHORT $LN6@do_put
$LN8@do_put:

; 1298 :                 _Fillcount = 0;

	mov	DWORD PTR __Fillcount$5[ebp], 0

; 1299 :             } else {

	jmp	SHORT $LN7@do_put
$LN6@do_put:

; 1300 :                 _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$8[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	esi, eax
	mov	DWORD PTR __Fillcount$5[ebp], esi
$LN7@do_put:

; 1301 :             }
; 1302 : 
; 1303 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN9@do_put

; 1304 :                 _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$5[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1305 :                 _Fillcount = 0;

	mov	DWORD PTR __Fillcount$5[ebp], 0
$LN9@do_put:

; 1306 :             }
; 1307 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

	lea	ecx, DWORD PTR __Str$8[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	lea	ecx, DWORD PTR __Str$8[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1308 :             _Iosbase.width(0);

	push	0
	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width

; 1309 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	mov	eax, DWORD PTR __Fillcount$5[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@do_put:

; 1310 :         }
; 1311 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@do_put
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 168				; 000000a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN19@do_put:
	DD	1
	DD	$LN18@do_put
$LN18@do_put:
	DD	-56					; ffffffc8H
	DD	28					; 0000001cH
	DD	$LN16@do_put
$LN16@do_put:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
	lea	ecx, DWORD PTR __Str$8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-168]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1268 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1269 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

	mov	esi, esp
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1270 :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1235 :     __CLR_OR_THIS_CALL num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1236 :         _Init(_Lobj);

	mov	edx, DWORD PTR __Lobj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
	npad	1

; 1237 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1226 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo&) {} // initialize from _Locinfo object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1224 :     __CLR_OR_THIS_CALL ~num_put() noexcept override {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
tv88 = -88						; size = 4
tv94 = -84						; size = 4
tv129 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 52
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1212 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 1213 :         // return locale category mask and construct standard facet
; 1214 :         if (_Ppf && !*_Ppf) {

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN9@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN9@Getcat

; 1215 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));

	push	8
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?_C_str@locale@std@@QBEPBDXZ		; std::locale::_C_str
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv88[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 1
	je	SHORT $LN9@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
	npad	1
$LN9@Getcat:

; 1216 :         }
; 1217 : 
; 1218 :         return _X_NUMERIC;

	mov	eax, 4

; 1219 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
__Psave_guard$3 = -56					; size = 4
__Pfmod$4 = -48						; size = 4
__Pf$5 = -44						; size = 4
__Id$6 = -40						; size = 4
__Psave$7 = -32						; size = 4
__Lock$8 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$7[ebp], eax

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();

	mov	ecx, OFFSET ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$_Get_index@$0A@@id@locale@std@@QAEIXZ ; std::locale::id::_Get_index<0>
	mov	DWORD PTR __Id$6[ebp], eax

; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$6[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$5[ebp], eax

; 441  : 
; 442  :     if (!_Pf) {

	cmp	DWORD PTR __Pf$5[ebp], 0
	jne	$LN6@use_facet

; 443  :         if (_Psave) {

	cmp	DWORD PTR __Psave$7[ebp], 0
	je	SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], edx
	jmp	SHORT $LN6@use_facet
$LN3@use_facet:

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$7[ebp]
	push	ecx
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 446  : #if _HAS_EXCEPTIONS
; 447  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 448  : #else
; 449  :             _CSTD abort(); // lazy disallowed
; 450  : #endif
; 451  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN6@use_facet
$LN5@use_facet:

; 452  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pfmod$4[ebp], edx

; 453  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	eax, DWORD PTR __Pfmod$4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 454  : 
; 455  : #if defined(_M_CEE)
; 456  :             _Facet_Register_m(_Pfmod);
; 457  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 458  :             _Facet_Register(_Pfmod);

	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	push	ecx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR __Pfmod$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 463  :             _Pf                       = _Psave;

	mov	ecx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], ecx

; 464  : 
; 465  :             (void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 466  :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	npad	1
$LN6@use_facet:

; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	edx, DWORD PTR __Pf$5[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@use_facet
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@use_facet:
	DD	3
	DD	$LN14@use_facet
$LN14@use_facet:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN10@use_facet
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN11@use_facet
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN12@use_facet
$LN12@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN11@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$LN10@use_facet:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$8[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__New_ptr$ = -76					; size = 4
__New_capacity$ = -64					; size = 4
__Proxy$ = -52						; size = 8
_$S11$ = -33						; size = 1
__Alproxy$ = -28					; size = 4
__Al$ = -24						; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT
; _this$ = ecx

; 871  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 872  :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 873  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 874  : 
; 875  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 876  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 877  :         } else {
; 878  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 879  :         }
; 880  : 
; 881  :         if (_Count > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Construct

; 882  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _$S11$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	edx, DWORD PTR _$S11$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], edx

; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

	cmp	DWORD PTR __Count$[ebp], 15		; 0000000fH
	ja	SHORT $LN3@Construct

; 890  :             _My_data._Mysize = _Count;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+20], eax

; 891  :             _My_data._Myres  = _Small_string_capacity;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 892  : 
; 893  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 895  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 896  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 899  :             } else { // _Strat == _Construct_strategy::_From_string
; 900  : #ifdef _INSERT_STRING_ANNOTATION
; 901  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 902  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 903  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	push	16					; 00000010H
	mov	edx, DWORD PTR __Arg$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 904  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 905  :             }
; 906  : 
; 907  :             _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 908  :             return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN1@Construct
$LN3@Construct:

; 909  :         }
; 910  : 
; 911  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __New_capacity$[ebp], eax

; 912  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	edx, DWORD PTR __New_capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 914  : 
; 915  :         _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 916  :         _My_data._Myres  = _New_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [edx+24], eax

; 917  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 918  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 920  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 921  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 923  :         } else { // _Strat == _Construct_strategy::_From_string
; 924  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	ecx, DWORD PTR __Count$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Arg$[ebp]
	push	edx
	mov	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 925  :         }
; 926  : 
; 927  :         _ASAN_STRING_CREATE(*this);
; 928  :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 929  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN1@Construct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN12@Construct:
	DD	4
	DD	$LN11@Construct
$LN11@Construct:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN6@Construct
	DD	-52					; ffffffccH
	DD	8
	DD	$LN7@Construct
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN8@Construct
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN9@Construct
$LN9@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN8@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN7@Construct:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
$T2 = -82						; size = 1
$T3 = -81						; size = 1
__New_ptr$ = -76					; size = 4
__New_capacity$ = -64					; size = 4
__Proxy$ = -52						; size = 8
_$S10$ = -33						; size = 1
__Alproxy$ = -28					; size = 4
__Al$ = -24						; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 871  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 872  :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 873  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 874  : 
; 875  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 876  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 877  :         } else {
; 878  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 879  :         }
; 880  : 
; 881  :         if (_Count > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Construct

; 882  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _$S10$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	edx, DWORD PTR _$S10$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], edx

; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

	cmp	DWORD PTR __Count$[ebp], 15		; 0000000fH
	ja	SHORT $LN3@Construct

; 890  :             _My_data._Mysize = _Count;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+20], eax

; 891  :             _My_data._Myres  = _Small_string_capacity;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 892  : 
; 893  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 895  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 896  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 899  :             } else { // _Strat == _Construct_strategy::_From_string
; 900  : #ifdef _INSERT_STRING_ANNOTATION
; 901  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 902  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 903  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 904  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 905  :             }
; 906  : 
; 907  :             _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 908  :             return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN1@Construct
$LN3@Construct:

; 909  :         }
; 910  : 
; 911  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	push	15					; 0000000fH
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __New_capacity$[ebp], eax

; 912  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	ecx, DWORD PTR __New_capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 914  : 
; 915  :         _My_data._Mysize = _Count;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+20], eax

; 916  :         _My_data._Myres  = _New_capacity;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 917  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 918  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 920  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 921  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 923  :         } else { // _Strat == _Construct_strategy::_From_string
; 924  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 925  :         }
; 926  : 
; 927  :         _ASAN_STRING_CREATE(*this);
; 928  :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 929  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN1@Construct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN12@Construct:
	DD	4
	DD	$LN11@Construct
$LN11@Construct:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN6@Construct
	DD	-52					; ffffffccH
	DD	8
	DD	$LN7@Construct
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN8@Construct
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN9@Construct
$LN9@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN8@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN7@Construct:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	48					; 00000030H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z
_TEXT	SEGMENT
$T2 = -82						; size = 1
$T3 = -81						; size = 1
__New_ptr$ = -76					; size = 4
__New_capacity$ = -64					; size = 4
__Proxy$ = -52						; size = 8
_$S9$ = -33						; size = 1
__Alproxy$ = -28					; size = 4
__Al$ = -24						; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 1
__Count$ = 12						; size = 4
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>, COMDAT
; _this$ = ecx

; 871  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 872  :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 873  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 874  : 
; 875  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 876  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 877  :         } else {
; 878  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 879  :         }
; 880  : 
; 881  :         if (_Count > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Construct

; 882  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _$S9$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	edx, DWORD PTR _$S9$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], edx

; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

	cmp	DWORD PTR __Count$[ebp], 15		; 0000000fH
	ja	SHORT $LN3@Construct

; 890  :             _My_data._Mysize = _Count;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+20], eax

; 891  :             _My_data._Myres  = _Small_string_capacity;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 892  : 
; 893  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);

	movzx	edx, BYTE PTR __Arg$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 12					; 0000000cH

; 895  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 896  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 899  :             } else { // _Strat == _Construct_strategy::_From_string
; 900  : #ifdef _INSERT_STRING_ANNOTATION
; 901  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 902  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 903  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 904  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 905  :             }
; 906  : 
; 907  :             _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 908  :             return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN1@Construct
$LN3@Construct:

; 909  :         }
; 910  : 
; 911  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	push	15					; 0000000fH
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __New_capacity$[ebp], eax

; 912  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	ecx, DWORD PTR __New_capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 914  : 
; 915  :         _My_data._Mysize = _Count;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+20], eax

; 916  :         _My_data._Myres  = _New_capacity;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 917  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 918  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);

	movzx	eax, BYTE PTR __Arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 12					; 0000000cH

; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 920  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 921  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 923  :         } else { // _Strat == _Construct_strategy::_From_string
; 924  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 925  :         }
; 926  : 
; 927  :         _ASAN_STRING_CREATE(*this);
; 928  :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 929  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN1@Construct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN12@Construct:
	DD	4
	DD	$LN11@Construct
$LN11@Construct:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN6@Construct
	DD	-52					; ffffffccH
	DD	8
	DD	$LN7@Construct
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN8@Construct
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN9@Construct
$LN9@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN8@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN7@Construct:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	57					; 00000039H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1512 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1514 : }

	pop	ebp
	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 978  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Convert_size@II@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@II@std@@YAII@Z PROC			; std::_Convert_size<unsigned int,unsigned int>, COMDAT

; 1120 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	push	ebp
	mov	ebp, esp

; 1121 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1122 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1123 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1124 : 
; 1125 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1126 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1127 :             _Xlength_error("size is too long for _Size_type");
; 1128 :         }
; 1129 :     }
; 1130 : 
; 1131 :     return static_cast<_Size_type>(_Len);

	mov	eax, DWORD PTR __Len$[ebp]

; 1132 : }

	pop	ebp
	ret	0
??$_Convert_size@II@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__New_proxy$ = -8					; size = 4
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1219 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1220 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	DWORD PTR __New_proxy$[ebp], eax

; 1221 :         _Construct_in_place(*_New_proxy, this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_proxy$[ebp]
	push	edx
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1222 :         _Myproxy            = _New_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_proxy$[ebp]
	mov	DWORD PTR [eax], ecx

; 1223 :         _New_proxy->_Mycont = this;

	mov	edx, DWORD PTR __New_proxy$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 1224 :     }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1147 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp

; 1148 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1149 :     using _Ty = typename _Alloc::value_type;
; 1150 :     _Ptr->~_Ty();
; 1151 :     _STD _Deallocate_plain(_Al, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 1152 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$07@std@@YAII@Z	; std::_Get_size_of_n<8>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
	add	esp, 4

; 991  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 122  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+4]

; 124  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -6						; size = 1
__Zero_uncaught_exceptions$ = -5			; size = 1
_this$ = -4						; size = 4
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 107  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 108  : #if !_HAS_EXCEPTIONS
; 109  :             const bool _Zero_uncaught_exceptions = true;
; 110  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@sentry
	mov	BYTE PTR tv72[ebp], 1
	jmp	SHORT $LN5@sentry
$LN4@sentry:
	mov	BYTE PTR tv72[ebp], 0
$LN5@sentry:
	mov	cl, BYTE PTR tv72[ebp]
	mov	BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	movzx	edx, BYTE PTR __Zero_uncaught_exceptions$[ebp]
	test	edx, edx
	je	SHORT $LN2@sentry

; 117  :                 this->_Myostr._Osfx();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
	npad	1
$LN2@sentry:

; 118  :             }
; 119  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	npad	1
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 91   :             if (!_Ostr.good()) {

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 92   :                 _Ok = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0

; 93   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	DWORD PTR __Tied$[ebp], eax

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	cmp	DWORD PTR __Tied$[ebp], 0
	je	SHORT $LN4@sentry
	mov	ecx, DWORD PTR __Ostr$[ebp]
	push	ecx
	call	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
	add	esp, 4
	cmp	DWORD PTR __Tied$[ebp], eax
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 98   :                 _Ok = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 1

; 99   :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	mov	ecx, DWORD PTR __Tied$[ebp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al
$LN1@sentry:

; 104  :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -24						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 78   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
__Rdbuf$ = -8						; size = 4
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 71   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN2@Sentry_bas

; 72   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@Sentry_bas:

; 73   :             }
; 74   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1538 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1539 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1540 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 3464 :     _CONSTEXPR23 pointer release() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3465 :         return _STD exchange(_Mypair._Myval2, nullptr);

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
	add	esp, 8

; 3466 :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 3425 :     _CONSTEXPR23 ~unique_ptr() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3426 :         if (_Mypair._Myval2) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@unique_ptr

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
	mov	ecx, eax
	call	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
	npad	1
$LN2@unique_ptr:

; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@operator
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv70[ebp], 0
$LN4@operator:

; 3310 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Get_index@$0A@@id@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -12						; size = 4
_this$ = -4						; size = 4
??$_Get_index@$0A@@id@locale@std@@QAEIXZ PROC		; std::locale::id::_Get_index<0>, COMDAT
; _this$ = ecx

; 90   :         size_t _Get_index() { // get stamp, with lazy allocation

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 91   :             if (_Id == 0) { // still zero, allocate stamp

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@Get_index

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	npad	1

; 93   :                 if (_Id == 0) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@Get_index

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	edx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	edx, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, edx ; std::locale::id::_Id_cnt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	mov	DWORD PTR [eax], ecx
$LN3@Get_index:

; 95   :                 }
; 96   :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	npad	1
$LN2@Get_index:

; 97   :             }
; 98   :             return _Id;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 99   :         }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Get_index
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@Get_index:
	DD	1
	DD	$LN7@Get_index
$LN7@Get_index:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN6@Get_index
$LN6@Get_index:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
??$_Get_index@$0A@@id@locale@std@@QAEIXZ ENDP		; std::locale::id::_Get_index<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@min
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@min:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 260  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const noexcept { // count number of available positions in write buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 261  :         return *_IPnext ? *_IPcount : 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Pnavail
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@Pnavail
$LN3@Pnavail:
	mov	DWORD PTR tv69[ebp], 0
$LN4@Pnavail:
	mov	eax, DWORD PTR tv69[ebp]
	cdq

; 262  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 255  :     _Elem* __CLR_OR_THIS_CALL _Pninc() noexcept { // increment current position in write buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 256  :         --*_IPcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], edx

; 257  :         return (*_IPnext)++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv76[ebp]

; 258  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 231  :     streamsize __CLR_OR_THIS_CALL _Gnavail() const noexcept { // count number of available elements in read buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 232  :         return *_IGnext ? *_IGcount : 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Gnavail
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@Gnavail
$LN3@Gnavail:
	mov	DWORD PTR tv69[ebp], 0
$LN4@Gnavail:
	mov	eax, DWORD PTR tv69[ebp]
	cdq

; 233  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 226  :     _Elem* __CLR_OR_THIS_CALL _Gnpreinc() noexcept { // preincrement current position in read buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 227  :         --*_IGcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx], edx

; 228  :         return ++(*_IGnext);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv72[ebp]

; 229  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 221  :     _Elem* __CLR_OR_THIS_CALL _Gninc() noexcept { // increment current position in read buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 222  :         --*_IGcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx], edx

; 223  :         return (*_IGnext)++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv76[ebp]

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 183  :     _Elem* __CLR_OR_THIS_CALL gptr() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 184  :         return *_IGnext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx]

; 185  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 170  :         streamsize _Count) { // put _Count characters from array beginning at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 171  :         return xsputn(_Ptr, _Count);

	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 172  :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
tv78 = -16						; size = 4
tv85 = -12						; size = 8
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 165  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
	mov	DWORD PTR tv85[ebp], eax
	mov	DWORD PTR tv85[ebp+4], edx
	cmp	DWORD PTR tv85[ebp+4], 0
	jl	SHORT $LN3@sputc
	jg	SHORT $LN5@sputc
	cmp	DWORD PTR tv85[ebp], 0
	jbe	SHORT $LN3@sputc
$LN5@sputc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl
	movzx	edx, BYTE PTR __Ch$[ebp]
	push	edx
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN4@sputc
$LN3@sputc:
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv78[ebp], eax
$LN4@sputc:
	mov	eax, DWORD PTR tv78[ebp]

; 167  :     }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv82 = -20						; size = 4
tv83 = -16						; size = 4
tv89 = -12						; size = 8
_this$ = -4						; size = 4
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 137  :     int_type __CLR_OR_THIS_CALL snextc() { // point to next character and return it

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 138  :         return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	DWORD PTR tv89[ebp], eax
	mov	DWORD PTR tv89[ebp+4], edx
	cmp	DWORD PTR tv89[ebp+4], 0
	jl	SHORT $LN5@snextc
	jg	SHORT $LN7@snextc
	cmp	DWORD PTR tv89[ebp], 1
	jbe	SHORT $LN5@snextc
$LN7@snextc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN6@snextc
$LN5@snextc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
	push	eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@snextc
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@snextc
$LN3@snextc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR tv82[ebp], eax
$LN4@snextc:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN6@snextc:
	mov	eax, DWORD PTR tv83[ebp]

; 139  :              : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
; 140  :                                                               : sgetc();
; 141  :     }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv75 = -16						; size = 4
tv82 = -12						; size = 8
_this$ = -4						; size = 4
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 128  :     int_type __CLR_OR_THIS_CALL sgetc() { // get a character and don't point past it

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	DWORD PTR tv82[ebp], eax
	mov	DWORD PTR tv82[ebp+4], edx
	cmp	DWORD PTR tv82[ebp+4], 0
	jl	SHORT $LN3@sgetc
	jg	SHORT $LN5@sgetc
	cmp	DWORD PTR tv82[ebp], 0
	jbe	SHORT $LN3@sgetc
$LN5@sgetc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@sgetc
$LN3@sgetc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv75[ebp], eax
$LN4@sgetc:
	mov	eax, DWORD PTR tv75[ebp]

; 130  :     }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv75 = -16						; size = 4
tv82 = -12						; size = 8
_this$ = -4						; size = 4
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 124  :     int_type __CLR_OR_THIS_CALL sbumpc() { // get a character and point past it

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	DWORD PTR tv82[ebp], eax
	mov	DWORD PTR tv82[ebp+4], edx
	cmp	DWORD PTR tv82[ebp+4], 0
	jl	SHORT $LN3@sbumpc
	jg	SHORT $LN5@sbumpc
	cmp	DWORD PTR tv82[ebp], 0
	jbe	SHORT $LN3@sbumpc
$LN5@sbumpc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@sbumpc
$LN3@sbumpc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv75[ebp], eax
$LN4@sbumpc:
	mov	eax, DWORD PTR tv75[ebp]

; 126  :     }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 120  :     int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  :         return sync();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 122  :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z PROC ; std::basic_istream<char,std::char_traits<char> >::operator>>, COMDAT
; _this$ = ecx

; 301  :     basic_istream& __CLR_OR_THIS_CALL operator>>(double& _Val) { // extract a double

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 302  :         return _Common_extract_with_num_get(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Common_extract_with_num_get@N@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAN@Z ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<double>

; 303  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::operator>>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
tv248 = -61						; size = 1
tv247 = -60						; size = 4
tv246 = -56						; size = 4
tv243 = -52						; size = 4
tv245 = -48						; size = 4
$T2 = -44						; size = 8
__Meta$3 = -36						; size = 4
__Ctype_fac$4 = -32					; size = 4
__Eof$ = -25						; size = 1
__Tied$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 121  :     bool __CLR_OR_THIS_CALL _Ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 122  :         if (!this->good()) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Ipfx

; 123  :             _Myios::setstate(ios_base::failbit);

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 124  :             return false;

	xor	al, al
	jmp	$LN1@Ipfx
$LN5@Ipfx:

; 125  :         }
; 126  : 
; 127  :         // state okay, flush tied stream and skip whitespace
; 128  :         const auto _Tied = _Myios::tie();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	DWORD PTR __Tied$[ebp], eax

; 129  :         if (_Tied) {

	cmp	DWORD PTR __Tied$[ebp], 0
	je	SHORT $LN6@Ipfx

; 130  :             _Tied->flush();

	mov	ecx, DWORD PTR __Tied$[ebp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	npad	1
$LN6@Ipfx:

; 131  :         }
; 132  : 
; 133  :         bool _Eof = false;

	mov	BYTE PTR __Eof$[ebp], 0

; 134  :         if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace

	movzx	eax, BYTE PTR __Noskip$[ebp]
	test	eax, eax
	jne	$LN17@Ipfx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 1
	je	$LN17@Ipfx

; 135  :             const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv245[ebp], eax
	mov	eax, DWORD PTR tv245[ebp]
	mov	DWORD PTR tv243[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR tv243[ebp]
	push	ecx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 136  : 
; 137  :             _TRY_IO_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 138  :             int_type _Meta = _Myios::rdbuf()->sgetc();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR tv246[ebp], eax
	mov	ecx, DWORD PTR tv246[ebp]
	mov	DWORD PTR __Meta$3[ebp], ecx

; 139  : 
; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

	jmp	SHORT $LN4@Ipfx
$LN2@Ipfx:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
	mov	DWORD PTR tv247[ebp], eax
	mov	ecx, DWORD PTR tv247[ebp]
	mov	DWORD PTR __Meta$3[ebp], ecx
$LN4@Ipfx:

; 141  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

	mov	edx, DWORD PTR __Meta$3[ebp]
	push	edx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Ipfx

; 142  :                     _Eof = true;

	mov	BYTE PTR __Eof$[ebp], 1

; 143  :                     break;

	jmp	SHORT $LN3@Ipfx
	jmp	SHORT $LN11@Ipfx
$LN9@Ipfx:

; 144  :                 } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

	mov	ecx, DWORD PTR __Meta$3[ebp]
	push	ecx
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	add	esp, 4
	movzx	edx, al
	push	edx
	push	72					; 00000048H
	mov	ecx, DWORD PTR __Ctype_fac$4[ebp]
	call	?is@?$ctype@D@std@@QBE_NFD@Z		; std::ctype<char>::is
	mov	BYTE PTR tv248[ebp], al
	movzx	eax, BYTE PTR tv248[ebp]
	test	eax, eax
	jne	SHORT $LN11@Ipfx

; 145  :                     break; // not whitespace, quit

	jmp	SHORT $LN3@Ipfx
$LN11@Ipfx:

; 146  :                 }
; 147  :             }

	jmp	SHORT $LN2@Ipfx
$LN3@Ipfx:
	jmp	SHORT $LN14@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 148  :             _CATCH_IO_END

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	mov	eax, $LN18@Ipfx
	ret	0
$LN14@Ipfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN17@Ipfx
$LN18@Ipfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:

; 149  :         }
; 150  : 
; 151  :         if (_Eof) {

	movzx	eax, BYTE PTR __Eof$[ebp]
	test	eax, eax
	je	SHORT $LN12@Ipfx

; 152  :             _Myios::setstate(ios_base::eofbit | ios_base::failbit);

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN12@Ipfx:

; 153  :         }
; 154  : 
; 155  :         return this->good();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
$LN1@Ipfx:

; 156  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv284 = -96						; size = 4
tv283 = -92						; size = 8
tv137 = -84						; size = 4
tv135 = -80						; size = 8
tv332 = -72						; size = 8
tv320 = -64						; size = 8
$T2 = -56						; size = 4
__Ok$ = -48						; size = 8
__Pad$ = -36						; size = 8
__Count$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 768  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 769  :     // insert NTBS into char stream
; 770  :     using _Elem = char;
; 771  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 772  : 
; 773  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 774  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR __Count$[ebp], eax
	mov	DWORD PTR __Count$[ebp+4], ecx

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv320[ebp], eax
	mov	DWORD PTR tv320[ebp+4], edx
	cmp	DWORD PTR tv320[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv320[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv332[ebp], eax
	mov	DWORD PTR tv332[ebp+4], edx
	mov	eax, DWORD PTR tv332[ebp+4]
	cmp	eax, DWORD PTR __Count$[ebp+4]
	jl	SHORT $LN17@operator
	jg	SHORT $LN25@operator
	mov	ecx, DWORD PTR tv332[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN17@operator
$LN25@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	sbb	edx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	DWORD PTR tv135[ebp+4], edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv135[ebp], xmm0
$LN18@operator:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	edx, DWORD PTR tv135[ebp+4]
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	DWORD PTR __Pad$[ebp+4], edx

; 776  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 777  : 
; 778  :     if (!_Ok) {

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@operator

; 779  :         _State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx

; 780  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 781  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 782  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN3@operator

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	SHORT $LN3@operator
	jg	SHORT $LN26@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	SHORT $LN3@operator
$LN26@operator:

; 784  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv137[ebp], eax
	mov	ecx, DWORD PTR tv137[ebp]
	push	ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@operator

; 785  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 786  :                     break;

	jmp	SHORT $LN3@operator
$LN12@operator:

; 787  :                 }
; 788  :             }

	jmp	SHORT $LN2@operator
$LN3@operator:

; 789  :         }
; 790  : 
; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN13@operator
	mov	ecx, DWORD PTR __Count$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
	mov	DWORD PTR tv283[ebp], eax
	mov	DWORD PTR tv283[ebp+4], edx
	mov	eax, DWORD PTR tv283[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jne	SHORT $LN27@operator
	mov	ecx, DWORD PTR tv283[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp+4]
	je	SHORT $LN13@operator
$LN27@operator:

; 792  :             _State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx
$LN13@operator:

; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN6@operator

; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	SHORT $LN6@operator
	jg	SHORT $LN28@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	SHORT $LN6@operator
$LN28@operator:

; 797  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv284[ebp], eax
	mov	ecx, DWORD PTR tv284[ebp]
	push	ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@operator

; 798  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 799  :                     break;

	jmp	SHORT $LN6@operator
$LN15@operator:

; 800  :                 }
; 801  :             }

	jmp	SHORT $LN5@operator
$LN6@operator:

; 802  :         }
; 803  : 
; 804  :         _Ostr.width(0);

	push	0
	push	0
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width
	npad	1
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 805  :         _CATCH_IO_(ios_base, _Ostr)

	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN22@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN22@operator:

; 806  :     }
; 807  : 
; 808  :     _Ostr.setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1

; 809  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 810  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@operator:
	DD	1
	DD	$LN31@operator
$LN31@operator:
	DD	-48					; ffffffd0H
	DD	8
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
tv77 = -48						; size = 4
__State$2 = -44						; size = 4
__Ok$3 = -36						; size = 8
__Rdbuf$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 562  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 563  :         const auto _Rdbuf = _Myios::rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 564  :         if (_Rdbuf) { // buffer exists, flush it

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	$LN2@flush

; 565  :             const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$3[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 566  : 
; 567  :             if (_Ok) {

	lea	ecx, DWORD PTR __Ok$3[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@flush

; 568  :                 ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$2[ebp], 0

; 569  :                 _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 570  :                 if (_Rdbuf->pubsync() == -1) {

	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], -1
	jne	SHORT $LN5@flush

; 571  :                     _State |= ios_base::badbit; // sync failed

	mov	edx, DWORD PTR __State$2[ebp]
	or	edx, 4
	mov	DWORD PTR __State$2[ebp], edx
$LN5@flush:
	jmp	SHORT $LN7@flush
__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:

; 572  :                 }
; 573  :                 _CATCH_IO_END

	push	1
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	mov	eax, $LN11@flush
	ret	0
$LN7@flush:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN10@flush
$LN11@flush:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN10@flush:

; 574  :                 _Myios::setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN3@flush:

; 575  :             }
; 576  :         }

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$3[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	npad	1
$LN2@flush:

; 577  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 578  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@flush
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@flush:
	DD	1
	DD	$LN14@flush
$LN14@flush:
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN12@flush
$LN12@flush:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2:
	lea	ecx, DWORD PTR __Ok$3[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
_TEXT	SEGMENT
tv195 = -84						; size = 4
tv192 = -80						; size = 4
tv65 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 8
$T4 = -60						; size = 8
$T5 = -52						; size = 8
__Nput_fac$6 = -44					; size = 4
__Ok$ = -36						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 8
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 412  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(double _Val) { // insert a double

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 413  :         ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 414  :         const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 415  : 
; 416  :         if (_Ok) { // state okay, use facet to insert

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@operator

; 417  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv192[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ecx, DWORD PTR tv192[ebp]
	push	ecx
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	DWORD PTR __Nput_fac$6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	npad	1

; 418  : 
; 419  :             _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 420  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Nput_fac$6[ebp]
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
	mov	DWORD PTR tv195[ebp], eax
	mov	ecx, DWORD PTR tv195[ebp]
	call	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@operator

; 421  :                 _State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx
$LN4@operator:
	jmp	SHORT $LN6@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0:

; 422  :             }
; 423  :             _CATCH_IO_END

	push	1
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	mov	eax, $LN11@operator
	ret	0
$LN6@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN10@operator
$LN11@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN10@operator:

; 424  :         }
; 425  : 
; 426  :         _Myios::setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1

; 427  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 428  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN15@operator:
	DD	1
	DD	$LN14@operator
$LN14@operator:
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN12@operator
$LN12@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv149 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 159  :     void __CLR_OR_THIS_CALL _Osfx() noexcept { // perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 160  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 161  :         if (this->good() && this->flags() & ios_base::unitbuf) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Osfx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 2
	je	SHORT $LN4@Osfx

; 162  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	mov	DWORD PTR tv149[ebp], eax
	cmp	DWORD PTR tv149[ebp], -1
	jne	SHORT $LN4@Osfx

; 163  :                 _Myios::setstate(ios_base::badbit);

	push	0
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN4@Osfx:
	jmp	SHORT $LN7@Osfx
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 164  :             }
; 165  :         }
; 166  :         _CATCH_ALL
; 167  :         _CATCH_END

	mov	eax, $LN10@Osfx
	ret	0
$LN7@Osfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@Osfx
$LN10@Osfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Osfx:

; 168  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 98   :     _Elem __CLR_OR_THIS_CALL fill() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 99   :         return _Fillch;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+64]

; 100  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 77   :     _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   :         return _Mystrbuf;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]

; 79   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 67   :     _Myos* __CLR_OR_THIS_CALL tie() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   :         return _Tiestr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]

; 69   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 49   :     void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Reraise = false) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 50   :         // merge _State into state, possibly reraise exception
; 51   :         clear(rdstate() | _State, _Reraise);

	movzx	eax, BYTE PTR __Reraise$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	or	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
	npad	1

; 52   :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 38   :     void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 39   :         // set state, possibly reraise exception
; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN3@clear
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@clear
$LN3@clear:
	mov	DWORD PTR tv72[ebp], 4
$LN4@clear:
	movzx	ecx, BYTE PTR __Reraise$[ebp]
	push	ecx
	mov	edx, DWORD PTR __State$[ebp]
	or	edx, DWORD PTR tv72[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	npad	1

; 41   :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\Hamzzi\Desktop\AI_Practice\Source\VS2010\Common\2D\Vector2d.cpp
_TEXT	SEGMENT
_is$ = 8						; size = 4
_lhs$ = 12						; size = 4
??5@YAAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@AAV01@AAUVector2D@@@Z PROC ; operator>>

; 13   : {

	push	ebp
	mov	ebp, esp

; 14   :   is >> lhs.x >> lhs.y;

	mov	eax, DWORD PTR _lhs$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _lhs$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _is$[ebp]
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	mov	ecx, eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>

; 15   : 
; 16   :   return is;

	mov	eax, DWORD PTR _is$[ebp]

; 17   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??5@YAAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@AAV01@AAUVector2D@@@Z ENDP ; operator>>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\Hamzzi\Desktop\AI_Practice\Source\VS2010\Common\2D\Vector2d.cpp
_TEXT	SEGMENT
_os$ = 8						; size = 4
_rhs$ = 12						; size = 4
??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUVector2D@@@Z PROC ; operator<<

; 5    : {

	push	ebp
	mov	ebp, esp

; 6    :   os << " " << rhs.x << " " << rhs.y;

	mov	eax, DWORD PTR _rhs$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+8]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG194400
	mov	ecx, DWORD PTR _rhs$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG194401
	mov	edx, DWORD PTR _os$[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 7    : 
; 8    :   return os;

	mov	eax, DWORD PTR _os$[ebp]

; 9    : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUVector2D@@@Z ENDP ; operator<<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Stofx_v3@std@@YAMPBDPAPADPAH@Z
_TEXT	SEGMENT
__Val$ = -12						; size = 4
__Orig$ = -8						; size = 4
__Errno_ref$ = -4					; size = 4
__Str$ = 8						; size = 4
__Endptr$ = 12						; size = 4
__Perr$ = 16						; size = 4
?_Stofx_v3@std@@YAMPBDPAPADPAH@Z PROC			; std::_Stofx_v3, COMDAT

; 54   : inline float _Stofx_v3(const char* _Str, char** _Endptr, int* _Perr) noexcept { // convert string to float

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 55   :     int& _Errno_ref = errno; // Nonzero cost, pay it once

	call	__errno
	mov	DWORD PTR __Errno_ref$[ebp], eax

; 56   :     const int _Orig = _Errno_ref;

	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Orig$[ebp], ecx

; 57   : 
; 58   :     _Errno_ref = 0;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	DWORD PTR [edx], 0

; 59   :     float _Val = _CSTD strtof(_Str, _Endptr);

	mov	eax, DWORD PTR __Endptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strtof
	add	esp, 8
	fstp	DWORD PTR __Val$[ebp]

; 60   :     *_Perr     = _Errno_ref;

	mov	edx, DWORD PTR __Perr$[ebp]
	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 61   :     _Errno_ref = _Orig;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	eax, DWORD PTR __Orig$[ebp]
	mov	DWORD PTR [edx], eax

; 62   : 
; 63   :     return _Val;

	fld	DWORD PTR __Val$[ebp]

; 64   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Stofx_v3@std@@YAMPBDPAPADPAH@Z ENDP			; std::_Stofx_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Stodx_v3@std@@YANPBDPAPADPAH@Z
_TEXT	SEGMENT
__Val$ = -16						; size = 8
__Orig$ = -8						; size = 4
__Errno_ref$ = -4					; size = 4
__Str$ = 8						; size = 4
__Endptr$ = 12						; size = 4
__Perr$ = 16						; size = 4
?_Stodx_v3@std@@YANPBDPAPADPAH@Z PROC			; std::_Stodx_v3, COMDAT

; 42   : inline double _Stodx_v3(const char* _Str, char** _Endptr, int* _Perr) noexcept { // convert string to double

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 43   :     int& _Errno_ref = errno; // Nonzero cost, pay it once

	call	__errno
	mov	DWORD PTR __Errno_ref$[ebp], eax

; 44   :     const int _Orig = _Errno_ref;

	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Orig$[ebp], ecx

; 45   : 
; 46   :     _Errno_ref  = 0;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	DWORD PTR [edx], 0

; 47   :     double _Val = _CSTD strtod(_Str, _Endptr);

	mov	eax, DWORD PTR __Endptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strtod
	add	esp, 8
	fstp	QWORD PTR __Val$[ebp]

; 48   :     *_Perr      = _Errno_ref;

	mov	edx, DWORD PTR __Perr$[ebp]
	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 49   :     _Errno_ref  = _Orig;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	eax, DWORD PTR __Orig$[ebp]
	mov	DWORD PTR [edx], eax

; 50   : 
; 51   :     return _Val;

	fld	QWORD PTR __Val$[ebp]

; 52   : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Stodx_v3@std@@YANPBDPAPADPAH@Z ENDP			; std::_Stodx_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 288  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const noexcept /* strengthened */ { // get locale

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 289  :         return *_Ploc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0locale@std@@QAE@ABV01@@Z		; std::locale::locale
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 290  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Oldwidth$ = -12					; size = 8
_this$ = -4						; size = 4
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 281  :     streamsize __CLR_OR_THIS_CALL width(streamsize _Newwidth) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 282  :         // set width to argument
; 283  :         const streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR __Oldwidth$[ebp], ecx
	mov	DWORD PTR __Oldwidth$[ebp+4], edx

; 284  :         _Wide                      = _Newwidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newwidth$[ebp]
	mov	edx, DWORD PTR __Newwidth$[ebp+4]
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], edx

; 285  :         return _Oldwidth;

	mov	eax, DWORD PTR __Oldwidth$[ebp]
	mov	edx, DWORD PTR __Oldwidth$[ebp+4]

; 286  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 277  :     _NODISCARD streamsize __CLR_OR_THIS_CALL width() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 278  :         return _Wide;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]

; 279  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 266  :     _NODISCARD streamsize __CLR_OR_THIS_CALL precision() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 267  :         return _Prec;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]

; 268  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 236  :     _NODISCARD fmtflags __CLR_OR_THIS_CALL flags() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  :         return _Fmtfl;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 238  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 205  :     _NODISCARD bool __CLR_OR_THIS_CALL good() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         return rdstate() == ios_base::goodbit;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	test	eax, eax
	jne	SHORT $LN3@good
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@good
$LN3@good:
	mov	DWORD PTR tv67[ebp], 0
$LN4@good:
	movzx	eax, BYTE PTR tv67[ebp]

; 207  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 186  :     _NODISCARD iostate __CLR_OR_THIS_CALL rdstate() const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  :         return _Mystate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 188  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -40						; size = 8
$T2 = -32						; size = 20
__Msg$3 = -12						; size = 4
__Filtered$ = -8					; size = 4
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 154  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  :         _State &= _Statmask;

	mov	eax, DWORD PTR __State$[ebp]
	and	eax, 23					; 00000017H
	mov	DWORD PTR __State$[ebp], eax

; 156  :         _Mystate             = _State;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 157  :         const auto _Filtered = _State & _Except;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
	and	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Filtered$[ebp], ecx

; 158  :         if (_Filtered) {

	je	SHORT $LN2@clear

; 159  :             if (_Reraise) {

	movzx	edx, BYTE PTR __Reraise$[ebp]
	test	edx, edx
	je	SHORT $LN3@clear

; 160  :                 _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	npad	1
$LN3@clear:

; 161  :             }
; 162  : 
; 163  :             const char* _Msg;
; 164  :             if (_Filtered & ios_base::badbit) {

	mov	eax, DWORD PTR __Filtered$[ebp]
	and	eax, 4
	je	SHORT $LN4@clear

; 165  :                 _Msg = "ios_base::badbit set";

	mov	DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
	jmp	SHORT $LN7@clear
$LN4@clear:

; 166  :             } else if (_Filtered & ios_base::failbit) {

	mov	ecx, DWORD PTR __Filtered$[ebp]
	and	ecx, 2
	je	SHORT $LN6@clear

; 167  :                 _Msg = "ios_base::failbit set";

	mov	DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@

; 168  :             } else {

	jmp	SHORT $LN7@clear
$LN6@clear:

; 169  :                 _Msg = "ios_base::eofbit set";

	mov	DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
$LN7@clear:

; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

	push	1
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR __Msg$3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
$LN2@clear:
$LN1@clear:

; 173  :         }
; 174  :     }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1failure@ios_base@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0system_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1system_error@std@@UAE@XZ
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 116  :         explicit failure(const char* _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 117  :             : system_error(_Errcode, _Message) {} // construct with message

	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errcode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z PROC	; std::_Adl_verify_range<char *,char const *>, COMDAT

; 1352 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	push	ebp
	mov	ebp, esp

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jbe	SHORT $LN2@Adl_verify
	push	OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1356					; 0000054cH
	push	OFFSET ??_C@_0GD@GOKHNLI@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@Adl_verify
	int	3
$LN4@Adl_verify:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@Adl_verify:
$LN1@Adl_verify:

; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ENDP	; std::_Adl_verify_range<char *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
__Psave_guard$3 = -56					; size = 4
__Pfmod$4 = -48						; size = 4
__Pf$5 = -44						; size = 4
__Id$6 = -40						; size = 4
__Psave$7 = -32						; size = 4
__Lock$8 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __Psave$7[ebp], eax

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();

	mov	ecx, OFFSET ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
	call	??$_Get_index@$0A@@id@locale@std@@QAEIXZ ; std::locale::id::_Get_index<0>
	mov	DWORD PTR __Id$6[ebp], eax

; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$6[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$5[ebp], eax

; 441  : 
; 442  :     if (!_Pf) {

	cmp	DWORD PTR __Pf$5[ebp], 0
	jne	$LN6@use_facet

; 443  :         if (_Psave) {

	cmp	DWORD PTR __Psave$7[ebp], 0
	je	SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], edx
	jmp	SHORT $LN6@use_facet
$LN3@use_facet:

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$7[ebp]
	push	ecx
	call	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 446  : #if _HAS_EXCEPTIONS
; 447  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 448  : #else
; 449  :             _CSTD abort(); // lazy disallowed
; 450  : #endif
; 451  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN6@use_facet
$LN5@use_facet:

; 452  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	edx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pfmod$4[ebp], edx

; 453  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	eax, DWORD PTR __Pfmod$4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 454  : 
; 455  : #if defined(_M_CEE)
; 456  :             _Facet_Register_m(_Pfmod);
; 457  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 458  :             _Facet_Register(_Pfmod);

	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	push	ecx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR __Pfmod$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR __Pfmod$4[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 463  :             _Pf                       = _Psave;

	mov	ecx, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR __Pf$5[ebp], ecx

; 464  : 
; 465  :             (void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 466  :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	npad	1
$LN6@use_facet:

; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	edx, DWORD PTR __Pf$5[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$8[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@use_facet
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@use_facet:
	DD	3
	DD	$LN14@use_facet
$LN14@use_facet:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN10@use_facet
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN11@use_facet
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN12@use_facet
$LN12@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN11@use_facet:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$LN10@use_facet:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$8[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$3[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$ctype@D@std@@MAE@XZ		; std::ctype<char>::~ctype<char>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN4@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN4@scalar
$LN3@scalar:
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN4@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2876 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2877 :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
	add	esp, 8

; 2878 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2879 :         return _Last;

	mov	eax, DWORD PTR __Last$[ebp]

; 2880 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2871 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2872 :         return _Ch;

	movzx	eax, BYTE PTR __Ch$[ebp]

; 2873 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2865 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2866 :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
	add	esp, 8

; 2867 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2868 :         return _Last;

	mov	eax, DWORD PTR __Last$[ebp]

; 2869 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2860 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2861 :         return _Byte;

	movzx	eax, BYTE PTR __Byte$[ebp]

; 2862 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2851 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2852 :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
	add	esp, 8

; 2853 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_toupper
$LN2@do_toupper:
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 1
	mov	DWORD PTR __First$[ebp], edx
$LN4@do_toupper:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@do_toupper

; 2854 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	__Toupper
	add	esp, 8
	mov	ecx, DWORD PTR __First$[ebp]
	mov	BYTE PTR [ecx], al

; 2855 :         }

	jmp	SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2856 : 
; 2857 :         return _First;

	mov	eax, DWORD PTR __First$[ebp]

; 2858 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2846 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2847 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	call	__Toupper
	add	esp, 8

; 2848 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2837 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2838 :         _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
	add	esp, 8

; 2839 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_tolower
$LN2@do_tolower:
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 1
	mov	DWORD PTR __First$[ebp], edx
$LN4@do_tolower:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@do_tolower

; 2840 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	__Tolower
	add	esp, 8
	mov	ecx, DWORD PTR __First$[ebp]
	mov	BYTE PTR [ecx], al

; 2841 :         }

	jmp	SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2842 : 
; 2843 :         return _First;

	mov	eax, DWORD PTR __First$[ebp]

; 2844 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2832 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2833 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	call	__Tolower
	add	esp, 8

; 2834 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2822 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2823 :         if (0 < _Ctype._Delfl) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jle	SHORT $LN2@Tidy

; 2824 :             _CSTD free(const_cast<short*>(_Ctype._Table));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_free
	add	esp, 4
	jmp	SHORT $LN4@Tidy
$LN2@Tidy:

; 2825 :         } else if (_Ctype._Delfl < 0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jge	SHORT $LN4@Tidy

; 2826 :             delete[] _Ctype._Table;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@Tidy:

; 2827 :         }
; 2828 : 
; 2829 :         _CSTD free(_Ctype._LocaleName);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_free
	add	esp, 4

; 2830 :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2818 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2819 :         _Ctype = _Lobj._Getctype();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 2820 :     }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2814 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$ctype@D@std@@6B@

; 2815 :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$ctype@D@std@@IAEXXZ		; std::ctype<char>::_Tidy
	npad	1

; 2816 :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
tv88 = -88						; size = 4
tv94 = -84						; size = 4
tv129 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 52
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2795 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 2796 :         if (_Ppf && !*_Ppf) {

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN9@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN9@Getcat

; 2797 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

	push	24					; 00000018H
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?_C_str@locale@std@@QBEPBDXZ		; std::locale::_C_str
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z	; std::ctype<char>::ctype<char>
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv88[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 1
	je	SHORT $LN9@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
	npad	1
$LN9@Getcat:

; 2798 :         }
; 2799 : 
; 2800 :         return _X_CTYPE;

	mov	eax, 2

; 2801 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2791 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ctype_base@std@@QAE@I@Z		; std::ctype_base::ctype_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$ctype@D@std@@6B@

; 2792 :         _Init(_Lobj);

	mov	edx, DWORD PTR __Lobj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init
	npad	1

; 2793 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2759 :         _Elem* _Dest) const { // widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2760 :         return do_widen(_First, _Last, _Dest);

	mov	esi, esp
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2761 :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?tolower@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?tolower@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::tolower, COMDAT
; _this$ = ecx

; 2736 :     _Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const { // convert element to lower case

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2737 :         return do_tolower(_Ch);

	mov	esi, esp
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2738 :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?tolower@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::tolower
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2702 :     bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2703 :         return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;

	movzx	eax, BYTE PTR __Ch$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movsx	eax, WORD PTR [edx+eax*2]
	movsx	ecx, WORD PTR __Maskval$[ebp]
	and	eax, ecx
	je	SHORT $LN3@is
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@is
$LN3@is:
	mov	DWORD PTR tv73[ebp], 0
$LN4@is:
	movzx	eax, BYTE PTR tv73[ebp]

; 2704 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN4@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN4@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN4@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2450 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept override {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2447 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) noexcept // strengthened

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2448 :         : locale::facet(_Refs) {}

	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@min
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@min:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1352 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	push	ebp
	mov	ebp, esp

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jbe	SHORT $LN2@Adl_verify
	push	OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1356					; 0000054cH
	push	OFFSET ??_C@_0GD@GOKHNLI@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@Adl_verify
	int	3
$LN4@Adl_verify:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@Adl_verify:
$LN1@Adl_verify:

; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 1352 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	push	ebp
	mov	ebp, esp

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jbe	SHORT $LN2@Adl_verify
	push	OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1356					; 0000054cH
	push	OFFSET ??_C@_0GD@GOKHNLI@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@Adl_verify
	int	3
$LN4@Adl_verify:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@Adl_verify:
$LN1@Adl_verify:

; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
tv71 = -16						; size = 4
__Ptr0$ = -12						; size = 4
__Facptr$ = -8						; size = 4
_this$ = -4						; size = 4
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Id$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Id$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN7@Getfacet
$LN6@Getfacet:
	mov	DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR __Facptr$[ebp], edx

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

	cmp	DWORD PTR __Facptr$[ebp], 0
	jne	SHORT $LN3@Getfacet
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN2@Getfacet
$LN3@Getfacet:

; 379  :             return _Facptr; // found facet or not transparent

	mov	eax, DWORD PTR __Facptr$[ebp]
	jmp	SHORT $LN1@Getfacet
$LN2@Getfacet:

; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	mov	DWORD PTR __Ptr0$[ebp], eax

; 384  :         if (_Id < _Ptr0->_Facetcount) {

	mov	eax, DWORD PTR __Ptr0$[ebp]
	mov	ecx, DWORD PTR __Id$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN4@Getfacet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

	mov	edx, DWORD PTR __Ptr0$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Id$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN1@Getfacet
$LN4@Getfacet:

; 386  :         }
; 387  : 
; 388  :         return nullptr; // no entry in current locale

	xor	eax, eax
$LN1@Getfacet:

; 389  :     }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_C_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_C_str@locale@std@@QBEPBDXZ PROC			; std::locale::_C_str, COMDAT
; _this$ = ecx

; 372  :     _Ret_z_ const char* _C_str() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@C_str
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 24					; 00000018H
	call	?c_str@?$_Yarn@D@std@@QBEPBDXZ		; std::_Yarn<char>::c_str
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN4@C_str
$LN3@C_str:
	mov	DWORD PTR tv70[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN4@C_str:
	mov	eax, DWORD PTR tv70[ebp]

; 374  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_C_str@locale@std@@QBEPBDXZ ENDP			; std::locale::_C_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv84 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 353  :     ~locale() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 354  :         if (_Ptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@locale

; 355  :             delete _Ptr->_Decref();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@locale
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN5@locale
$LN4@locale:
	mov	DWORD PTR tv84[ebp], 0
$LN5@locale:

; 356  :         }
; 357  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 272  :     locale() noexcept : _Ptr(_Init(true)) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0locale@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	call	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z	; std::locale::_Init
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 269  :         _Ptr->_Incref();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 270  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN4@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN4@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN4@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 146  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Facet_base@std@@UAE@XZ		; std::_Facet_base::~_Facet_base
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 144  :         {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Facet_base@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Initrefs$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 144  :         {}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 130  :         _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  :             if (_MT_DECR(_Myrefs) == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
	dec	ecx
	jne	SHORT $LN2@Decref

; 132  :                 return this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@Decref
$LN2@Decref:

; 133  :             }
; 134  : 
; 135  :             return nullptr;

	xor	eax, eax
$LN1@Decref:

; 136  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 126  :         void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 127  :             _MT_INCR(_Myrefs);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	lock	 inc	 DWORD PTR [eax]

; 128  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??3_Crt_new_delete@std@@SAXPAX@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??3_Crt_new_delete@std@@SAXPAX@Z PROC			; std::_Crt_new_delete::operator delete, COMDAT

; 47   :     void __CLRCALL_OR_CDECL operator delete(void* _Ptr) noexcept { // replace operator delete

	push	ebp
	mov	ebp, esp

; 48   :         _CSTD free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 49   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??3_Crt_new_delete@std@@SAXPAX@Z ENDP			; std::_Crt_new_delete::operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z
_TEXT	SEGMENT
tv71 = -4						; size = 4
__Size$ = 8						; size = 4
___formal$ = 12						; size = 4
??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z PROC	; std::_Crt_new_delete::operator new, COMDAT

; 43   :     void* __CLRCALL_OR_CDECL operator new(size_t _Size, const nothrow_t&) noexcept { // replace nothrow operator new

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 44   :         return _malloc_dbg(_Size > 0 ? _Size : 1, _CRT_BLOCK, __FILE__, __LINE__);

	cmp	DWORD PTR __Size$[ebp], 0
	jbe	SHORT $LN3@operator
	mov	eax, DWORD PTR __Size$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv71[ebp], 1
$LN4@operator:
	push	44					; 0000002cH
	push	OFFSET ??_C@_0GC@DIOGEBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	__malloc_dbg
	add	esp, 16					; 00000010H

; 45   :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z ENDP	; std::_Crt_new_delete::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??2_Crt_new_delete@std@@SAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Size$ = 8						; size = 4
??2_Crt_new_delete@std@@SAPAXI@Z PROC			; std::_Crt_new_delete::operator new, COMDAT

; 34   :     void* __CLRCALL_OR_CDECL operator new(size_t _Size) { // replace operator new

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 35   :         void* _Ptr = operator new(_Size, nothrow);

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	eax, DWORD PTR __Size$[ebp]
	push	eax
	call	??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z ; std::_Crt_new_delete::operator new
	add	esp, 8
	mov	DWORD PTR __Ptr$[ebp], eax

; 36   :         if (!_Ptr) {

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN2@operator

; 37   :             _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
	npad	1
$LN2@operator:

; 38   :         }
; 39   : 
; 40   :         return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN1@operator:

; 41   :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??2_Crt_new_delete@std@@SAPAXI@Z ENDP			; std::_Crt_new_delete::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 202  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 203  :         if (_Myptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__free_dbg
	add	esp, 8
$LN2@Tidy:

; 206  : #else
; 207  :             _CSTD free(_Myptr);
; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 212  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 182  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Yarn@_W@std@@AAEXXZ		; std::_Yarn<wchar_t>::_Tidy
	npad	1

; 183  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 140  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+4], cx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 202  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 203  :         if (_Myptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__free_dbg
	add	esp, 8
$LN2@Tidy:

; 206  : #else
; 207  :             _CSTD free(_Myptr);
; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 212  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 189  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 190  :         return _Myptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@c_str
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN4@c_str
$LN3@c_str:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@c_str:
	mov	eax, DWORD PTR tv68[ebp]

; 191  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 182  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Yarn@D@std@@AAEXXZ		; std::_Yarn<char>::_Tidy
	npad	1

; 183  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 140  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 322  :     const char* __CLR_OR_THIS_CALL _Gettrue() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 323  :         return "true";

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true@

; 324  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 318  :     const char* __CLR_OR_THIS_CALL _Getfalse() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 319  :         return "false";

	mov	eax, OFFSET ??_C@_05LAPONLG@false@

; 320  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 284  :     const lconv* __CLR_OR_THIS_CALL _Getlconv() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 285  :         return localeconv();

	call	_localeconv

; 286  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -96						; size = 44
$T2 = -52						; size = 44
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 280  :     _Cvtvec __CLR_OR_THIS_CALL _Getcvt() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 281  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getcvt
	add	esp, 4
	mov	ecx, 11					; 0000000bH
	mov	esi, eax
	lea	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	ecx, 11					; 0000000bH
	lea	esi, DWORD PTR $T2[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 282  :     }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -36						; size = 16
$T2 = -20						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 276  :     _Ctypevec __CLR_OR_THIS_CALL _Getctype() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 277  :         return ::_Getctype();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getctype
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T2[ebp+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T2[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T2[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 278  :     }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 256  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Locinfo@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 257  :         _Locinfo_dtor(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
	add	esp, 4

; 258  :     }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	npad	1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 234  :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 232  :         : _Lock(_LOCK_LOCALE)

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 234  :     {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 235  :         if (_Pch) {

	cmp	DWORD PTR __Pch$[ebp], 0
	je	SHORT $LN2@Locinfo

; 236  :             _Locinfo_ctor(this, _Pch);

	mov	eax, DWORD PTR __Pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 237  :             return;

	jmp	SHORT $LN1@Locinfo
$LN2@Locinfo:

; 238  :         }
; 239  : 
; 240  :         _Xruntime_error("bad locale name");

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	?_Xruntime_error@std@@YAXPBD@Z		; std::_Xruntime_error
	npad	1
$LN1@Locinfo:

; 241  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Locinfo:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Facet_base@std@@UAE@XZ		; std::_Facet_base::~_Facet_base
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 25   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 62   : [[noreturn]] inline void _Throw_bad_cast() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 63   :     _THROW(bad_cast{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
	npad	1
$LN1@Throw_bad_:

; 64   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_cast@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 153  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 152  :         : exception("bad cast", 1)

	push	1
	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBDH@Z		; std::exception::exception

; 153  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 154  :     }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 668  : _NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {

	push	ebp
	mov	ebp, esp

; 669  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 670  :     return _Static._Storage;

	mov	eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 671  : }

	pop	ebp
	ret	0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G_Iostream_error_category2@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category2@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category2@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1_Iostream_error_category2@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category2@std@@UAE@XZ PROC		; std::_Iostream_error_category2::~_Iostream_error_category2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category2@std@@UAE@XZ ENDP		; std::_Iostream_error_category2::~_Iostream_error_category2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Iostream_error_length$2 = -8				; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT
; _this$ = ecx

; 555  :     _NODISCARD string message(int _Errcode) const override {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 556  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 557  :             static constexpr char _Iostream_error[] = "iostream stream error";
; 558  :             constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; // TRANSITION, DevCom-906503

	mov	DWORD PTR __Iostream_error_length$2[ebp], 21 ; 00000015H

; 559  :             return string{_Iostream_error, _Iostream_error_length};

	push	21					; 00000015H
	push	OFFSET ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 560  :         } else {

	jmp	SHORT $LN3@message
$LN2@message:

; 561  :             return _Syserror_map(_Errcode);

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 562  :         }
; 563  :     }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category2@std@@UBEPBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT
; _this$ = ecx

; 551  :     _NODISCARD const char* name() const noexcept override {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 552  :         return "iostream";

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 553  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category2@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1system_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_System_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error@std@@UAE@XZ
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
$T2 = -48						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 490  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR __Errcode$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0runtime_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7_System_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [edx+16], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv137 = -60						; size = 4
tv135 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 475  :     _System_error(error_code _Errcode, const string& _Message)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 476  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR __Errcode$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Errcode$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv137[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Errcode$[ebp]
	mov	eax, DWORD PTR __Errcode$[ebp+4]
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
tv84 = -56						; size = 4
tv79 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 28
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 463  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 464  :         if (!_Message.empty()) {

	lea	ecx, DWORD PTR __Message$[ebp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Makestr

; 465  :             _Message.append(": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	lea	ecx, DWORD PTR __Message$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN2@Makestr:

; 466  :         }
; 467  : 
; 468  :         _Message.append(_Errcode.message());

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Errcode$[ebp]
	call	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
	mov	DWORD PTR tv79[ebp], eax
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv84[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv84[ebp]
	push	eax
	lea	ecx, DWORD PTR __Message$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 469  :         return _Message;

	lea	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Message$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 470  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
	lea	ecx, DWORD PTR __Message$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ec$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 429  : _EXPORT_STD _NODISCARD inline error_code make_error_code(io_errc _Ec) noexcept {

	push	ebp
	mov	ebp, esp

; 430  :     return error_code(static_cast<int>(_Ec), _STD iostream_category());

	call	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
	push	eax
	mov	eax, DWORD PTR __Ec$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_code@std@@QAE@HABVerror_category@1@@Z ; std::error_code::error_code
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 431  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
tv78 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 304  :     _NODISCARD friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv78[ebp]

; 306  :     }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 291  :     _NODISCARD const error_category& category() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  :         return *_Mycat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 293  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 287  :     _NODISCARD int value() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 288  :         return _Myval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 289  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
tv67 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 206  :     _NODISCARD string message() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 207  :         return category().message(value());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv67[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv67[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 208  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 200  :     _NODISCARD const error_category& category() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 201  :         return *_Mycat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 202  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 196  :     _NODISCARD int value() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 197  :         return _Myval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 198  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 171  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Val$ = 8						; size = 4
??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z PROC ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>, COMDAT

; 2456 : _NODISCARD constexpr _To _Bit_cast(const _From& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2457 :     return __builtin_bit_cast(_To, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR $T1[ebp]

; 2458 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ENDP ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 99   :     _NODISCARD bool operator==(const error_category& _Right) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _M_CEE_PURE
; 101  :         return _Addr == _Right._Addr;
; 102  : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv71[ebp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv71[ebp]

; 104  : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 105  :     }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
_this$ = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 416  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 417  :     return *this == _Code.category() && _Code.value() == _Errval;

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	movzx	eax, BYTE PTR tv74[ebp]

; 418  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 412  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 413  :     return default_error_condition(_Errval) == _Cond;

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	esi, esp
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??8std@@YA_NABVerror_condition@0@0@Z	; std::operator==
	add	esp, 8

; 414  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 407  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 408  :     // make error_condition for error code
; 409  :     return error_condition(_Errval, *this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 410  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 87   :     _CONSTEXPR20 virtual ~error_category() noexcept = default;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 697  : _EXPORT_STD _NODISCARD inline const error_category& iostream_category() noexcept {

	push	ebp
	mov	ebp, esp

; 698  :     return _Immortalize_memcpy_image<_Iostream_error_category2>();

	call	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>

; 699  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBD@Z		; std::exception::exception
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1542 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1543 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1544 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1538 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1539 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1540 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3110 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3111 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3112 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3106 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3107 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3108 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 3102 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3103 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
	npad	1

; 3104 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -13						; size = 1
__Al$2 = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3080 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3081 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 3082 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Tidy_deall

; 3084 :             _ASAN_STRING_REMOVE(*this);
; 3085 :             auto& _Al = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$2[ebp], eax

; 3086 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Al$2[ebp]
	push	eax
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 3087 :             _My_data._Bx._Switch_to_buf();

	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3088 :         }
; 3089 : 
; 3090 :         _My_data._Mysize = 0;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [edx+24], 15			; 0000000fH

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __My_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 3094 :     }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3074 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3075 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 3076 :         _Mypair._Myval2._Mysize = _New_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3077 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __New_size$[ebp]
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 3078 :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2990 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2991 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR __Requested$[ebp]
	push	edx
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH

; 2992 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Masked$ = -8						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2977 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	eax, DWORD PTR __Requested$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Masked$[ebp], eax

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	ecx, DWORD PTR __Masked$[ebp]
	cmp	ecx, DWORD PTR __Max$[ebp]
	jbe	SHORT $LN2@Calculate_

; 2980 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, DWORD PTR __Old$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR __Max$[ebp]
	sub	eax, edx
	cmp	DWORD PTR __Old$[ebp], eax
	jbe	SHORT $LN3@Calculate_

; 2984 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	ecx, DWORD PTR __Old$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Old$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	eax, DWORD PTR __Masked$[ebp]
	push	eax
	call	??$max@I@std@@YAABIABI0@Z		; std::max<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
$LN1@Calculate_:

; 2988 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Calculate_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@Calculate_:
	DD	1
	DD	$LN7@Calculate_
$LN7@Calculate_:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN6@Calculate_
$LN6@Calculate_:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 2493 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2494 :         return _Mypair._Myval2._Mysize == 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv68[ebp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv68[ebp]

; 2495 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 2386 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2387 :         // determine new length, padding with _Ch elements as needed
; 2388 :         const size_type _Old_size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Old_size$[ebp], eax

; 2389 :         if (_New_size <= _Old_size) {

	mov	eax, DWORD PTR __New_size$[ebp]
	cmp	eax, DWORD PTR __Old_size$[ebp]
	ja	SHORT $LN2@resize

; 2390 :             _Eos(_New_size);

	mov	ecx, DWORD PTR __New_size$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	npad	1

; 2391 :         } else {

	jmp	SHORT $LN3@resize
$LN2@resize:

; 2392 :             append(_New_size - _Old_size, _Ch);

	movzx	edx, BYTE PTR __Ch$[ebp]
	push	edx
	mov	eax, DWORD PTR __New_size$[ebp]
	sub	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN3@resize:

; 2393 :         }
; 2394 :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
__Storage_max$ = -20					; size = 4
__Alloc_max$ = -12					; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 2377 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2378 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	add	esp, 4
	mov	DWORD PTR __Alloc_max$[ebp], eax

; 2379 :         const size_type _Storage_max = // can always store small string

	mov	DWORD PTR $T3[ebp], 16			; 00000010H
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR __Alloc_max$[ebp]
	push	ecx
	call	??$max@I@std@@YAABIABI0@Z		; std::max<unsigned int>
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Storage_max$[ebp], edx

; 2380 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2381 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	eax, DWORD PTR __Storage_max$[ebp]
	sub	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	call	??$_Max_limit@H@std@@YAHXZ		; std::_Max_limit<int>
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 2382 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2383 :         );
; 2384 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@max_size
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@max_size:
	DD	1
	DD	$LN5@max_size
$LN5@max_size:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN4@max_size
$LN4@max_size:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 2373 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2374 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 2375 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 2359 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2360 :         return _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2361 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2355 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2356 :         return _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2357 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T1 = -14						; size = 1
$T2 = -13						; size = 1
__Ptr$3 = -12						; size = 4
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 2291 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jae	SHORT $LN2@push_back

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 2296 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Ptr$3[ebp], eax

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$3[ebp]
	add	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	mov	ecx, DWORD PTR __Ptr$3[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2299 :             return;

	jmp	SHORT $LN1@push_back
$LN2@push_back:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
	npad	1
$LN1@push_back:

; 2303 :             1,
; 2304 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch)
; 2305 :                 _STATIC_LAMBDA {
; 2306 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);
; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 2309 :                 },
; 2310 :             _Ch);
; 2311 :     }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2276 :     /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2277 : #if _MSVC_STL_HARDENING_BASIC_STRING || _ITERATOR_DEBUG_LEVEL != 0
; 2278 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jbe	SHORT $LN2@operator
	push	OFFSET ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	2278					; 000008e6H
	push	OFFSET ??_C@_0GC@FCIPFKFB@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@operator
	int	3
$LN4@operator:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@operator:

; 2279 : #endif
; 2280 : 
; 2281 :         return _Mypair._Myval2._Myptr()[_Off];

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
$LN1@operator:

; 2282 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2267 :     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2268 : #if _MSVC_STL_HARDENING_BASIC_STRING || _ITERATOR_DEBUG_LEVEL != 0
; 2269 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jbe	SHORT $LN2@operator
	push	OFFSET ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	2269					; 000008ddH
	push	OFFSET ??_C@_0GC@FCIPFKFB@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@operator
	int	3
$LN4@operator:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@operator:

; 2270 : #endif
; 2271 : 
; 2272 :         return _Mypair._Myval2._Myptr()[_Off];

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
$LN1@operator:

; 2273 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
$T1 = -17						; size = 1
__Insert_at$2 = -16					; size = 4
__Old_ptr$3 = -12					; size = 4
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1784 :         const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1785 :         // insert _Count * _Ch at _Off
; 1786 :         _Mypair._Myval2._Check_offset(_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 1787 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Old_size$[ebp], edx

; 1788 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], ecx
	ja	SHORT $LN2@insert

; 1789 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1790 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	edx, DWORD PTR __Old_size$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1791 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$3[ebp], eax

; 1792 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	mov	ecx, DWORD PTR __Old_ptr$3[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Insert_at$2[ebp], ecx

; 1793 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	mov	edx, DWORD PTR __Old_size$[ebp]
	sub	edx, DWORD PTR __Off$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Insert_at$2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Insert_at$2[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 1794 :             _Traits::assign(_Insert_at, _Count, _Ch); // fill hole

	movzx	edx, BYTE PTR __Ch$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Insert_at$2[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 12					; 0000000cH

; 1795 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@insert
$LN2@insert:

; 1796 :         }
; 1797 : 
; 1798 :         return _Reallocate_grow_by(

	xor	edx, edx
	mov	BYTE PTR $T1[ebp], dl
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
$LN1@insert:

; 1799 :             _Count,
; 1800 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 1801 :                 const size_type _Count, const _Elem _Ch) _STATIC_LAMBDA {
; 1802 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 1803 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 1805 :             },
; 1806 :             _Off, _Count, _Ch);
; 1807 :     }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
$T1 = -14						; size = 1
$T2 = -13						; size = 1
__Old_ptr$3 = -12					; size = 4
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1538 :         // append _Count * _Ch
; 1539 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 1540 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], eax
	ja	SHORT $LN2@append

; 1541 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1542 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1543 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$3[ebp], eax

; 1544 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$3[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 12					; 0000000cH

; 1545 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Old_ptr$3[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 1546 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1547 :         }
; 1548 : 
; 1549 :         return _Reallocate_grow_by(

	xor	edx, edx
	mov	BYTE PTR $T1[ebp], dl
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN1@append:

; 1550 :             _Count,
; 1551 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 1552 :                 const _Elem _Ch) _STATIC_LAMBDA {
; 1553 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1554 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 1555 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1556 :             },
; 1557 :             _Count, _Ch);
; 1558 :     }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1533 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1534 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1535 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -14						; size = 1
$T2 = -13						; size = 1
__Old_ptr$3 = -12					; size = 4
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1510 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1511 :         // append [_Ptr, _Ptr + _Count)
; 1512 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 1513 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], eax
	ja	SHORT $LN2@append

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1516 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$3[ebp], eax

; 1517 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$3[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Old_ptr$3[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 1519 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1520 :         }
; 1521 : 
; 1522 :         return _Reallocate_grow_by(

	xor	edx, edx
	mov	BYTE PTR $T1[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 1523 :             _Count,
; 1524 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1525 :                 const size_type _Count) _STATIC_LAMBDA {
; 1526 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1527 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1529 :             },
; 1530 :             _Ptr, _Count);
; 1531 :     }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1482 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1484 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1462 :     _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1463 :         return append(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1464 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -24					; size = 4
_$S4$ = -13						; size = 1
__Alproxy$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1382 :     _CONSTEXPR20 ~basic_string() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1383 :         _Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1384 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1385 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S4$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	eax, DWORD PTR _$S4$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 1386 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __To_delete$[ebp], edx

; 1387 :         _Mypair._Myval2._Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1388 :         _Delete_plain_internal(_Alproxy, _To_delete);

	mov	ecx, DWORD PTR __To_delete$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 1389 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1390 :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@basic_stri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@basic_stri:
	DD	1
	DD	$LN5@basic_stri
$LN5@basic_stri:
	DD	-13					; fffffff3H
	DD	1
	DD	$LN4@basic_stri
$LN4@basic_stri:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	52					; 00000034H
	DB	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
$T1 = -22						; size = 1
$T2 = -21						; size = 1
__Right_data_mem$3 = -20				; size = 4
__My_data_mem$4 = -16					; size = 4
__Right_data$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 1258 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1259 :         // assign by stealing _Right's buffer
; 1260 :         // pre: this != &_Right
; 1261 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1262 :         // pre: *this owns no memory, iterators orphaned
; 1263 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1264 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1265 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR __Right_data$[ebp], ecx

; 1266 : 
; 1267 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1268 :         if constexpr (_Can_memcpy_val) {
; 1269 : #if _HAS_CXX20
; 1270 :             if (!_STD is_constant_evaluated())
; 1271 : #endif // _HAS_CXX20
; 1272 :             {
; 1273 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1274 :                 if (_Right_data._Large_mode_engaged()) {

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Take_conte

; 1275 :                     // take ownership of _Right's iterators along with its buffer
; 1276 :                     _Swap_proxy_and_iterators(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
	npad	1

; 1277 :                 } else {

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1278 :                     _Right_data._Orphan_all();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1
$LN3@Take_conte:

; 1279 :                 }
; 1280 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1281 : 
; 1282 :                 const auto _My_data_mem =

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __My_data_mem$4[ebp], eax

; 1283 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1284 :                 const auto _Right_data_mem =

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __Right_data_mem$3[ebp], eax

; 1285 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	push	24					; 00000018H
	mov	eax, DWORD PTR __Right_data_mem$3[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data_mem$4[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1287 : 
; 1288 :                 _Right_data._Mysize = 0;

	mov	edx, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1289 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 1290 :                 _Right_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR __Right_data$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 1292 :                 return;

	jmp	$LN1@Take_conte

; 1293 :             }
; 1294 :         }
; 1295 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1296 : 
; 1297 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Take_conte

; 1298 :             _Swap_proxy_and_iterators(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 1299 : 
; 1300 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	edx, DWORD PTR __Right_data$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
	add	esp, 8

; 1301 :             _Right_data._Bx._Switch_to_buf();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	add	ecx, 4
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 1302 :         } else { // copy small string buffer

	jmp	SHORT $LN5@Take_conte
$LN4@Take_conte:

; 1303 :             _Right_data._Orphan_all();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1304 : 
; 1305 :             _My_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 1306 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	ecx, DWORD PTR __Right_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Right_data$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH
$LN5@Take_conte:

; 1307 :         }
; 1308 : 
; 1309 :         _My_data._Myres  = _Right_data._Myres;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 1310 :         _My_data._Mysize = _Right_data._Mysize;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx

; 1311 : 
; 1312 :         _Right_data._Mysize = 0;

	mov	edx, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1313 :         _Right_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 1314 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR __Right_data$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8
$LN1@Take_conte:

; 1315 :     }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1252 :     _CONSTEXPR20 basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1253 :         *this = _STD move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 1254 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1255 :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Pocma_val$ = -16					; size = 4
__Right_al$ = -12					; size = 4
__Al$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1225 :         noexcept(_Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1226 :         if (this == _STD addressof(_Right)) {

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	cmp	DWORD PTR _this$[ebp], eax
	jne	SHORT $LN2@operator

; 1227 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 1228 :         }
; 1229 : 
; 1230 :         auto& _Al                 = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1231 :         auto& _Right_al           = _Right._Getal();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Right_al$[ebp], eax

; 1232 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

	mov	DWORD PTR __Pocma_val$[ebp], 0

; 1233 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 1234 :             if (_Al != _Right_al) {
; 1235 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 1236 :                 _Mypair._Myval2._Orphan_all();
; 1237 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1238 :             }
; 1239 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 1240 :             if (_Al != _Right_al) {
; 1241 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 1242 :                 return *this;
; 1243 :             }
; 1244 :         }
; 1245 : 
; 1246 :         _Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1247 :         _Pocma(_Al, _Right_al);

	mov	ecx, DWORD PTR __Right_al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
	add	esp, 8

; 1248 :         _Take_contents(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 1249 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 1250 :     }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -18						; size = 1
$T3 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1028 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
	add	esp, 4
	push	eax
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 1029 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 1030 :         _Take_contents(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1031 :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -10						; size = 1
$T2 = -9						; size = 1
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT
; _this$ = ecx

; 855  :     _CONSTEXPR20 void _Construct_empty() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 856  :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 857  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 858  : 
; 859  :         // initialize basic_string data members
; 860  :         _My_data._Mysize = 0;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [edx+24], 15			; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __My_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 866  :     }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 850  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

	push	ebp
	mov	ebp, esp

; 851  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	eax, DWORD PTR __Capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
	npad	1

; 853  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 785  :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 786  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Ch$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	npad	1

; 787  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 768  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 770  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 755  :         : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 756  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 757  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -18						; size = 1
$T3 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 717  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 718  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
	npad	1

; 719  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 708  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 709  :         _Construct_empty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 710  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 501  :             _STD _Destroy_in_place(_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
	add	esp, 4

; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 481  :     [[noreturn]] static void _Xran() {

	push	ebp
	mov	ebp, esp

; 482  :         _Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
	npad	1
$LN1@Xran:

; 483  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 467  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 468  :         // checks whether _Off is in the bounds of [0, size()]
; 469  :         if (_Mysize < _Off) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN2@Check_offs

; 470  :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	npad	1
$LN2@Check_offs:
$LN1@Check_offs:

; 471  :         }
; 472  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 456  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 457  :         // start the lifetime of the array elements
; 458  : #if _HAS_CXX20
; 459  :         if (_STD is_constant_evaluated()) {
; 460  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 461  :                 _Bx._Buf[_Idx] = value_type();
; 462  :             }
; 463  :         }
; 464  : #endif // _HAS_CXX20
; 465  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 452  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 453  :         return _Myres > _Small_string_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 15			; 0000000fH
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[ebp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[ebp]

; 454  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 443  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 445  :         if (_Large_mode_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Myptr

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 447  :         }
; 448  : 
; 449  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 450  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 434  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 435  :         value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 436  :         if (_Large_mode_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Myptr

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 438  :         }
; 439  : 
; 440  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 441  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 403  : 
; 404  : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 405  :     _CONSTEXPR20 ~_String_val() noexcept {
; 406  :         if constexpr (is_pointer_v<pointer>) {
; 407  :             if (!_STD _Is_constant_evaluated()) {
; 408  :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 409  :                 _Bx._Ptr = _Tombstone;
; 410  :                 _Mysize  = 0;
; 411  :                 _Myres   = (_Small_string_capacity + 1) | _Alloc_mask; // first capacity when entering large mode
; 412  : 
; 413  :                 // The capacity indicates whether we're in small mode or large mode; see _Large_mode_engaged().
; 414  :                 // The string would be usable in small mode, so we need large mode for the tombstone to be effective.
; 415  :                 // `_Small_string_capacity + 1` would be sufficient to make _Large_mode_engaged() return true. However,
; 416  :                 // basic_string uses a "roundup mask" when allocating; see _Calculate_growth(). So to avoid confusing
; 417  :                 // the SSO logic, we use the first capacity that would normally be used when entering large mode.
; 418  :             }
; 419  :         }
; 420  :     }
; 421  : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 422  : 
; 423  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 424  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 425  :     // roundup mask for allocated buffers, [0, 15]
; 426  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 427  :                                            : sizeof(value_type) <= 2 ? 7
; 428  :                                            : sizeof(value_type) <= 4 ? 3
; 429  :                                            : sizeof(value_type) <= 8 ? 1
; 430  :                                                                      : 0;
; 431  :     // capacity in small mode
; 432  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 433  : 
; 434  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 435  :         value_type* _Result = _Bx._Buf;
; 436  :         if (_Large_mode_engaged()) {
; 437  :             _Result = _Unfancy(_Bx._Ptr);
; 438  :         }
; 439  : 
; 440  :         return _Result;
; 441  :     }
; 442  : 
; 443  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 444  :         const value_type* _Result = _Bx._Buf;
; 445  :         if (_Large_mode_engaged()) {
; 446  :             _Result = _Unfancy(_Bx._Ptr);
; 447  :         }
; 448  : 
; 449  :         return _Result;
; 450  :     }
; 451  : 
; 452  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 453  :         return _Myres > _Small_string_capacity;
; 454  :     }
; 455  : 
; 456  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 457  :         // start the lifetime of the array elements
; 458  : #if _HAS_CXX20
; 459  :         if (_STD is_constant_evaluated()) {
; 460  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 461  :                 _Bx._Buf[_Idx] = value_type();
; 462  :             }
; 463  :         }
; 464  : #endif // _HAS_CXX20
; 465  :     }
; 466  : 
; 467  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 468  :         // checks whether _Off is in the bounds of [0, size()]
; 469  :         if (_Mysize < _Off) {
; 470  :             _Xran();
; 471  :         }
; 472  :     }
; 473  : 
; 474  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 475  :         // checks whether _Off is in the bounds of [0, size())
; 476  :         if (_Mysize <= _Off) {
; 477  :             _Xran();
; 478  :         }
; 479  :     }
; 480  : 
; 481  :     [[noreturn]] static void _Xran() {
; 482  :         _Xout_of_range("invalid string position");
; 483  :     }
; 484  : 
; 485  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 486  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 487  :         return (_STD min)(_Size, _Mysize - _Off);
; 488  :     }
; 489  : 
; 490  :     union _Bxty { // storage for small buffer or pointer to larger one
; 491  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 492  :         // renaming `_String_val` (and fixing the visualizer).
; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 495  : 
; 496  :         value_type _Buf[_BUF_SIZE];
; 497  :         pointer _Ptr;
; 498  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 499  : 
; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }
; 512  :     };
; 513  :     _Bxty _Bx;
; 514  : 
; 515  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 516  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	push	ebp
	mov	ebp, esp

; 750  :         return _Al;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 751  :     }

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 747  :     }

	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$00@std@@YAII@Z	; std::_Get_size_of_n<1>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
	add	esp, 4

; 991  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN2@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN2@deallocate
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	983					; 000003d7H
	push	OFFSET ??_C@_0GC@KLECFGLI@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@deallocate
	int	3
$LN4@deallocate:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@deallocate:

; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	??$_Deallocate@$07@std@@YAXPAXI@Z	; std::_Deallocate<8>
	add	esp, 8
$LN1@deallocate:

; 986  :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 974  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 530  : [[noreturn]] inline void _Xlen_string() {

	push	ebp
	mov	ebp, esp

; 531  :     _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
	npad	1
$LN1@Xlen_strin:

; 532  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1465 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1458 :     _Container_proxy* _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1465 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1460 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1461 :         _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1462 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __New_val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 775  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 776  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z
_TEXT	SEGMENT
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_locked, COMDAT
; _this$ = ecx

; 1246 :     void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1247 :         _Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 1248 :         _Swap_proxy_and_iterators_unlocked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked

; 1249 :     }

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Swap_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@Swap_proxy:
	DD	1
	DD	$LN5@Swap_proxy
$LN5@Swap_proxy:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN4@Swap_proxy
$LN4@Swap_proxy:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1241 :     void _Orphan_all_locked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1242 :         _Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 1243 :         _Orphan_all_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1244 :     }

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Orphan_all:
	DD	1
	DD	$LN5@Orphan_all
$LN5@Orphan_all:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN4@Orphan_all
$LN4@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z
_TEXT	SEGMENT
__Temp$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked, COMDAT
; _this$ = ecx

; 1405 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1406 :     _Container_proxy* _Temp = _Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$[ebp], ecx

; 1407 :     _Myproxy                = _Right._Myproxy;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 1408 :     _Right._Myproxy         = _Temp;

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Temp$[ebp]
	mov	DWORD PTR [edx], eax

; 1409 : 
; 1410 :     if (_Myproxy) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@Swap_proxy

; 1411 :         _Myproxy->_Mycont = this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@Swap_proxy:

; 1412 :     }
; 1413 : 
; 1414 :     if (_Right._Myproxy) {

	mov	edx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN3@Swap_proxy

; 1415 :         _Right._Myproxy->_Mycont = &_Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [ecx], edx
$LN3@Swap_proxy:

; 1416 :     }
; 1417 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
_this$ = -4						; size = 4
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1381 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1382 :     if (!_Myproxy) { // no proxy, already done

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Orphan_all

; 1383 :         return;

	jmp	SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1384 :     }
; 1385 : 
; 1386 :     // proxy allocated, drain it
; 1387 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	push	eax
	call	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
	add	esp, 8
	mov	DWORD PTR __Pnext$2[ebp], eax
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	ecx, DWORD PTR __Pnext$2[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnext$2[ebp], edx
$LN4@Orphan_all:
	cmp	DWORD PTR __Pnext$2[ebp], 0
	je	SHORT $LN3@Orphan_all

; 1388 :         _Pnext->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	DWORD PTR [eax], 0

; 1389 :     }

	jmp	SHORT $LN2@Orphan_all
$LN3@Orphan_all:
$LN1@Orphan_all:

; 1390 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 1419 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1420 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1421 : #if _HAS_CXX20
; 1422 :     if (_STD is_constant_evaluated()) {
; 1423 :         _Swap_proxy_and_iterators_unlocked(_Right);
; 1424 :     } else
; 1425 : #endif // _HAS_CXX20
; 1426 :     {
; 1427 :         _Swap_proxy_and_iterators_locked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
	npad	1

; 1428 :     }
; 1429 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1430 :     _Swap_proxy_and_iterators_unlocked(_Right);
; 1431 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1432 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1392 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1393 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1394 : #if _HAS_CXX20
; 1395 :     if (_STD is_constant_evaluated()) {
; 1396 :         _Orphan_all_unlocked_v3();
; 1397 :     } else
; 1398 : #endif // _HAS_CXX20
; 1399 :     {
; 1400 :         _Orphan_all_locked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
	npad	1

; 1401 :     }
; 1402 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1403 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1210 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1211 : 
; 1212 :     _Container_base12(const _Container_base12&)            = delete;
; 1213 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1214 : 
; 1215 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1216 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1217 : 
; 1218 :     template <class _Alloc>
; 1219 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1220 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1221 :         _Construct_in_place(*_New_proxy, this);
; 1222 :         _Myproxy            = _New_proxy;
; 1223 :         _New_proxy->_Mycont = this;
; 1224 :     }
; 1225 : 
; 1226 :     template <class _Alloc>
; 1227 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1228 :         // pre: no iterators refer to the existing proxy
; 1229 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1230 :         _Construct_in_place(*_New_proxy, this);
; 1231 :         _New_proxy->_Mycont = this;
; 1232 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1233 :     }
; 1234 : 
; 1235 :     _Container_proxy* _Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1210 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1202 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont_$[ebp]
	mov	DWORD PTR [eax], ecx

; 1203 : 
; 1204 :     const _Container_base12* _Mycont       = nullptr;
; 1205 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 1202 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 39					; 00000027H
	mov	edx, DWORD PTR __Bytes$[ebp]
	mov	DWORD PTR [edx], ecx

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_user$[ebp], ecx

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, 4
	imul	eax, edx, -1
	mov	ecx, DWORD PTR __Ptr_user$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR __Ptr_container$[ebp], edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	je	SHORT $LN2@Adjust_man
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	209					; 000000d1H
	push	OFFSET ??_C@_0GC@KLECFGLI@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN6@Adjust_man
	int	3
$LN6@Adjust_man:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN2@Adjust_man:

; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	DWORD PTR __Min_back_shift$[ebp], 8

; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR __Back_shift$[ebp], edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	DWORD PTR __Back_shift$[ebp], 8
	jb	SHORT $LN4@Adjust_man
	cmp	DWORD PTR __Back_shift$[ebp], 39	; 00000027H
	jbe	SHORT $LN3@Adjust_man
$LN4@Adjust_man:
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	219					; 000000dbH
	push	OFFSET ??_C@_0GC@KLECFGLI@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN7@Adjust_man
	int	3
$LN7@Adjust_man:
	push	0
	push	0
	push	0
	push	0
	push	0
	call	__invoke_watson
	npad	1
$LN3@Adjust_man:

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@Adjust_man:

; 221  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp

; 136  :         return ::operator new(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 137  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 108  :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
	npad	1
$LN1@Throw_bad_:

; 109  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 529  :     _NODISCARD static constexpr int_type eof() noexcept {

	push	ebp
	mov	ebp, esp

; 530  :         return static_cast<int_type>(EOF);

	or	eax, -1

; 531  :     }

	pop	ebp
	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 521  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	movzx	eax, BYTE PTR tv65[ebp]

; 523  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z PROC	; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 517  :     _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {

	push	ebp
	mov	ebp, esp

; 518  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]

; 519  :     }

	pop	ebp
	ret	0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ENDP	; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z PROC	; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 513  :     _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {

	push	ebp
	mov	ebp, esp

; 514  :         return static_cast<_Elem>(_Meta);

	movzx	eax, BYTE PTR __Meta$[ebp]

; 515  :     }

	pop	ebp
	ret	0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ENDP	; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 496  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 497  : #if _HAS_CXX20
; 498  :         if (_STD is_constant_evaluated()) {
; 499  :             return _Primary_char_traits::assign(_Left, _Right);
; 500  :         }
; 501  : #endif // _HAS_CXX20
; 502  :         _Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 503  :     }

	pop	ebp
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 485  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 486  :         // assign _Count * _Ch to [_First, ...)
; 487  : #if _HAS_CXX20
; 488  :         if (_STD is_constant_evaluated()) {
; 489  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 490  :         }
; 491  : #endif // _HAS_CXX20
; 492  : 
; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 494  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 443  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 444  :         // find length of null-terminated string
; 445  : #if _HAS_CXX17
; 446  : #ifdef __cpp_char8_t
; 447  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 448  : #if _HAS_U8_INTRINSICS
; 449  :             return __builtin_u8strlen(_First);
; 450  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 451  :             return _Primary_char_traits::length(_First);
; 452  : #endif // ^^^ no u8 intrinsics ^^^
; 453  :         } else
; 454  : #endif // defined(__cpp_char8_t)
; 455  :         {
; 456  :             return __builtin_strlen(_First);
; 457  :         }
; 458  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 459  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 460  : #endif // ^^^ !_HAS_CXX17 ^^^
; 461  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 136  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 137  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 138  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 139  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 140  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 141  : #if _HAS_CXX20
; 142  :         if (_STD is_constant_evaluated()) {
; 143  :             // dest: [_First1, _First1 + _Count)
; 144  :             // src: [_First2, _First2 + _Count)
; 145  :             // We need to handle overlapping ranges.
; 146  :             // If _First1 is in the src range, we need a backward loop.
; 147  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 148  : 
; 149  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 150  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 151  :             bool _Loop_forward = true;
; 152  : 
; 153  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 154  :                 if (_First1 == _Src) {
; 155  :                     _Loop_forward = false;
; 156  :                     break;
; 157  :                 }
; 158  :             }
; 159  : 
; 160  :             if (_Loop_forward) {
; 161  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 162  :                     _First1[_Idx] = _First2[_Idx];
; 163  :                 }
; 164  :             } else {
; 165  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 166  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 167  :                 }
; 168  :             }
; 169  : 
; 170  :             return _First1;
; 171  :         }
; 172  : #endif // _HAS_CXX20
; 173  : 
; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 175  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 176  : 
; 177  :         return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 178  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 105  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 106  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 107  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 108  :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 109  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 110  : #if _HAS_CXX20
; 111  :         if (_STD is_constant_evaluated()) {
; 112  :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 113  :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 114  :                 _First1[_Idx] = _First2[_Idx];
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // _HAS_CXX20
; 120  : 
; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 125  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_array_new_length@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 143  :         : bad_alloc("bad array new length")

	push	OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@AAE@QBD@Z		; std::bad_alloc::bad_alloc

; 144  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	npad	1
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 133  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  :         : exception(_Message, 1)

	push	1
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBDH@Z		; std::exception::exception

; 133  :     {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 134  :     }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@what
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@what
$LN3@what:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
	mov	eax, DWORD PTR tv69[ebp]

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 91   :         __std_exception_destroy(&_Data);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_destroy
	add	esp, 4

; 92   :     }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 72   :         : _Data()

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Other$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_copy
	add	esp, 8

; 75   :     }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 67   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 66   :         : _Data()

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx

; 68   :         _Data._What = _Message;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 69   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -16					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 59   :         : _Data()

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx

; 61   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	mov	DWORD PTR __InitData$[ebp], eax
	mov	BYTE PTR __InitData$[ebp+4], 1

; 62   :         __std_exception_copy(&_InitData, &_Data);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR __InitData$[ebp]
	push	edx
	call	___std_exception_copy
	add	esp, 8

; 63   :     }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@exception
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@exception:
	DD	1
	DD	$LN5@exception
$LN5@exception:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN4@exception
$LN4@exception:
	DB	95					; 0000005fH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1823 :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	__vsprintf_s_l
	add	esp, 20					; 00000014H
	mov	DWORD PTR __Result$[ebp], eax

; 1828 :             __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1829 :             return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1830 :         }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
tv73 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1490 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___stdio_common_vsprintf_s
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsprintf_s
	mov	DWORD PTR tv73[ebp], -1
	jmp	SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv73[ebp], ecx
$LN4@vsprintf_s:
	mov	eax, DWORD PTR tv73[ebp]

; 1496 :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 164  :     {

	push	ebp
	mov	ebp, esp

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 167  :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 902  :     {

	push	ebp
	mov	ebp, esp

; 903  :         return frexp((double)_X, _Y);

	mov	eax, DWORD PTR __Y$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_frexp
	add	esp, 12					; 0000000cH

; 904  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 881  :     {

	push	ebp
	mov	ebp, esp

; 882  :         return fabs((double)_X);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8

; 883  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT ?fpclassify@@YAHO@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
?fpclassify@@YAHO@Z PROC				; fpclassify, COMDAT

; 331  :     {

	push	ebp
	mov	ebp, esp

; 332  : #if defined(__clang__)
; 333  :         return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, _X);
; 334  : #else
; 335  :         return _ldtest(&_X);

	lea	eax, DWORD PTR __X$[ebp]
	push	eax
	call	__ldtest
	add	esp, 4
	cwde

; 336  : #endif
; 337  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?fpclassify@@YAHO@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT ?fpclassify@@YAHN@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
?fpclassify@@YAHN@Z PROC				; fpclassify, COMDAT

; 322  :     {

	push	ebp
	mov	ebp, esp

; 323  : #if defined(__clang__)
; 324  :         return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, _X);
; 325  : #else
; 326  :         return _dtest(&_X);

	lea	eax, DWORD PTR __X$[ebp]
	push	eax
	call	__dtest
	add	esp, 4
	cwde

; 327  : #endif
; 328  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?fpclassify@@YAHN@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\Hamzzi\Desktop\AI_Practice\Source\VS2010\Common\2D\Vector2d.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\Hamzzi\Desktop\AI_Practice\Source\VS2010\Common\2D\Vector2d.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
